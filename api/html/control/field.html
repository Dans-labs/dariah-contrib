<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>control.field API documentation</title>
<meta name="description" content="Fields of records of tables â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.field</code></h1>
</header>
<section id="section-intro">
<p>Fields of records of tables.</p>
<ul>
<li>Display readonly/editable</li>
<li>Refresh buttons</li>
<li>Saving values</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Fields of records of tables.

*   Display readonly/editable
*   Refresh buttons
*   Saving values
&#34;&#34;&#34;

from flask import request, abort

from config import Config as C, Names as N
from control.html import HtmlElements as H
from control.utils import pick as G, bencode, cap1, E, BLANK, ONE, COMMA
from control.perm import getPermField
from control.typ.value import ConversionError

CT = C.tables
CW = C.web
CF = C.workflow


DEFAULT_TYPE = CT.defaultType
CONSTRAINED = CT.constrained
WITH_NOW = CT.withNow
WORKFLOW_TABLES = set(CT.userTables) | set(CT.userEntryTables)
CASCADE_SPECS = CT.cascade

WORKFLOW_FIELDS = CF.fields

REFRESH = CW.messages[N.refresh]
LIMITS = CW.limits
LIMIT_JSON = G(LIMITS, N.json, default=1000000)


class Field:
    &#34;&#34;&#34;Deals with fields.&#34;&#34;&#34;

    inheritProps = (
        N.context,
        N.uid,
        N.eppn,
        N.table,
        N.record,
        N.eid,
        N.perm,
        N.readonly,
        N.mayRead,
    )

    def __init__(
        self,
        recordObj,
        field,
        asMaster=False,
        readonly=None,
        mayRead=None,
        mayEdit=None,
    ):
        &#34;&#34;&#34;## Initialization

        Store the incoming information.

        A number of properties will be inherited from the record object
        that spawns a field object.

        The value of the field will be looked up from the record and saved into the attribute
        `value`.

        Set the attribute `fieldTypeObj` to a suitable derived class of
        `control.typ.base.TypeBase`.

        !!! caution
            Fields that point to master records are never editable in this app.

        !!! hint
            The parameters `readonly`, `mayRead`, `mayEdit` are optional.
            If they are not passed or `None`, values for these will be taken
            from the `recordObj` that has spawned this field object.

        !!! caution
            Whether a field is readable or editable, depends first on how it
            is configured in the .yaml file in `tables` that correspnds to the table.
            This can be overriden by setting the `mayRead` and `mayEdit` attributes
            in the `recordObj`, and it can be overridden again by explicitly
            passing values for them here.

        Parameters
        ----------
        recordObj: object
            See below.
        field: string
            See below.
        asMaster: boolean, optional `False`
            See below.
        readonly: boolean | `None`, optional `None`
            Whether the field must be presented readonly.
        mayRead: boolean | `None`, optional `None`
            If passed, overrides the configured read permission for this field.
        mayEdit: boolean | `None`, optional `None`
            If passed, overrides the configured write permission for this field.
        &#34;&#34;&#34;

        for prop in Field.inheritProps:
            setattr(self, prop, getattr(recordObj, prop, None))

        self.recordObj = recordObj
        &#34;&#34;&#34;*object* A `control.record.Record` object (or one of a derived class)
        &#34;&#34;&#34;

        self.field = field
        &#34;&#34;&#34;*string* The name of the field
        &#34;&#34;&#34;

        self.asMaster = asMaster
        &#34;&#34;&#34;*boolean* Whether this field points to a master record.
        &#34;&#34;&#34;

        table = self.table

        withNow = G(WITH_NOW, table)
        if withNow:
            nowFields = []
            for info in withNow.values():
                if type(info) is str:
                    nowFields.append(info)
                else:
                    nowFields.extend(info)
            nowFields = set(nowFields)
        else:
            nowFields = set()

        self.withRefresh = field == N.modified or field in nowFields
        &#34;&#34;&#34;*boolean* Whether the field needs a refresh button.
        &#34;&#34;&#34;

        self.withNow = G(withNow, field)
        &#34;&#34;&#34;*dict* Which field updates need a timestamp?

        The info comes from tables.yaml, under key `withNow`.
        It is keyed by table name, then by  field name, and the value
        is a single field or lists of two fields with the names of
        corresponding timestamp fields.

        When a (boolean) field has two timestamp fields, the first one is used  if
        he value is a list, the first one will be used if the modification
        sets the field to `True` and the second one when the field becomes `False`.

        !!! hint
            In assessments, when `submitted` becomes `True`, `dateSubmitted` receives
            a  timestamp. When `submitted` becomes `False`, it is `dateWithdrawn` that
            receives the timestamp.
        &#34;&#34;&#34;

        fieldSpecs = recordObj.fields
        fieldSpec = G(fieldSpecs, field)

        record = self.record
        self.value = G(record, field)
        &#34;&#34;&#34;*mixed* The value of the field.
        &#34;&#34;&#34;

        require = G(fieldSpec, N.perm, default={})
        self.require = require
        &#34;&#34;&#34;*dict* The required permissions for this field.

        Keys are `read` and `edit`, the values are `True` or `False`.
        &#34;&#34;&#34;

        self.label = G(fieldSpec, N.label, default=cap1(field))
        &#34;&#34;&#34;*string* A label to display in front of the field.
        &#34;&#34;&#34;

        self.tp = G(fieldSpec, N.type, default=DEFAULT_TYPE)
        &#34;&#34;&#34;*string* The data type of the field.&#34;&#34;&#34;

        self.multiple = G(fieldSpec, N.multiple, default=False)
        &#34;&#34;&#34;*boolean* Whether the field value consists of multiple values or a single one.
        &#34;&#34;&#34;

        self.extensible = G(fieldSpec, N.extensible, default=False)
        &#34;&#34;&#34;*boolean* Whether the user may add new values to the value table of this field.
        &#34;&#34;&#34;

        context = self.context

        perm = self.perm
        table = self.table
        eid = self.eid
        tp = self.tp
        types = context.types

        fieldTypeObj = getattr(types, tp, None)
        self.fieldTypeObj = fieldTypeObj
        &#34;&#34;&#34;*object* The type object by which the value of this field can be interpreted.
        &#34;&#34;&#34;

        self.widgetType = fieldTypeObj.widgetType
        &#34;&#34;&#34;*string* The type of widget for presenting an edit view on this field.
        &#34;&#34;&#34;

        readonly = self.readonly if readonly is None else readonly

        (self.mayRead, self.mayEdit) = getPermField(table, perm, require)
        if mayRead is not None:
            self.mayRead = mayRead
        if mayEdit is not None:
            self.mayEdit = mayEdit

        if readonly or asMaster:
            self.mayEdit = False

        self.atts = dict(table=table, eid=eid, field=field)
        &#34;&#34;&#34;*dict* Identification of this field value:  table, id of record, name of field.

        !!! hint
            To be used to pass to buttons in widgets for this field.
        &#34;&#34;&#34;

    def save(self, data):
        &#34;&#34;&#34;Save a new value for this field to MongoDb.

        Before saving, permissions and workflow conditions will be checked.

        After saving, workflow information will be adjusted.

        !!! caution
            If the `editors` field of an assessment or review is modified,
            the same value should be put in the detail records, the
            `criteriaEntry` and `reviewEntry` records respectively.

        Parameters
        ----------
        data: mixed
            The new value(s) for this field.
            It comes straight from the client, and will be converted to proper
            Python/MongoDb values
        &#34;&#34;&#34;

        mayEdit = self.mayEdit

        if not mayEdit:
            return False

        context = self.context
        db = context.db
        uid = self.uid
        eppn = self.eppn
        table = self.table
        eid = self.eid
        field = self.field
        extensible = self.extensible
        record = self.record
        recordObj = self.recordObj
        require = self.require
        constrain = None
        constrainField = G(CONSTRAINED, field)
        if constrainField:
            constrainValue = G(record, constrainField)
            if constrainValue:
                constrain = (constrainField, constrainValue)

        multiple = self.multiple
        fieldTypeObj = self.fieldTypeObj
        conversion = fieldTypeObj.fromStr if fieldTypeObj else None
        kwargs = dict(uid=uid, eppn=eppn, extensible=extensible) if extensible else {}
        if constrain:
            kwargs[N.constrain] = constrain

        if conversion is not None:
            try:
                if multiple:
                    data = [conversion(d, **kwargs) for d in data or []]
                else:
                    data = conversion(data, **kwargs)
            except ConversionError:
                return False

        modified = G(record, N.modified)
        nowFields = []
        if data is not None:
            withNow = self.withNow
            if withNow:
                withNowField = (
                    withNow
                    if type(withNow) is str
                    else withNow[0]
                    if data
                    else withNow[1]
                )
                nowFields.append(withNowField)

        result = db.updateField(
            table, eid, field, data, eppn, modified, nowFields=nowFields,
        )
        if not result:
            return False

        (updates, deletions) = result
        record = context.getItem(table, eid, requireFresh=True)

        recordObj.reload(record)
        self.value = G(record, field)
        self.perm = recordObj.perm
        perm = self.perm
        (self.mayRead, self.mayEdit) = getPermField(table, perm, require)

        good = True
        if field == N.editors and table in CASCADE_SPECS:
            for dtable in CASCADE_SPECS[table]:
                drecords = db.getDetails(dtable, table, eid)
                for drecord in drecords:
                    deid = G(drecord, N._id)
                    result = db.updateField(
                        dtable,
                        deid,
                        N.editors,
                        data,
                        eppn,
                        modified,
                        nowFields=nowFields,
                    )
                    if not result:
                        good = False

        if table in WORKFLOW_TABLES and field in WORKFLOW_FIELDS:
            recordObj.adjustWorkflow()

        return good

    def isEmpty(self):
        &#34;&#34;&#34;Whether the value(s) is/are empty.

        A single value is empty if it is `None`.

        A mutliple value is empty if it is `None` or `[]`.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        value = self.value
        multiple = self.multiple
        return value is None or multiple and value == []

    def isBlank(self):
        &#34;&#34;&#34;Whether the value(s) is/are blank.

        A single value is empty if it is `None` or `&#39;&#39;`.

        A mutliple value is empty if it is `None` or `[]`, or all its
        component values are blank.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        value = self.value
        multiple = self.multiple
        return (
            value is None
            or value == E
            or multiple
            and (value == [] or all(v is None or v == E for v in value))
        )

    def wrapBare(self):
        &#34;&#34;&#34;Produce the bare field value.

        This is the result of calling the
        `control.typ.base.TypeBase.toDisplay` method on the derived
        type class that matches the type of the field.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        context = self.context
        types = context.types
        tp = self.tp
        value = self.value
        multiple = self.multiple

        fieldTypeObj = getattr(types, tp, None)
        method = fieldTypeObj.toDisplay

        return (
            BLANK.join(method(val) for val in (value or []))
            if multiple
            else method(value)
        )

    def wrap(self, action=None, asEdit=False, empty=False, withLabel=True, cls=E):
        &#34;&#34;&#34;Wrap the field into HTML.

        If there is an `action`, data from the request is picked up and
        `Field.save` is called to save that data to the MongoDB.
        Depending on the `action`, the field is then rendered as follows:

        action | effect
        --- | ---
        `save` | no rendering
        `view`| a read only rendering
        `edit` | an edit widget

        Whether a field is presented as an editable field depends on a number of factors:

        factor | story
        --- | ---
        is master | a field pointing to a master will not be edited
        attribute `mayEdit` | does the current user have permission to edit the field?
        action `edit` or parameter `asEdit` | do we want to present an editable widget?

        Parameters
        ----------
        action: {save, edit, view}, optional `None`
            If present, data will be saved to the database first.
        asEdit: boolean, optional `False`
            No data will be saved.
            The field will rendered editable, if permitted.
        empty: boolean, optional `False`
            Only relevant for readonly views: if the value is empty, just present the
            empty string and nothing else.
        withLabel: boolean, optional `True`
            Whether to precede the value with a field label.
            The label is specified in the field specs which are in the table&#39;s .yaml
            file in `control/tables`.
        cls: string, optional `&#39;&#39;`
            A CSS class to append to the outer `&lt;div&gt;` of the result.

        Returns
        -------
        string(html)
            If there was an `action`, the bare representation of the field value is returned.
            Otherwise, and if `withLabel`, a label is added.
        &#34;&#34;&#34;

        mayRead = self.mayRead

        if mayRead is False:
            return E

        asMaster = self.asMaster
        mayEdit = self.mayEdit

        if action is not None and not asMaster:
            contentLength = request.content_length
            if contentLength is not None and contentLength &gt; LIMIT_JSON:
                abort(400)
            data = request.get_json()
            if data is not None and N.save in data:
                if mayEdit:
                    good = self.save(data[N.save])
                else:
                    good = False
                if not good:
                    abort(400)

        if action == N.save:
            return E

        editable = mayEdit and (action == N.edit or asEdit) and not asMaster
        widget = self.wrapWidget(editable, cls=cls)

        if action is not None:
            return H.join(widget)

        if empty and self.isEmpty():
            return E

        label = self.label
        editClass = &#34; edit&#34; if editable else E

        return (
            H.div(
                [
                    H.div(f&#34;&#34;&#34;{label}:&#34;&#34;&#34;, cls=&#34;record-label&#34;),
                    H.div(widget, cls=f&#34;record-value{editClass}&#34;),
                ],
                cls=&#34;record-row&#34;,
            )
            if withLabel
            else H.div(widget, cls=f&#34;record-value{editClass}&#34;)
        )

    def wrapWidget(self, editable, cls=E):
        &#34;&#34;&#34;Wrap the field value.

        A widget shows the value and may have additional controls to

        *   edit the value
        *   refresh the value

        Refresh fields are those fields that change if other fields are updated,
        typically fields that record the moment on which something happened.
        These fields will get a refresh button automatically.

        Fields may have three conditions relevant for rendering:

        condition | rendering
        --- | ---
        not editable | readonly
        editable in readonly view | readonly with button for editable view
        editable in edit view | editable with button for readonly view

        Parameters
        ----------
        editable: boolean
            Whether the field should be presented in editable form
        cls
            See `Field.wrap()`

        Returns
        -------
        button: string(html)
        representation: string(html)

        They are packaged as a tuple.
        &#34;&#34;&#34;

        atts = self.atts
        mayEdit = self.mayEdit
        withRefresh = self.withRefresh

        button = (
            H.iconx(N.ok, cls=&#34;small&#34;, action=N.view, **atts)
            if editable
            else (
                H.iconx(N.edit, cls=&#34;small&#34;, action=N.edit, **atts)
                if mayEdit
                else H.iconx(
                    N.refresh, cls=&#34;small&#34;, action=N.view, title=REFRESH, **atts,
                )
                if withRefresh
                else E
            )
        )

        return (button, self.wrapValue(editable, cls=cls))

    def wrapValue(self, editable, cls=E):
        &#34;&#34;&#34;Wraps the value of a field.

        !!! hint &#34;field=value in comments&#34;
            In the result we include a string

            ``` html
            &lt;!-- title=My contribution --&gt;
            ```

            but then with the field name instead of `title`
            and the unmarked-up value  instead of `My contribution`.
            This makes it easier for the test suite
            to spot the fields and their values.

        Parameters
        ----------
        editable: boolean
            Whether the field should be presented in editable form
        cls
            See `Field.wrap()`

        Returns
        -------
        string(html)
        &#34;&#34;&#34;
        context = self.context
        types = context.types
        fieldTypeObj = self.fieldTypeObj
        field = self.field
        value = self.value
        tp = self.tp
        multiple = self.multiple
        extensible = self.extensible
        widgetType = self.widgetType

        baseCls = &#34;tags&#34; if widgetType == N.related else &#34;values&#34;
        isSelectWidget = widgetType == N.related

        args = []
        if isSelectWidget and editable:
            record = self.record
            constrain = None
            constrainField = G(CONSTRAINED, field)
            if constrainField:
                constrainValue = G(record, constrainField)
                if constrainValue:
                    constrain = (constrainField, constrainValue)
            args.append(multiple)
            args.append(extensible)
            args.append(constrain)
        atts = dict(wtype=widgetType)

        if editable:
            typeObj = getattr(types, tp, None)
            method = typeObj.toOrig
            origStr = [method(v) for v in value or []] if multiple else method(value)
            atts[N.orig] = bencode(origStr)
        if multiple:
            atts[N.multiple] = ONE
        if extensible:
            atts[N.extensible] = ONE

        method = fieldTypeObj.widget if editable else fieldTypeObj.toDisplay
        extraCls = E if editable else cls
        valueBare = (
            (COMMA.join(val for val in value or []) if multiple else value)
            if tp == N.markdown
            else (
                COMMA.join(
                    fieldTypeObj.toDisplay(val, markup=False) for val in value or []
                )
                if multiple
                else fieldTypeObj.toDisplay(value, markup=False)
            )
        )

        return f&#34;&lt;!-- {field}={valueBare} --&gt;&#34; + (
            H.div(
                [
                    method(val, *args)
                    for val in (value or []) + ([E] if editable else [])
                ],
                **atts,
                cls=baseCls,
            )
            if multiple and not (editable and isSelectWidget)
            else H.div(method(value, *args), **atts, cls=f&#34;value {extraCls}&#34;)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.field.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>recordObj, field, asMaster=False, readonly=None, mayRead=None, mayEdit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deals with fields.</p>
<h2 id="initialization">Initialization</h2>
<p>Store the incoming information.</p>
<p>A number of properties will be inherited from the record object
that spawns a field object.</p>
<p>The value of the field will be looked up from the record and saved into the attribute
<code>value</code>.</p>
<p>Set the attribute <code>fieldTypeObj</code> to a suitable derived class of
<code><a title="control.typ.base.TypeBase" href="typ/base.html#control.typ.base.TypeBase">TypeBase</a></code>.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Fields that point to master records are never editable in this app.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>The parameters <code>readonly</code>, <code>mayRead</code>, <code>mayEdit</code> are optional.
If they are not passed or <code>None</code>, values for these will be taken
from the <code>recordObj</code> that has spawned this field object.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Whether a field is readable or editable, depends first on how it
is configured in the .yaml file in <code>tables</code> that correspnds to the table.
This can be overriden by setting the <code>mayRead</code> and <code>mayEdit</code> attributes
in the <code>recordObj</code>, and it can be overridden again by explicitly
passing values for them here.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recordObj</code></strong> :&ensp;<code>object</code></dt>
<dd>See below.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>See below.</dd>
<dt><strong><code>asMaster</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>See below.</dd>
<dt><strong><code>readonly</code></strong> :&ensp;<code>boolean |</code>None<code>, optional </code>None``</dt>
<dd>Whether the field must be presented readonly.</dd>
<dt><strong><code>mayRead</code></strong> :&ensp;<code>boolean |</code>None<code>, optional </code>None``</dt>
<dd>If passed, overrides the configured read permission for this field.</dd>
<dt><strong><code>mayEdit</code></strong> :&ensp;<code>boolean |</code>None<code>, optional </code>None``</dt>
<dd>If passed, overrides the configured write permission for this field.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    &#34;&#34;&#34;Deals with fields.&#34;&#34;&#34;

    inheritProps = (
        N.context,
        N.uid,
        N.eppn,
        N.table,
        N.record,
        N.eid,
        N.perm,
        N.readonly,
        N.mayRead,
    )

    def __init__(
        self,
        recordObj,
        field,
        asMaster=False,
        readonly=None,
        mayRead=None,
        mayEdit=None,
    ):
        &#34;&#34;&#34;## Initialization

        Store the incoming information.

        A number of properties will be inherited from the record object
        that spawns a field object.

        The value of the field will be looked up from the record and saved into the attribute
        `value`.

        Set the attribute `fieldTypeObj` to a suitable derived class of
        `control.typ.base.TypeBase`.

        !!! caution
            Fields that point to master records are never editable in this app.

        !!! hint
            The parameters `readonly`, `mayRead`, `mayEdit` are optional.
            If they are not passed or `None`, values for these will be taken
            from the `recordObj` that has spawned this field object.

        !!! caution
            Whether a field is readable or editable, depends first on how it
            is configured in the .yaml file in `tables` that correspnds to the table.
            This can be overriden by setting the `mayRead` and `mayEdit` attributes
            in the `recordObj`, and it can be overridden again by explicitly
            passing values for them here.

        Parameters
        ----------
        recordObj: object
            See below.
        field: string
            See below.
        asMaster: boolean, optional `False`
            See below.
        readonly: boolean | `None`, optional `None`
            Whether the field must be presented readonly.
        mayRead: boolean | `None`, optional `None`
            If passed, overrides the configured read permission for this field.
        mayEdit: boolean | `None`, optional `None`
            If passed, overrides the configured write permission for this field.
        &#34;&#34;&#34;

        for prop in Field.inheritProps:
            setattr(self, prop, getattr(recordObj, prop, None))

        self.recordObj = recordObj
        &#34;&#34;&#34;*object* A `control.record.Record` object (or one of a derived class)
        &#34;&#34;&#34;

        self.field = field
        &#34;&#34;&#34;*string* The name of the field
        &#34;&#34;&#34;

        self.asMaster = asMaster
        &#34;&#34;&#34;*boolean* Whether this field points to a master record.
        &#34;&#34;&#34;

        table = self.table

        withNow = G(WITH_NOW, table)
        if withNow:
            nowFields = []
            for info in withNow.values():
                if type(info) is str:
                    nowFields.append(info)
                else:
                    nowFields.extend(info)
            nowFields = set(nowFields)
        else:
            nowFields = set()

        self.withRefresh = field == N.modified or field in nowFields
        &#34;&#34;&#34;*boolean* Whether the field needs a refresh button.
        &#34;&#34;&#34;

        self.withNow = G(withNow, field)
        &#34;&#34;&#34;*dict* Which field updates need a timestamp?

        The info comes from tables.yaml, under key `withNow`.
        It is keyed by table name, then by  field name, and the value
        is a single field or lists of two fields with the names of
        corresponding timestamp fields.

        When a (boolean) field has two timestamp fields, the first one is used  if
        he value is a list, the first one will be used if the modification
        sets the field to `True` and the second one when the field becomes `False`.

        !!! hint
            In assessments, when `submitted` becomes `True`, `dateSubmitted` receives
            a  timestamp. When `submitted` becomes `False`, it is `dateWithdrawn` that
            receives the timestamp.
        &#34;&#34;&#34;

        fieldSpecs = recordObj.fields
        fieldSpec = G(fieldSpecs, field)

        record = self.record
        self.value = G(record, field)
        &#34;&#34;&#34;*mixed* The value of the field.
        &#34;&#34;&#34;

        require = G(fieldSpec, N.perm, default={})
        self.require = require
        &#34;&#34;&#34;*dict* The required permissions for this field.

        Keys are `read` and `edit`, the values are `True` or `False`.
        &#34;&#34;&#34;

        self.label = G(fieldSpec, N.label, default=cap1(field))
        &#34;&#34;&#34;*string* A label to display in front of the field.
        &#34;&#34;&#34;

        self.tp = G(fieldSpec, N.type, default=DEFAULT_TYPE)
        &#34;&#34;&#34;*string* The data type of the field.&#34;&#34;&#34;

        self.multiple = G(fieldSpec, N.multiple, default=False)
        &#34;&#34;&#34;*boolean* Whether the field value consists of multiple values or a single one.
        &#34;&#34;&#34;

        self.extensible = G(fieldSpec, N.extensible, default=False)
        &#34;&#34;&#34;*boolean* Whether the user may add new values to the value table of this field.
        &#34;&#34;&#34;

        context = self.context

        perm = self.perm
        table = self.table
        eid = self.eid
        tp = self.tp
        types = context.types

        fieldTypeObj = getattr(types, tp, None)
        self.fieldTypeObj = fieldTypeObj
        &#34;&#34;&#34;*object* The type object by which the value of this field can be interpreted.
        &#34;&#34;&#34;

        self.widgetType = fieldTypeObj.widgetType
        &#34;&#34;&#34;*string* The type of widget for presenting an edit view on this field.
        &#34;&#34;&#34;

        readonly = self.readonly if readonly is None else readonly

        (self.mayRead, self.mayEdit) = getPermField(table, perm, require)
        if mayRead is not None:
            self.mayRead = mayRead
        if mayEdit is not None:
            self.mayEdit = mayEdit

        if readonly or asMaster:
            self.mayEdit = False

        self.atts = dict(table=table, eid=eid, field=field)
        &#34;&#34;&#34;*dict* Identification of this field value:  table, id of record, name of field.

        !!! hint
            To be used to pass to buttons in widgets for this field.
        &#34;&#34;&#34;

    def save(self, data):
        &#34;&#34;&#34;Save a new value for this field to MongoDb.

        Before saving, permissions and workflow conditions will be checked.

        After saving, workflow information will be adjusted.

        !!! caution
            If the `editors` field of an assessment or review is modified,
            the same value should be put in the detail records, the
            `criteriaEntry` and `reviewEntry` records respectively.

        Parameters
        ----------
        data: mixed
            The new value(s) for this field.
            It comes straight from the client, and will be converted to proper
            Python/MongoDb values
        &#34;&#34;&#34;

        mayEdit = self.mayEdit

        if not mayEdit:
            return False

        context = self.context
        db = context.db
        uid = self.uid
        eppn = self.eppn
        table = self.table
        eid = self.eid
        field = self.field
        extensible = self.extensible
        record = self.record
        recordObj = self.recordObj
        require = self.require
        constrain = None
        constrainField = G(CONSTRAINED, field)
        if constrainField:
            constrainValue = G(record, constrainField)
            if constrainValue:
                constrain = (constrainField, constrainValue)

        multiple = self.multiple
        fieldTypeObj = self.fieldTypeObj
        conversion = fieldTypeObj.fromStr if fieldTypeObj else None
        kwargs = dict(uid=uid, eppn=eppn, extensible=extensible) if extensible else {}
        if constrain:
            kwargs[N.constrain] = constrain

        if conversion is not None:
            try:
                if multiple:
                    data = [conversion(d, **kwargs) for d in data or []]
                else:
                    data = conversion(data, **kwargs)
            except ConversionError:
                return False

        modified = G(record, N.modified)
        nowFields = []
        if data is not None:
            withNow = self.withNow
            if withNow:
                withNowField = (
                    withNow
                    if type(withNow) is str
                    else withNow[0]
                    if data
                    else withNow[1]
                )
                nowFields.append(withNowField)

        result = db.updateField(
            table, eid, field, data, eppn, modified, nowFields=nowFields,
        )
        if not result:
            return False

        (updates, deletions) = result
        record = context.getItem(table, eid, requireFresh=True)

        recordObj.reload(record)
        self.value = G(record, field)
        self.perm = recordObj.perm
        perm = self.perm
        (self.mayRead, self.mayEdit) = getPermField(table, perm, require)

        good = True
        if field == N.editors and table in CASCADE_SPECS:
            for dtable in CASCADE_SPECS[table]:
                drecords = db.getDetails(dtable, table, eid)
                for drecord in drecords:
                    deid = G(drecord, N._id)
                    result = db.updateField(
                        dtable,
                        deid,
                        N.editors,
                        data,
                        eppn,
                        modified,
                        nowFields=nowFields,
                    )
                    if not result:
                        good = False

        if table in WORKFLOW_TABLES and field in WORKFLOW_FIELDS:
            recordObj.adjustWorkflow()

        return good

    def isEmpty(self):
        &#34;&#34;&#34;Whether the value(s) is/are empty.

        A single value is empty if it is `None`.

        A mutliple value is empty if it is `None` or `[]`.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        value = self.value
        multiple = self.multiple
        return value is None or multiple and value == []

    def isBlank(self):
        &#34;&#34;&#34;Whether the value(s) is/are blank.

        A single value is empty if it is `None` or `&#39;&#39;`.

        A mutliple value is empty if it is `None` or `[]`, or all its
        component values are blank.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        value = self.value
        multiple = self.multiple
        return (
            value is None
            or value == E
            or multiple
            and (value == [] or all(v is None or v == E for v in value))
        )

    def wrapBare(self):
        &#34;&#34;&#34;Produce the bare field value.

        This is the result of calling the
        `control.typ.base.TypeBase.toDisplay` method on the derived
        type class that matches the type of the field.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        context = self.context
        types = context.types
        tp = self.tp
        value = self.value
        multiple = self.multiple

        fieldTypeObj = getattr(types, tp, None)
        method = fieldTypeObj.toDisplay

        return (
            BLANK.join(method(val) for val in (value or []))
            if multiple
            else method(value)
        )

    def wrap(self, action=None, asEdit=False, empty=False, withLabel=True, cls=E):
        &#34;&#34;&#34;Wrap the field into HTML.

        If there is an `action`, data from the request is picked up and
        `Field.save` is called to save that data to the MongoDB.
        Depending on the `action`, the field is then rendered as follows:

        action | effect
        --- | ---
        `save` | no rendering
        `view`| a read only rendering
        `edit` | an edit widget

        Whether a field is presented as an editable field depends on a number of factors:

        factor | story
        --- | ---
        is master | a field pointing to a master will not be edited
        attribute `mayEdit` | does the current user have permission to edit the field?
        action `edit` or parameter `asEdit` | do we want to present an editable widget?

        Parameters
        ----------
        action: {save, edit, view}, optional `None`
            If present, data will be saved to the database first.
        asEdit: boolean, optional `False`
            No data will be saved.
            The field will rendered editable, if permitted.
        empty: boolean, optional `False`
            Only relevant for readonly views: if the value is empty, just present the
            empty string and nothing else.
        withLabel: boolean, optional `True`
            Whether to precede the value with a field label.
            The label is specified in the field specs which are in the table&#39;s .yaml
            file in `control/tables`.
        cls: string, optional `&#39;&#39;`
            A CSS class to append to the outer `&lt;div&gt;` of the result.

        Returns
        -------
        string(html)
            If there was an `action`, the bare representation of the field value is returned.
            Otherwise, and if `withLabel`, a label is added.
        &#34;&#34;&#34;

        mayRead = self.mayRead

        if mayRead is False:
            return E

        asMaster = self.asMaster
        mayEdit = self.mayEdit

        if action is not None and not asMaster:
            contentLength = request.content_length
            if contentLength is not None and contentLength &gt; LIMIT_JSON:
                abort(400)
            data = request.get_json()
            if data is not None and N.save in data:
                if mayEdit:
                    good = self.save(data[N.save])
                else:
                    good = False
                if not good:
                    abort(400)

        if action == N.save:
            return E

        editable = mayEdit and (action == N.edit or asEdit) and not asMaster
        widget = self.wrapWidget(editable, cls=cls)

        if action is not None:
            return H.join(widget)

        if empty and self.isEmpty():
            return E

        label = self.label
        editClass = &#34; edit&#34; if editable else E

        return (
            H.div(
                [
                    H.div(f&#34;&#34;&#34;{label}:&#34;&#34;&#34;, cls=&#34;record-label&#34;),
                    H.div(widget, cls=f&#34;record-value{editClass}&#34;),
                ],
                cls=&#34;record-row&#34;,
            )
            if withLabel
            else H.div(widget, cls=f&#34;record-value{editClass}&#34;)
        )

    def wrapWidget(self, editable, cls=E):
        &#34;&#34;&#34;Wrap the field value.

        A widget shows the value and may have additional controls to

        *   edit the value
        *   refresh the value

        Refresh fields are those fields that change if other fields are updated,
        typically fields that record the moment on which something happened.
        These fields will get a refresh button automatically.

        Fields may have three conditions relevant for rendering:

        condition | rendering
        --- | ---
        not editable | readonly
        editable in readonly view | readonly with button for editable view
        editable in edit view | editable with button for readonly view

        Parameters
        ----------
        editable: boolean
            Whether the field should be presented in editable form
        cls
            See `Field.wrap()`

        Returns
        -------
        button: string(html)
        representation: string(html)

        They are packaged as a tuple.
        &#34;&#34;&#34;

        atts = self.atts
        mayEdit = self.mayEdit
        withRefresh = self.withRefresh

        button = (
            H.iconx(N.ok, cls=&#34;small&#34;, action=N.view, **atts)
            if editable
            else (
                H.iconx(N.edit, cls=&#34;small&#34;, action=N.edit, **atts)
                if mayEdit
                else H.iconx(
                    N.refresh, cls=&#34;small&#34;, action=N.view, title=REFRESH, **atts,
                )
                if withRefresh
                else E
            )
        )

        return (button, self.wrapValue(editable, cls=cls))

    def wrapValue(self, editable, cls=E):
        &#34;&#34;&#34;Wraps the value of a field.

        !!! hint &#34;field=value in comments&#34;
            In the result we include a string

            ``` html
            &lt;!-- title=My contribution --&gt;
            ```

            but then with the field name instead of `title`
            and the unmarked-up value  instead of `My contribution`.
            This makes it easier for the test suite
            to spot the fields and their values.

        Parameters
        ----------
        editable: boolean
            Whether the field should be presented in editable form
        cls
            See `Field.wrap()`

        Returns
        -------
        string(html)
        &#34;&#34;&#34;
        context = self.context
        types = context.types
        fieldTypeObj = self.fieldTypeObj
        field = self.field
        value = self.value
        tp = self.tp
        multiple = self.multiple
        extensible = self.extensible
        widgetType = self.widgetType

        baseCls = &#34;tags&#34; if widgetType == N.related else &#34;values&#34;
        isSelectWidget = widgetType == N.related

        args = []
        if isSelectWidget and editable:
            record = self.record
            constrain = None
            constrainField = G(CONSTRAINED, field)
            if constrainField:
                constrainValue = G(record, constrainField)
                if constrainValue:
                    constrain = (constrainField, constrainValue)
            args.append(multiple)
            args.append(extensible)
            args.append(constrain)
        atts = dict(wtype=widgetType)

        if editable:
            typeObj = getattr(types, tp, None)
            method = typeObj.toOrig
            origStr = [method(v) for v in value or []] if multiple else method(value)
            atts[N.orig] = bencode(origStr)
        if multiple:
            atts[N.multiple] = ONE
        if extensible:
            atts[N.extensible] = ONE

        method = fieldTypeObj.widget if editable else fieldTypeObj.toDisplay
        extraCls = E if editable else cls
        valueBare = (
            (COMMA.join(val for val in value or []) if multiple else value)
            if tp == N.markdown
            else (
                COMMA.join(
                    fieldTypeObj.toDisplay(val, markup=False) for val in value or []
                )
                if multiple
                else fieldTypeObj.toDisplay(value, markup=False)
            )
        )

        return f&#34;&lt;!-- {field}={valueBare} --&gt;&#34; + (
            H.div(
                [
                    method(val, *args)
                    for val in (value or []) + ([E] if editable else [])
                ],
                **atts,
                cls=baseCls,
            )
            if multiple and not (editable and isSelectWidget)
            else H.div(method(value, *args), **atts, cls=f&#34;value {extraCls}&#34;)
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="control.field.Field.inheritProps"><code class="name">var <span class="ident">inheritProps</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="control.field.Field.asMaster"><code class="name">var <span class="ident">asMaster</span></code></dt>
<dd>
<div class="desc"><p><em>boolean</em> Whether this field points to a master record.</p></div>
</dd>
<dt id="control.field.Field.atts"><code class="name">var <span class="ident">atts</span></code></dt>
<dd>
<div class="desc"><p><em>dict</em> Identification of this field value:
table, id of record, name of field.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>To be used to pass to buttons in widgets for this field.</p>
</div></div>
</dd>
<dt id="control.field.Field.extensible"><code class="name">var <span class="ident">extensible</span></code></dt>
<dd>
<div class="desc"><p><em>boolean</em> Whether the user may add new values to the value table of this field.</p></div>
</dd>
<dt id="control.field.Field.field"><code class="name">var <span class="ident">field</span></code></dt>
<dd>
<div class="desc"><p><em>string</em> The name of the field</p></div>
</dd>
<dt id="control.field.Field.fieldTypeObj"><code class="name">var <span class="ident">fieldTypeObj</span></code></dt>
<dd>
<div class="desc"><p><em>object</em> The type object by which the value of this field can be interpreted.</p></div>
</dd>
<dt id="control.field.Field.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p><em>string</em> A label to display in front of the field.</p></div>
</dd>
<dt id="control.field.Field.multiple"><code class="name">var <span class="ident">multiple</span></code></dt>
<dd>
<div class="desc"><p><em>boolean</em> Whether the field value consists of multiple values or a single one.</p></div>
</dd>
<dt id="control.field.Field.recordObj"><code class="name">var <span class="ident">recordObj</span></code></dt>
<dd>
<div class="desc"><p><em>object</em> A <code><a title="control.record.Record" href="record.html#control.record.Record">Record</a></code> object (or one of a derived class)</p></div>
</dd>
<dt id="control.field.Field.require"><code class="name">var <span class="ident">require</span></code></dt>
<dd>
<div class="desc"><p><em>dict</em> The required permissions for this field.</p>
<p>Keys are <code>read</code> and <code>edit</code>, the values are <code>True</code> or <code>False</code>.</p></div>
</dd>
<dt id="control.field.Field.tp"><code class="name">var <span class="ident">tp</span></code></dt>
<dd>
<div class="desc"><p><em>string</em> The data type of the field.</p></div>
</dd>
<dt id="control.field.Field.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p><em>mixed</em> The value of the field.</p></div>
</dd>
<dt id="control.field.Field.widgetType"><code class="name">var <span class="ident">widgetType</span></code></dt>
<dd>
<div class="desc"><p><em>string</em> The type of widget for presenting an edit view on this field.</p></div>
</dd>
<dt id="control.field.Field.withNow"><code class="name">var <span class="ident">withNow</span></code></dt>
<dd>
<div class="desc"><p><em>dict</em> Which field updates need a timestamp?</p>
<p>The info comes from tables.yaml, under key <code>withNow</code>.
It is keyed by table name, then by
field name, and the value
is a single field or lists of two fields with the names of
corresponding timestamp fields.</p>
<p>When a (boolean) field has two timestamp fields, the first one is used
if
he value is a list, the first one will be used if the modification
sets the field to <code>True</code> and the second one when the field becomes <code>False</code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>In assessments, when <code>submitted</code> becomes <code>True</code>, <code>dateSubmitted</code> receives
a
timestamp. When <code>submitted</code> becomes <code>False</code>, it is <code>dateWithdrawn</code> that
receives the timestamp.</p>
</div></div>
</dd>
<dt id="control.field.Field.withRefresh"><code class="name">var <span class="ident">withRefresh</span></code></dt>
<dd>
<div class="desc"><p><em>boolean</em> Whether the field needs a refresh button.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.field.Field.isBlank"><code class="name flex">
<span>def <span class="ident">isBlank</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Whether the value(s) is/are blank.</p>
<p>A single value is empty if it is <code>None</code> or <code>''</code>.</p>
<p>A mutliple value is empty if it is <code>None</code> or <code>[]</code>, or all its
component values are blank.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isBlank(self):
    &#34;&#34;&#34;Whether the value(s) is/are blank.

    A single value is empty if it is `None` or `&#39;&#39;`.

    A mutliple value is empty if it is `None` or `[]`, or all its
    component values are blank.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    value = self.value
    multiple = self.multiple
    return (
        value is None
        or value == E
        or multiple
        and (value == [] or all(v is None or v == E for v in value))
    )</code></pre>
</details>
</dd>
<dt id="control.field.Field.isEmpty"><code class="name flex">
<span>def <span class="ident">isEmpty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Whether the value(s) is/are empty.</p>
<p>A single value is empty if it is <code>None</code>.</p>
<p>A mutliple value is empty if it is <code>None</code> or <code>[]</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isEmpty(self):
    &#34;&#34;&#34;Whether the value(s) is/are empty.

    A single value is empty if it is `None`.

    A mutliple value is empty if it is `None` or `[]`.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    value = self.value
    multiple = self.multiple
    return value is None or multiple and value == []</code></pre>
</details>
</dd>
<dt id="control.field.Field.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a new value for this field to MongoDb.</p>
<p>Before saving, permissions and workflow conditions will be checked.</p>
<p>After saving, workflow information will be adjusted.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>If the <code>editors</code> field of an assessment or review is modified,
the same value should be put in the detail records, the
<code>criteriaEntry</code> and <code>reviewEntry</code> records respectively.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>mixed</code></dt>
<dd>The new value(s) for this field.
It comes straight from the client, and will be converted to proper
Python/MongoDb values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, data):
    &#34;&#34;&#34;Save a new value for this field to MongoDb.

    Before saving, permissions and workflow conditions will be checked.

    After saving, workflow information will be adjusted.

    !!! caution
        If the `editors` field of an assessment or review is modified,
        the same value should be put in the detail records, the
        `criteriaEntry` and `reviewEntry` records respectively.

    Parameters
    ----------
    data: mixed
        The new value(s) for this field.
        It comes straight from the client, and will be converted to proper
        Python/MongoDb values
    &#34;&#34;&#34;

    mayEdit = self.mayEdit

    if not mayEdit:
        return False

    context = self.context
    db = context.db
    uid = self.uid
    eppn = self.eppn
    table = self.table
    eid = self.eid
    field = self.field
    extensible = self.extensible
    record = self.record
    recordObj = self.recordObj
    require = self.require
    constrain = None
    constrainField = G(CONSTRAINED, field)
    if constrainField:
        constrainValue = G(record, constrainField)
        if constrainValue:
            constrain = (constrainField, constrainValue)

    multiple = self.multiple
    fieldTypeObj = self.fieldTypeObj
    conversion = fieldTypeObj.fromStr if fieldTypeObj else None
    kwargs = dict(uid=uid, eppn=eppn, extensible=extensible) if extensible else {}
    if constrain:
        kwargs[N.constrain] = constrain

    if conversion is not None:
        try:
            if multiple:
                data = [conversion(d, **kwargs) for d in data or []]
            else:
                data = conversion(data, **kwargs)
        except ConversionError:
            return False

    modified = G(record, N.modified)
    nowFields = []
    if data is not None:
        withNow = self.withNow
        if withNow:
            withNowField = (
                withNow
                if type(withNow) is str
                else withNow[0]
                if data
                else withNow[1]
            )
            nowFields.append(withNowField)

    result = db.updateField(
        table, eid, field, data, eppn, modified, nowFields=nowFields,
    )
    if not result:
        return False

    (updates, deletions) = result
    record = context.getItem(table, eid, requireFresh=True)

    recordObj.reload(record)
    self.value = G(record, field)
    self.perm = recordObj.perm
    perm = self.perm
    (self.mayRead, self.mayEdit) = getPermField(table, perm, require)

    good = True
    if field == N.editors and table in CASCADE_SPECS:
        for dtable in CASCADE_SPECS[table]:
            drecords = db.getDetails(dtable, table, eid)
            for drecord in drecords:
                deid = G(drecord, N._id)
                result = db.updateField(
                    dtable,
                    deid,
                    N.editors,
                    data,
                    eppn,
                    modified,
                    nowFields=nowFields,
                )
                if not result:
                    good = False

    if table in WORKFLOW_TABLES and field in WORKFLOW_FIELDS:
        recordObj.adjustWorkflow()

    return good</code></pre>
</details>
</dd>
<dt id="control.field.Field.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>self, action=None, asEdit=False, empty=False, withLabel=True, cls='')</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap the field into HTML.</p>
<p>If there is an <code>action</code>, data from the request is picked up and
<code><a title="control.field.Field.save" href="#control.field.Field.save">Field.save()</a></code> is called to save that data to the MongoDB.
Depending on the <code>action</code>, the field is then rendered as follows:</p>
<table>
<thead>
<tr>
<th>action</th>
<th>effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>save</code></td>
<td>no rendering</td>
</tr>
<tr>
<td><code>view</code></td>
<td>a read only rendering</td>
</tr>
<tr>
<td><code>edit</code></td>
<td>an edit widget</td>
</tr>
</tbody>
</table>
<p>Whether a field is presented as an editable field depends on a number of factors:</p>
<table>
<thead>
<tr>
<th>factor</th>
<th>story</th>
</tr>
</thead>
<tbody>
<tr>
<td>is master</td>
<td>a field pointing to a master will not be edited</td>
</tr>
<tr>
<td>attribute <code>mayEdit</code></td>
<td>does the current user have permission to edit the field?</td>
</tr>
<tr>
<td>action <code>edit</code> or parameter <code>asEdit</code></td>
<td>do we want to present an editable widget?</td>
</tr>
</tbody>
</table>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>{save, edit, view}</code>, optional <code>None</code></dt>
<dd>If present, data will be saved to the database first.</dd>
<dt><strong><code>asEdit</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>No data will be saved.
The field will rendered editable, if permitted.</dd>
<dt><strong><code>empty</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only relevant for readonly views: if the value is empty, just present the
empty string and nothing else.</dd>
<dt><strong><code>withLabel</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to precede the value with a field label.
The label is specified in the field specs which are in the table's .yaml
file in <code>control/tables</code>.</dd>
<dt><strong><code>cls</code></strong> :&ensp;<code>string</code>, optional <code>''</code></dt>
<dd>A CSS class to append to the outer <code>&lt;div&gt;</code> of the result.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string(html)</code></dt>
<dd>If there was an <code>action</code>, the bare representation of the field value is returned.
Otherwise, and if <code>withLabel</code>, a label is added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(self, action=None, asEdit=False, empty=False, withLabel=True, cls=E):
    &#34;&#34;&#34;Wrap the field into HTML.

    If there is an `action`, data from the request is picked up and
    `Field.save` is called to save that data to the MongoDB.
    Depending on the `action`, the field is then rendered as follows:

    action | effect
    --- | ---
    `save` | no rendering
    `view`| a read only rendering
    `edit` | an edit widget

    Whether a field is presented as an editable field depends on a number of factors:

    factor | story
    --- | ---
    is master | a field pointing to a master will not be edited
    attribute `mayEdit` | does the current user have permission to edit the field?
    action `edit` or parameter `asEdit` | do we want to present an editable widget?

    Parameters
    ----------
    action: {save, edit, view}, optional `None`
        If present, data will be saved to the database first.
    asEdit: boolean, optional `False`
        No data will be saved.
        The field will rendered editable, if permitted.
    empty: boolean, optional `False`
        Only relevant for readonly views: if the value is empty, just present the
        empty string and nothing else.
    withLabel: boolean, optional `True`
        Whether to precede the value with a field label.
        The label is specified in the field specs which are in the table&#39;s .yaml
        file in `control/tables`.
    cls: string, optional `&#39;&#39;`
        A CSS class to append to the outer `&lt;div&gt;` of the result.

    Returns
    -------
    string(html)
        If there was an `action`, the bare representation of the field value is returned.
        Otherwise, and if `withLabel`, a label is added.
    &#34;&#34;&#34;

    mayRead = self.mayRead

    if mayRead is False:
        return E

    asMaster = self.asMaster
    mayEdit = self.mayEdit

    if action is not None and not asMaster:
        contentLength = request.content_length
        if contentLength is not None and contentLength &gt; LIMIT_JSON:
            abort(400)
        data = request.get_json()
        if data is not None and N.save in data:
            if mayEdit:
                good = self.save(data[N.save])
            else:
                good = False
            if not good:
                abort(400)

    if action == N.save:
        return E

    editable = mayEdit and (action == N.edit or asEdit) and not asMaster
    widget = self.wrapWidget(editable, cls=cls)

    if action is not None:
        return H.join(widget)

    if empty and self.isEmpty():
        return E

    label = self.label
    editClass = &#34; edit&#34; if editable else E

    return (
        H.div(
            [
                H.div(f&#34;&#34;&#34;{label}:&#34;&#34;&#34;, cls=&#34;record-label&#34;),
                H.div(widget, cls=f&#34;record-value{editClass}&#34;),
            ],
            cls=&#34;record-row&#34;,
        )
        if withLabel
        else H.div(widget, cls=f&#34;record-value{editClass}&#34;)
    )</code></pre>
</details>
</dd>
<dt id="control.field.Field.wrapBare"><code class="name flex">
<span>def <span class="ident">wrapBare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the bare field value.</p>
<p>This is the result of calling the
<code><a title="control.typ.base.TypeBase.toDisplay" href="typ/base.html#control.typ.base.TypeBase.toDisplay">TypeBase.toDisplay()</a></code> method on the derived
type class that matches the type of the field.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string(html)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapBare(self):
    &#34;&#34;&#34;Produce the bare field value.

    This is the result of calling the
    `control.typ.base.TypeBase.toDisplay` method on the derived
    type class that matches the type of the field.

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    context = self.context
    types = context.types
    tp = self.tp
    value = self.value
    multiple = self.multiple

    fieldTypeObj = getattr(types, tp, None)
    method = fieldTypeObj.toDisplay

    return (
        BLANK.join(method(val) for val in (value or []))
        if multiple
        else method(value)
    )</code></pre>
</details>
</dd>
<dt id="control.field.Field.wrapValue"><code class="name flex">
<span>def <span class="ident">wrapValue</span></span>(<span>self, editable, cls='')</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps the value of a field.</p>
<div class="admonition hint">
<p class="admonition-title">field=value in comments</p>
<p>In the result we include a string</p>
<p><code>html
&lt;!-- title=My contribution --&gt;</code></p>
<p>but then with the field name instead of <code>title</code>
and the unmarked-up value
instead of <code>My contribution</code>.
This makes it easier for the test suite
to spot the fields and their values.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>editable</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the field should be presented in editable form</dd>
<dt><strong><code>cls</code></strong></dt>
<dd>See <code><a title="control.field.Field.wrap" href="#control.field.Field.wrap">Field.wrap()</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string(html)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapValue(self, editable, cls=E):
    &#34;&#34;&#34;Wraps the value of a field.

    !!! hint &#34;field=value in comments&#34;
        In the result we include a string

        ``` html
        &lt;!-- title=My contribution --&gt;
        ```

        but then with the field name instead of `title`
        and the unmarked-up value  instead of `My contribution`.
        This makes it easier for the test suite
        to spot the fields and their values.

    Parameters
    ----------
    editable: boolean
        Whether the field should be presented in editable form
    cls
        See `Field.wrap()`

    Returns
    -------
    string(html)
    &#34;&#34;&#34;
    context = self.context
    types = context.types
    fieldTypeObj = self.fieldTypeObj
    field = self.field
    value = self.value
    tp = self.tp
    multiple = self.multiple
    extensible = self.extensible
    widgetType = self.widgetType

    baseCls = &#34;tags&#34; if widgetType == N.related else &#34;values&#34;
    isSelectWidget = widgetType == N.related

    args = []
    if isSelectWidget and editable:
        record = self.record
        constrain = None
        constrainField = G(CONSTRAINED, field)
        if constrainField:
            constrainValue = G(record, constrainField)
            if constrainValue:
                constrain = (constrainField, constrainValue)
        args.append(multiple)
        args.append(extensible)
        args.append(constrain)
    atts = dict(wtype=widgetType)

    if editable:
        typeObj = getattr(types, tp, None)
        method = typeObj.toOrig
        origStr = [method(v) for v in value or []] if multiple else method(value)
        atts[N.orig] = bencode(origStr)
    if multiple:
        atts[N.multiple] = ONE
    if extensible:
        atts[N.extensible] = ONE

    method = fieldTypeObj.widget if editable else fieldTypeObj.toDisplay
    extraCls = E if editable else cls
    valueBare = (
        (COMMA.join(val for val in value or []) if multiple else value)
        if tp == N.markdown
        else (
            COMMA.join(
                fieldTypeObj.toDisplay(val, markup=False) for val in value or []
            )
            if multiple
            else fieldTypeObj.toDisplay(value, markup=False)
        )
    )

    return f&#34;&lt;!-- {field}={valueBare} --&gt;&#34; + (
        H.div(
            [
                method(val, *args)
                for val in (value or []) + ([E] if editable else [])
            ],
            **atts,
            cls=baseCls,
        )
        if multiple and not (editable and isSelectWidget)
        else H.div(method(value, *args), **atts, cls=f&#34;value {extraCls}&#34;)
    )</code></pre>
</details>
</dd>
<dt id="control.field.Field.wrapWidget"><code class="name flex">
<span>def <span class="ident">wrapWidget</span></span>(<span>self, editable, cls='')</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap the field value.</p>
<p>A widget shows the value and may have additional controls to</p>
<ul>
<li>edit the value</li>
<li>refresh the value</li>
</ul>
<p>Refresh fields are those fields that change if other fields are updated,
typically fields that record the moment on which something happened.
These fields will get a refresh button automatically.</p>
<p>Fields may have three conditions relevant for rendering:</p>
<table>
<thead>
<tr>
<th>condition</th>
<th>rendering</th>
</tr>
</thead>
<tbody>
<tr>
<td>not editable</td>
<td>readonly</td>
</tr>
<tr>
<td>editable in readonly view</td>
<td>readonly with button for editable view</td>
</tr>
<tr>
<td>editable in edit view</td>
<td>editable with button for readonly view</td>
</tr>
</tbody>
</table>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>editable</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the field should be presented in editable form</dd>
<dt><strong><code>cls</code></strong></dt>
<dd>See <code><a title="control.field.Field.wrap" href="#control.field.Field.wrap">Field.wrap()</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>string(html)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>representation</code></strong> :&ensp;<code>string(html)</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>They are packaged as a tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapWidget(self, editable, cls=E):
    &#34;&#34;&#34;Wrap the field value.

    A widget shows the value and may have additional controls to

    *   edit the value
    *   refresh the value

    Refresh fields are those fields that change if other fields are updated,
    typically fields that record the moment on which something happened.
    These fields will get a refresh button automatically.

    Fields may have three conditions relevant for rendering:

    condition | rendering
    --- | ---
    not editable | readonly
    editable in readonly view | readonly with button for editable view
    editable in edit view | editable with button for readonly view

    Parameters
    ----------
    editable: boolean
        Whether the field should be presented in editable form
    cls
        See `Field.wrap()`

    Returns
    -------
    button: string(html)
    representation: string(html)

    They are packaged as a tuple.
    &#34;&#34;&#34;

    atts = self.atts
    mayEdit = self.mayEdit
    withRefresh = self.withRefresh

    button = (
        H.iconx(N.ok, cls=&#34;small&#34;, action=N.view, **atts)
        if editable
        else (
            H.iconx(N.edit, cls=&#34;small&#34;, action=N.edit, **atts)
            if mayEdit
            else H.iconx(
                N.refresh, cls=&#34;small&#34;, action=N.view, title=REFRESH, **atts,
            )
            if withRefresh
            else E
        )
    )

    return (button, self.wrapValue(editable, cls=cls))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.field.Field" href="#control.field.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="control.field.Field.asMaster" href="#control.field.Field.asMaster">asMaster</a></code></li>
<li><code><a title="control.field.Field.atts" href="#control.field.Field.atts">atts</a></code></li>
<li><code><a title="control.field.Field.extensible" href="#control.field.Field.extensible">extensible</a></code></li>
<li><code><a title="control.field.Field.field" href="#control.field.Field.field">field</a></code></li>
<li><code><a title="control.field.Field.fieldTypeObj" href="#control.field.Field.fieldTypeObj">fieldTypeObj</a></code></li>
<li><code><a title="control.field.Field.inheritProps" href="#control.field.Field.inheritProps">inheritProps</a></code></li>
<li><code><a title="control.field.Field.isBlank" href="#control.field.Field.isBlank">isBlank</a></code></li>
<li><code><a title="control.field.Field.isEmpty" href="#control.field.Field.isEmpty">isEmpty</a></code></li>
<li><code><a title="control.field.Field.label" href="#control.field.Field.label">label</a></code></li>
<li><code><a title="control.field.Field.multiple" href="#control.field.Field.multiple">multiple</a></code></li>
<li><code><a title="control.field.Field.recordObj" href="#control.field.Field.recordObj">recordObj</a></code></li>
<li><code><a title="control.field.Field.require" href="#control.field.Field.require">require</a></code></li>
<li><code><a title="control.field.Field.save" href="#control.field.Field.save">save</a></code></li>
<li><code><a title="control.field.Field.tp" href="#control.field.Field.tp">tp</a></code></li>
<li><code><a title="control.field.Field.value" href="#control.field.Field.value">value</a></code></li>
<li><code><a title="control.field.Field.widgetType" href="#control.field.Field.widgetType">widgetType</a></code></li>
<li><code><a title="control.field.Field.withNow" href="#control.field.Field.withNow">withNow</a></code></li>
<li><code><a title="control.field.Field.withRefresh" href="#control.field.Field.withRefresh">withRefresh</a></code></li>
<li><code><a title="control.field.Field.wrap" href="#control.field.Field.wrap">wrap</a></code></li>
<li><code><a title="control.field.Field.wrapBare" href="#control.field.Field.wrapBare">wrapBare</a></code></li>
<li><code><a title="control.field.Field.wrapValue" href="#control.field.Field.wrapValue">wrapValue</a></code></li>
<li><code><a title="control.field.Field.wrapWidget" href="#control.field.Field.wrapWidget">wrapWidget</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>