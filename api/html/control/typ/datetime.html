<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>control.typ.datetime API documentation</title>
<meta name="description" content="The datetime type." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.typ.datetime</code></h1>
</header>
<section id="section-intro">
<p>The datetime type.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The datetime type.&#34;&#34;&#34;

import re
from datetime import datetime as dt

from config import Config as C, Names as N
from control.utils import now, E
from control.html import HtmlElements as H
from control.typ.base import TypeBase


CW = C.web

QQ = H.icon(CW.unknown[N.generic])
Qq = H.icon(CW.unknown[N.generic], asChar=True)

dtTrim = re.compile(r&#34;&#34;&#34;[^0-9  T/:.-]+&#34;&#34;&#34;)
dtSep = re.compile(r&#34;&#34;&#34;[ T/:.-]+&#34;&#34;&#34;)


def getDefaultDate():
    today = now()
    return (
        today.year,
        today.month,
        today.day,
        today.hour,
        today.minute,
        today.second,
    )


DATETIME_FORMAT = &#34;&#34;&#34;{:&gt;04}-{:&gt;02}-{:&gt;02} {:&gt;02}:{:&gt;02}:{:&gt;02}&#34;&#34;&#34;


def genDatetimePattern():
    s = &#34;&#34;&#34;[ /:.-]&#34;&#34;&#34;
    t = &#34;&#34;&#34;[T /:.-]&#34;&#34;&#34;
    yr = f&#34;&#34;&#34;([12][0-9][0-9][0-9])&#34;&#34;&#34;
    mth = f&#34;&#34;&#34;((0[1-9])|(1[0-2])|[1-9])&#34;&#34;&#34;
    d = f&#34;&#34;&#34;((0[1-9])|([12][0-9])|(3[01])|[1-9])&#34;&#34;&#34;
    hr = f&#34;&#34;&#34;(([0-5][0-9])|[0-9])&#34;&#34;&#34;
    m = hr
    sec = hr
    return (
        &#34;&#34;&#34;^&#34;&#34;&#34;
        f&#34;&#34;&#34;{yr}?({s}{mth})?({s}{d})?({t}{hr})?({s}{m})?({s}{sec})?&#34;&#34;&#34;
        &#34;&#34;&#34;Z?&#34;&#34;&#34;
        &#34;&#34;&#34;$&#34;&#34;&#34;
    )


DATETIME_PATTERN = genDatetimePattern()


class Datetime(TypeBase):
    &#34;&#34;&#34;Type class for date-time values&#34;&#34;&#34;
    rawType = dt
    widgetType = N.text
    pattern = DATETIME_PATTERN

    def partition(self, strVal):
        &#34;&#34;&#34;Split a datetime string into 3 date components and 3 time components.

        !!! note
            The fraction part of seconds is ignored.

        !!! warning
            If there are missing components, they will be taken from the default date,
            which is `now`.

        Parameters
        ----------
        strVal: string
        &#34;&#34;&#34;
        normalVal = dtTrim.sub(E, strVal)
        if not normalVal:
            return None

        normalParts = [int(p) for p in dtSep.split(normalVal)]
        if len(normalParts) == 0:
            return None

        if not 1900 &lt;= normalParts[0] &lt;= 2100:
            return None

        defaultDate = getDefaultDate()
        if len(normalParts) &gt; 6:
            normalParts = normalParts[0:6]
        if len(normalParts) &lt; 6:
            normalParts = [
                normalParts[i] if i &lt; len(normalParts) else defaultDate[i]
                for i in range(6)
            ]
        try:
            dt(*normalParts)  # only for checking
        except Exception:
            normalParts = defaultDate
        return normalParts

    def normalize(self, strVal):
        normalParts = self.partition(strVal)
        if normalParts is None:
            return E
        return DATETIME_FORMAT.format(*normalParts)

    def fromStr(self, editVal):
        if not editVal:
            return None
        if editVal == N.now:
            return now()
        normalParts = self.partition(editVal)
        if normalParts is None:
            return None
        cast = self.rawType
        return cast(*normalParts)

    def toDisplay(self, val, markup=True):
        if val is None:
            return QQ if markup else Qq
        valBare = self.normalize(val.isoformat())
        return H.span(valBare) if markup else valBare

    def toEdit(self, val):
        return E if val is None else self.normalize(val.isoformat())

    def toOrig(self, val):
        if val is None:
            return None
        return self.normalize(val.isoformat())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="control.typ.datetime.genDatetimePattern"><code class="name flex">
<span>def <span class="ident">genDatetimePattern</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genDatetimePattern():
    s = &#34;&#34;&#34;[ /:.-]&#34;&#34;&#34;
    t = &#34;&#34;&#34;[T /:.-]&#34;&#34;&#34;
    yr = f&#34;&#34;&#34;([12][0-9][0-9][0-9])&#34;&#34;&#34;
    mth = f&#34;&#34;&#34;((0[1-9])|(1[0-2])|[1-9])&#34;&#34;&#34;
    d = f&#34;&#34;&#34;((0[1-9])|([12][0-9])|(3[01])|[1-9])&#34;&#34;&#34;
    hr = f&#34;&#34;&#34;(([0-5][0-9])|[0-9])&#34;&#34;&#34;
    m = hr
    sec = hr
    return (
        &#34;&#34;&#34;^&#34;&#34;&#34;
        f&#34;&#34;&#34;{yr}?({s}{mth})?({s}{d})?({t}{hr})?({s}{m})?({s}{sec})?&#34;&#34;&#34;
        &#34;&#34;&#34;Z?&#34;&#34;&#34;
        &#34;&#34;&#34;$&#34;&#34;&#34;
    )</code></pre>
</details>
</dd>
<dt id="control.typ.datetime.getDefaultDate"><code class="name flex">
<span>def <span class="ident">getDefaultDate</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDefaultDate():
    today = now()
    return (
        today.year,
        today.month,
        today.day,
        today.hour,
        today.minute,
        today.second,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.typ.datetime.Datetime"><code class="flex name class">
<span>class <span class="ident">Datetime</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Type class for date-time values</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Datetime(TypeBase):
    &#34;&#34;&#34;Type class for date-time values&#34;&#34;&#34;
    rawType = dt
    widgetType = N.text
    pattern = DATETIME_PATTERN

    def partition(self, strVal):
        &#34;&#34;&#34;Split a datetime string into 3 date components and 3 time components.

        !!! note
            The fraction part of seconds is ignored.

        !!! warning
            If there are missing components, they will be taken from the default date,
            which is `now`.

        Parameters
        ----------
        strVal: string
        &#34;&#34;&#34;
        normalVal = dtTrim.sub(E, strVal)
        if not normalVal:
            return None

        normalParts = [int(p) for p in dtSep.split(normalVal)]
        if len(normalParts) == 0:
            return None

        if not 1900 &lt;= normalParts[0] &lt;= 2100:
            return None

        defaultDate = getDefaultDate()
        if len(normalParts) &gt; 6:
            normalParts = normalParts[0:6]
        if len(normalParts) &lt; 6:
            normalParts = [
                normalParts[i] if i &lt; len(normalParts) else defaultDate[i]
                for i in range(6)
            ]
        try:
            dt(*normalParts)  # only for checking
        except Exception:
            normalParts = defaultDate
        return normalParts

    def normalize(self, strVal):
        normalParts = self.partition(strVal)
        if normalParts is None:
            return E
        return DATETIME_FORMAT.format(*normalParts)

    def fromStr(self, editVal):
        if not editVal:
            return None
        if editVal == N.now:
            return now()
        normalParts = self.partition(editVal)
        if normalParts is None:
            return None
        cast = self.rawType
        return cast(*normalParts)

    def toDisplay(self, val, markup=True):
        if val is None:
            return QQ if markup else Qq
        valBare = self.normalize(val.isoformat())
        return H.span(valBare) if markup else valBare

    def toEdit(self, val):
        return E if val is None else self.normalize(val.isoformat())

    def toOrig(self, val):
        if val is None:
            return None
        return self.normalize(val.isoformat())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="control.typ.base.TypeBase" href="base.html#control.typ.base.TypeBase">TypeBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="control.typ.datetime.Datetime.pattern"><code class="name">var <span class="ident">pattern</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="control.typ.datetime.Datetime.rawType"><code class="name">var <span class="ident">rawType</span></code></dt>
<dd>
<section class="desc"><p>datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])</p>
<p>The year, month and day arguments are required. tzinfo may be None, or an
instance of a tzinfo subclass. The remaining arguments may be ints.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class datetime(date):
    &#34;&#34;&#34;datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])

    The year, month and day arguments are required. tzinfo may be None, or an
    instance of a tzinfo subclass. The remaining arguments may be ints.
    &#34;&#34;&#34;
    __slots__ = date.__slots__ + time.__slots__

    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,
                microsecond=0, tzinfo=None, *, fold=0):
        if (isinstance(year, (bytes, str)) and len(year) == 10 and
            1 &lt;= ord(year[2:3])&amp;0x7F &lt;= 12):
            # Pickle support
            if isinstance(year, str):
                try:
                    year = bytes(year, &#39;latin1&#39;)
                except UnicodeEncodeError:
                    # More informative error message.
                    raise ValueError(
                        &#34;Failed to encode latin1 string when unpickling &#34;
                        &#34;a datetime object. &#34;
                        &#34;pickle.load(data, encoding=&#39;latin1&#39;) is assumed.&#34;)
            self = object.__new__(cls)
            self.__setstate(year, month)
            self._hashcode = -1
            return self
        year, month, day = _check_date_fields(year, month, day)
        hour, minute, second, microsecond, fold = _check_time_fields(
            hour, minute, second, microsecond, fold)
        _check_tzinfo_arg(tzinfo)
        self = object.__new__(cls)
        self._year = year
        self._month = month
        self._day = day
        self._hour = hour
        self._minute = minute
        self._second = second
        self._microsecond = microsecond
        self._tzinfo = tzinfo
        self._hashcode = -1
        self._fold = fold
        return self

    # Read-only field accessors
    @property
    def hour(self):
        &#34;&#34;&#34;hour (0-23)&#34;&#34;&#34;
        return self._hour

    @property
    def minute(self):
        &#34;&#34;&#34;minute (0-59)&#34;&#34;&#34;
        return self._minute

    @property
    def second(self):
        &#34;&#34;&#34;second (0-59)&#34;&#34;&#34;
        return self._second

    @property
    def microsecond(self):
        &#34;&#34;&#34;microsecond (0-999999)&#34;&#34;&#34;
        return self._microsecond

    @property
    def tzinfo(self):
        &#34;&#34;&#34;timezone info object&#34;&#34;&#34;
        return self._tzinfo

    @property
    def fold(self):
        return self._fold

    @classmethod
    def _fromtimestamp(cls, t, utc, tz):
        &#34;&#34;&#34;Construct a datetime from a POSIX timestamp (like time.time()).

        A timezone info object may be passed in as well.
        &#34;&#34;&#34;
        frac, t = _math.modf(t)
        us = round(frac * 1e6)
        if us &gt;= 1000000:
            t += 1
            us -= 1000000
        elif us &lt; 0:
            t -= 1
            us += 1000000

        converter = _time.gmtime if utc else _time.localtime
        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)
        ss = min(ss, 59)    # clamp out leap seconds if the platform has them
        result = cls(y, m, d, hh, mm, ss, us, tz)
        if tz is None:
            # As of version 2015f max fold in IANA database is
            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.
            # Let&#39;s probe 24 hours in the past to detect a transition:
            max_fold_seconds = 24 * 3600

            # On Windows localtime_s throws an OSError for negative values,
            # thus we can&#39;t perform fold detection for values of time less
            # than the max time fold. See comments in _datetimemodule&#39;s
            # version of this method for more details.
            if t &lt; max_fold_seconds and sys.platform.startswith(&#34;win&#34;):
                return result

            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]
            probe1 = cls(y, m, d, hh, mm, ss, us, tz)
            trans = result - probe1 - timedelta(0, max_fold_seconds)
            if trans.days &lt; 0:
                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]
                probe2 = cls(y, m, d, hh, mm, ss, us, tz)
                if probe2 == result:
                    result._fold = 1
        else:
            result = tz.fromutc(result)
        return result

    @classmethod
    def fromtimestamp(cls, t, tz=None):
        &#34;&#34;&#34;Construct a datetime from a POSIX timestamp (like time.time()).

        A timezone info object may be passed in as well.
        &#34;&#34;&#34;
        _check_tzinfo_arg(tz)

        return cls._fromtimestamp(t, tz is not None, tz)

    @classmethod
    def utcfromtimestamp(cls, t):
        &#34;&#34;&#34;Construct a naive UTC datetime from a POSIX timestamp.&#34;&#34;&#34;
        return cls._fromtimestamp(t, True, None)

    @classmethod
    def now(cls, tz=None):
        &#34;Construct a datetime from time.time() and optional time zone info.&#34;
        t = _time.time()
        return cls.fromtimestamp(t, tz)

    @classmethod
    def utcnow(cls):
        &#34;Construct a UTC datetime from time.time().&#34;
        t = _time.time()
        return cls.utcfromtimestamp(t)

    @classmethod
    def combine(cls, date, time, tzinfo=True):
        &#34;Construct a datetime from a given date and a given time.&#34;
        if not isinstance(date, _date_class):
            raise TypeError(&#34;date argument must be a date instance&#34;)
        if not isinstance(time, _time_class):
            raise TypeError(&#34;time argument must be a time instance&#34;)
        if tzinfo is True:
            tzinfo = time.tzinfo
        return cls(date.year, date.month, date.day,
                   time.hour, time.minute, time.second, time.microsecond,
                   tzinfo, fold=time.fold)

    @classmethod
    def fromisoformat(cls, date_string):
        &#34;&#34;&#34;Construct a datetime from the output of datetime.isoformat().&#34;&#34;&#34;
        if not isinstance(date_string, str):
            raise TypeError(&#39;fromisoformat: argument must be str&#39;)

        # Split this at the separator
        dstr = date_string[0:10]
        tstr = date_string[11:]

        try:
            date_components = _parse_isoformat_date(dstr)
        except ValueError:
            raise ValueError(f&#39;Invalid isoformat string: {date_string!r}&#39;)

        if tstr:
            try:
                time_components = _parse_isoformat_time(tstr)
            except ValueError:
                raise ValueError(f&#39;Invalid isoformat string: {date_string!r}&#39;)
        else:
            time_components = [0, 0, 0, 0, None]

        return cls(*(date_components + time_components))

    def timetuple(self):
        &#34;Return local time tuple compatible with time.localtime().&#34;
        dst = self.dst()
        if dst is None:
            dst = -1
        elif dst:
            dst = 1
        else:
            dst = 0
        return _build_struct_time(self.year, self.month, self.day,
                                  self.hour, self.minute, self.second,
                                  dst)

    def _mktime(self):
        &#34;&#34;&#34;Return integer POSIX timestamp.&#34;&#34;&#34;
        epoch = datetime(1970, 1, 1)
        max_fold_seconds = 24 * 3600
        t = (self - epoch) // timedelta(0, 1)
        def local(u):
            y, m, d, hh, mm, ss = _time.localtime(u)[:6]
            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)

        # Our goal is to solve t = local(u) for u.
        a = local(t) - t
        u1 = t - a
        t1 = local(u1)
        if t1 == t:
            # We found one solution, but it may not be the one we need.
            # Look for an earlier solution (if `fold` is 0), or a
            # later one (if `fold` is 1).
            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]
            b = local(u2) - u2
            if a == b:
                return u1
        else:
            b = t1 - u1
            assert a != b
        u2 = t - b
        t2 = local(u2)
        if t2 == t:
            return u2
        if t1 == t:
            return u1
        # We have found both offsets a and b, but neither t - a nor t - b is
        # a solution.  This means t is in the gap.
        return (max, min)[self.fold](u1, u2)


    def timestamp(self):
        &#34;Return POSIX timestamp as float&#34;
        if self._tzinfo is None:
            s = self._mktime()
            return s + self.microsecond / 1e6
        else:
            return (self - _EPOCH).total_seconds()

    def utctimetuple(self):
        &#34;Return UTC time tuple compatible with time.gmtime().&#34;
        offset = self.utcoffset()
        if offset:
            self -= offset
        y, m, d = self.year, self.month, self.day
        hh, mm, ss = self.hour, self.minute, self.second
        return _build_struct_time(y, m, d, hh, mm, ss, 0)

    def date(self):
        &#34;Return the date part.&#34;
        return date(self._year, self._month, self._day)

    def time(self):
        &#34;Return the time part, with tzinfo None.&#34;
        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)

    def timetz(self):
        &#34;Return the time part, with same tzinfo.&#34;
        return time(self.hour, self.minute, self.second, self.microsecond,
                    self._tzinfo, fold=self.fold)

    def replace(self, year=None, month=None, day=None, hour=None,
                minute=None, second=None, microsecond=None, tzinfo=True,
                *, fold=None):
        &#34;&#34;&#34;Return a new datetime with new values for the specified fields.&#34;&#34;&#34;
        if year is None:
            year = self.year
        if month is None:
            month = self.month
        if day is None:
            day = self.day
        if hour is None:
            hour = self.hour
        if minute is None:
            minute = self.minute
        if second is None:
            second = self.second
        if microsecond is None:
            microsecond = self.microsecond
        if tzinfo is True:
            tzinfo = self.tzinfo
        if fold is None:
            fold = self.fold
        return type(self)(year, month, day, hour, minute, second,
                          microsecond, tzinfo, fold=fold)

    def _local_timezone(self):
        if self.tzinfo is None:
            ts = self._mktime()
        else:
            ts = (self - _EPOCH) // timedelta(seconds=1)
        localtm = _time.localtime(ts)
        local = datetime(*localtm[:6])
        try:
            # Extract TZ data if available
            gmtoff = localtm.tm_gmtoff
            zone = localtm.tm_zone
        except AttributeError:
            delta = local - datetime(*_time.gmtime(ts)[:6])
            zone = _time.strftime(&#39;%Z&#39;, localtm)
            tz = timezone(delta, zone)
        else:
            tz = timezone(timedelta(seconds=gmtoff), zone)
        return tz

    def astimezone(self, tz=None):
        if tz is None:
            tz = self._local_timezone()
        elif not isinstance(tz, tzinfo):
            raise TypeError(&#34;tz argument must be an instance of tzinfo&#34;)

        mytz = self.tzinfo
        if mytz is None:
            mytz = self._local_timezone()
            myoffset = mytz.utcoffset(self)
        else:
            myoffset = mytz.utcoffset(self)
            if myoffset is None:
                mytz = self.replace(tzinfo=None)._local_timezone()
                myoffset = mytz.utcoffset(self)

        if tz is mytz:
            return self

        # Convert self to UTC, and attach the new time zone object.
        utc = (self - myoffset).replace(tzinfo=tz)

        # Convert from UTC to tz&#39;s local time.
        return tz.fromutc(utc)

    # Ways to produce a string.

    def ctime(self):
        &#34;Return ctime() style string.&#34;
        weekday = self.toordinal() % 7 or 7
        return &#34;%s %s %2d %02d:%02d:%02d %04d&#34; % (
            _DAYNAMES[weekday],
            _MONTHNAMES[self._month],
            self._day,
            self._hour, self._minute, self._second,
            self._year)

    def isoformat(self, sep=&#39;T&#39;, timespec=&#39;auto&#39;):
        &#34;&#34;&#34;Return the time formatted according to ISO.

        The full format looks like &#39;YYYY-MM-DD HH:MM:SS.mmmmmm&#39;.
        By default, the fractional part is omitted if self.microsecond == 0.

        If self.tzinfo is not None, the UTC offset is also attached, giving
        giving a full format of &#39;YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM&#39;.

        Optional argument sep specifies the separator between date and
        time, default &#39;T&#39;.

        The optional argument timespec specifies the number of additional
        terms of the time to include.
        &#34;&#34;&#34;
        s = (&#34;%04d-%02d-%02d%c&#34; % (self._year, self._month, self._day, sep) +
             _format_time(self._hour, self._minute, self._second,
                          self._microsecond, timespec))

        off = self.utcoffset()
        tz = _format_offset(off)
        if tz:
            s += tz

        return s

    def __repr__(self):
        &#34;&#34;&#34;Convert to formal string, for repr().&#34;&#34;&#34;
        L = [self._year, self._month, self._day,  # These are never zero
             self._hour, self._minute, self._second, self._microsecond]
        if L[-1] == 0:
            del L[-1]
        if L[-1] == 0:
            del L[-1]
        s = &#34;%s.%s(%s)&#34; % (self.__class__.__module__,
                           self.__class__.__qualname__,
                           &#34;, &#34;.join(map(str, L)))
        if self._tzinfo is not None:
            assert s[-1:] == &#34;)&#34;
            s = s[:-1] + &#34;, tzinfo=%r&#34; % self._tzinfo + &#34;)&#34;
        if self._fold:
            assert s[-1:] == &#34;)&#34;
            s = s[:-1] + &#34;, fold=1)&#34;
        return s

    def __str__(self):
        &#34;Convert to string, for str().&#34;
        return self.isoformat(sep=&#39; &#39;)

    @classmethod
    def strptime(cls, date_string, format):
        &#39;string, format -&gt; new datetime parsed from a string (like time.strptime()).&#39;
        import _strptime
        return _strptime._strptime_datetime(cls, date_string, format)

    def utcoffset(self):
        &#34;&#34;&#34;Return the timezone offset as timedelta positive east of UTC (negative west of
        UTC).&#34;&#34;&#34;
        if self._tzinfo is None:
            return None
        offset = self._tzinfo.utcoffset(self)
        _check_utc_offset(&#34;utcoffset&#34;, offset)
        return offset

    def tzname(self):
        &#34;&#34;&#34;Return the timezone name.

        Note that the name is 100% informational -- there&#39;s no requirement that
        it mean anything in particular. For example, &#34;GMT&#34;, &#34;UTC&#34;, &#34;-500&#34;,
        &#34;-5:00&#34;, &#34;EDT&#34;, &#34;US/Eastern&#34;, &#34;America/New York&#34; are all valid replies.
        &#34;&#34;&#34;
        if self._tzinfo is None:
            return None
        name = self._tzinfo.tzname(self)
        _check_tzname(name)
        return name

    def dst(self):
        &#34;&#34;&#34;Return 0 if DST is not in effect, or the DST offset (as timedelta
        positive eastward) if DST is in effect.

        This is purely informational; the DST offset has already been added to
        the UTC offset returned by utcoffset() if applicable, so there&#39;s no
        need to consult dst() unless you&#39;re interested in displaying the DST
        info.
        &#34;&#34;&#34;
        if self._tzinfo is None:
            return None
        offset = self._tzinfo.dst(self)
        _check_utc_offset(&#34;dst&#34;, offset)
        return offset

    # Comparisons of datetime objects with other.

    def __eq__(self, other):
        if isinstance(other, datetime):
            return self._cmp(other, allow_mixed=True) == 0
        elif not isinstance(other, date):
            return NotImplemented
        else:
            return False

    def __le__(self, other):
        if isinstance(other, datetime):
            return self._cmp(other) &lt;= 0
        elif not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __lt__(self, other):
        if isinstance(other, datetime):
            return self._cmp(other) &lt; 0
        elif not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __ge__(self, other):
        if isinstance(other, datetime):
            return self._cmp(other) &gt;= 0
        elif not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __gt__(self, other):
        if isinstance(other, datetime):
            return self._cmp(other) &gt; 0
        elif not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def _cmp(self, other, allow_mixed=False):
        assert isinstance(other, datetime)
        mytz = self._tzinfo
        ottz = other._tzinfo
        myoff = otoff = None

        if mytz is ottz:
            base_compare = True
        else:
            myoff = self.utcoffset()
            otoff = other.utcoffset()
            # Assume that allow_mixed means that we are called from __eq__
            if allow_mixed:
                if myoff != self.replace(fold=not self.fold).utcoffset():
                    return 2
                if otoff != other.replace(fold=not other.fold).utcoffset():
                    return 2
            base_compare = myoff == otoff

        if base_compare:
            return _cmp((self._year, self._month, self._day,
                         self._hour, self._minute, self._second,
                         self._microsecond),
                        (other._year, other._month, other._day,
                         other._hour, other._minute, other._second,
                         other._microsecond))
        if myoff is None or otoff is None:
            if allow_mixed:
                return 2 # arbitrary non-zero value
            else:
                raise TypeError(&#34;cannot compare naive and aware datetimes&#34;)
        # XXX What follows could be done more efficiently...
        diff = self - other     # this will take offsets into account
        if diff.days &lt; 0:
            return -1
        return diff and 1 or 0

    def __add__(self, other):
        &#34;Add a datetime and a timedelta.&#34;
        if not isinstance(other, timedelta):
            return NotImplemented
        delta = timedelta(self.toordinal(),
                          hours=self._hour,
                          minutes=self._minute,
                          seconds=self._second,
                          microseconds=self._microsecond)
        delta += other
        hour, rem = divmod(delta.seconds, 3600)
        minute, second = divmod(rem, 60)
        if 0 &lt; delta.days &lt;= _MAXORDINAL:
            return datetime.combine(date.fromordinal(delta.days),
                                    time(hour, minute, second,
                                         delta.microseconds,
                                         tzinfo=self._tzinfo))
        raise OverflowError(&#34;result out of range&#34;)

    __radd__ = __add__

    def __sub__(self, other):
        &#34;Subtract two datetimes, or a datetime and a timedelta.&#34;
        if not isinstance(other, datetime):
            if isinstance(other, timedelta):
                return self + -other
            return NotImplemented

        days1 = self.toordinal()
        days2 = other.toordinal()
        secs1 = self._second + self._minute * 60 + self._hour * 3600
        secs2 = other._second + other._minute * 60 + other._hour * 3600
        base = timedelta(days1 - days2,
                         secs1 - secs2,
                         self._microsecond - other._microsecond)
        if self._tzinfo is other._tzinfo:
            return base
        myoff = self.utcoffset()
        otoff = other.utcoffset()
        if myoff == otoff:
            return base
        if myoff is None or otoff is None:
            raise TypeError(&#34;cannot mix naive and timezone-aware time&#34;)
        return base + otoff - myoff

    def __hash__(self):
        if self._hashcode == -1:
            if self.fold:
                t = self.replace(fold=0)
            else:
                t = self
            tzoff = t.utcoffset()
            if tzoff is None:
                self._hashcode = hash(t._getstate()[0])
            else:
                days = _ymd2ord(self.year, self.month, self.day)
                seconds = self.hour * 3600 + self.minute * 60 + self.second
                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)
        return self._hashcode

    # Pickle support.

    def _getstate(self, protocol=3):
        yhi, ylo = divmod(self._year, 256)
        us2, us3 = divmod(self._microsecond, 256)
        us1, us2 = divmod(us2, 256)
        m = self._month
        if self._fold and protocol &gt; 3:
            m += 128
        basestate = bytes([yhi, ylo, m, self._day,
                           self._hour, self._minute, self._second,
                           us1, us2, us3])
        if self._tzinfo is None:
            return (basestate,)
        else:
            return (basestate, self._tzinfo)

    def __setstate(self, string, tzinfo):
        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):
            raise TypeError(&#34;bad tzinfo state arg&#34;)
        (yhi, ylo, m, self._day, self._hour,
         self._minute, self._second, us1, us2, us3) = string
        if m &gt; 127:
            self._fold = 1
            self._month = m - 128
        else:
            self._fold = 0
            self._month = m
        self._year = yhi * 256 + ylo
        self._microsecond = (((us1 &lt;&lt; 8) | us2) &lt;&lt; 8) | us3
        self._tzinfo = tzinfo

    def __reduce_ex__(self, protocol):
        return (self.__class__, self._getstate(protocol))

    def __reduce__(self):
        return self.__reduce_ex__(2)</code></pre>
</details>
</dd>
<dt id="control.typ.datetime.Datetime.widgetType"><code class="name">var <span class="ident">widgetType</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.typ.datetime.Datetime.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, strVal)</span>
</code></dt>
<dd>
<section class="desc"><p>Split a datetime string into 3 date components and 3 time components.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The fraction part of seconds is ignored.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If there are missing components, they will be taken from the default date,
which is <code>now</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strVal</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(self, strVal):
    &#34;&#34;&#34;Split a datetime string into 3 date components and 3 time components.

    !!! note
        The fraction part of seconds is ignored.

    !!! warning
        If there are missing components, they will be taken from the default date,
        which is `now`.

    Parameters
    ----------
    strVal: string
    &#34;&#34;&#34;
    normalVal = dtTrim.sub(E, strVal)
    if not normalVal:
        return None

    normalParts = [int(p) for p in dtSep.split(normalVal)]
    if len(normalParts) == 0:
        return None

    if not 1900 &lt;= normalParts[0] &lt;= 2100:
        return None

    defaultDate = getDefaultDate()
    if len(normalParts) &gt; 6:
        normalParts = normalParts[0:6]
    if len(normalParts) &lt; 6:
        normalParts = [
            normalParts[i] if i &lt; len(normalParts) else defaultDate[i]
            for i in range(6)
        ]
    try:
        dt(*normalParts)  # only for checking
    except Exception:
        normalParts = defaultDate
    return normalParts</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="control.typ.base.TypeBase" href="base.html#control.typ.base.TypeBase">TypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="control.typ.base.TypeBase.fromStr" href="base.html#control.typ.base.TypeBase.fromStr">fromStr</a></code></li>
<li><code><a title="control.typ.base.TypeBase.needsContext" href="base.html#control.typ.base.TypeBase.needsContext">needsContext</a></code></li>
<li><code><a title="control.typ.base.TypeBase.normalize" href="base.html#control.typ.base.TypeBase.normalize">normalize</a></code></li>
<li><code><a title="control.typ.base.TypeBase.toDisplay" href="base.html#control.typ.base.TypeBase.toDisplay">toDisplay</a></code></li>
<li><code><a title="control.typ.base.TypeBase.toEdit" href="base.html#control.typ.base.TypeBase.toEdit">toEdit</a></code></li>
<li><code><a title="control.typ.base.TypeBase.toOrig" href="base.html#control.typ.base.TypeBase.toOrig">toOrig</a></code></li>
<li><code><a title="control.typ.base.TypeBase.validationMsg" href="base.html#control.typ.base.TypeBase.validationMsg">validationMsg</a></code></li>
<li><code><a title="control.typ.base.TypeBase.widget" href="base.html#control.typ.base.TypeBase.widget">widget</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control.typ" href="index.html">control.typ</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="control.typ.datetime.genDatetimePattern" href="#control.typ.datetime.genDatetimePattern">genDatetimePattern</a></code></li>
<li><code><a title="control.typ.datetime.getDefaultDate" href="#control.typ.datetime.getDefaultDate">getDefaultDate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.typ.datetime.Datetime" href="#control.typ.datetime.Datetime">Datetime</a></code></h4>
<ul class="">
<li><code><a title="control.typ.datetime.Datetime.partition" href="#control.typ.datetime.Datetime.partition">partition</a></code></li>
<li><code><a title="control.typ.datetime.Datetime.pattern" href="#control.typ.datetime.Datetime.pattern">pattern</a></code></li>
<li><code><a title="control.typ.datetime.Datetime.rawType" href="#control.typ.datetime.Datetime.rawType">rawType</a></code></li>
<li><code><a title="control.typ.datetime.Datetime.widgetType" href="#control.typ.datetime.Datetime.widgetType">widgetType</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>