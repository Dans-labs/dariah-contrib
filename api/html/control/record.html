<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>control.record API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.record</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from config import Config as C, Names as N
from control.perm import permRecord
from control.utils import pick as G, cap1, E, ELLIPS, ONE, S
from control.html import HtmlElements as H
from control.field import Field

from control.cust.factory_details import factory as detailsFactory


CT = C.tables
CW = C.web


MASTERS = CT.masters
MAIN_TABLE = CT.userTables[0]
ACTUAL_TABLES = set(CT.actualTables)
REFRESH_TABLES = set(CT.refreshTables)
USER_TABLES_LIST = CT.userTables
USER_TABLES = set(USER_TABLES_LIST)
WORKFLOW_TABLES = USER_TABLES | set(CT.userEntryTables)
CASCADE_SPECS = CT.cascade

# an easy way to go from assessment to contrib and from contrib to assessment
# used in deleteButton

TO_MASTER = {
    USER_TABLES_LIST[i + 1]: USER_TABLES_LIST[i]
    for i in range(len(USER_TABLES_LIST) - 1)
}


class Record:
    &#34;&#34;&#34;Deals with records.&#34;&#34;&#34;

    inheritProps = (
        N.context,
        N.uid,
        N.eppn,
        N.mkTable,
        N.table,
        N.fields,
        N.prov,
        N.isUserTable,
        N.isUserEntryTable,
        N.itemLabels,
    )

    def __init__(
        self,
        tableObj,
        eid=None,
        record=None,
        withDetails=False,
        readonly=False,
        bodyMethod=None,
    ):
        &#34;&#34;&#34;Store the incoming information.

        A number of properties will be inherited from the table object
        that spawns a record object.

        Set the DetailsClass to a suitable derived class of Details,
        otherwise to the base class `control.details.Details` itself.

        Parameters
        ----------
        tableObj: object
            A `control.table.Table` object (or one of a derived class)
        eid, record, withDetails, readonly, bodyMethod
            See `control.table.Table.record`
        &#34;&#34;&#34;

        for prop in Record.inheritProps:
            setattr(self, prop, getattr(tableObj, prop, None))

        self.tableObj = tableObj
        self.withDetails = withDetails
        self.readonly = readonly
        self.bodyMethod = bodyMethod

        context = self.context
        table = self.table

        self.DetailsClass = detailsFactory(table)

        if record is None:
            record = context.getItem(table, eid)
        self.record = record
        self.eid = G(record, N._id)

        self.setPerm()
        self.setWorkflow()
        self.mayDelete = self.getDelPerm()

    def getDelPerm(self):
        &#34;&#34;&#34;Compute the delete permission for this record.

            The unbreakable rule is:
            *   Records with dependencies cannot be deleted if the dependencies
                are not configured as `cascade-delete` in tables.yaml.

            The next rules are workflow rules:

            *   if a record is fixed due to workflow constraints, no one can delete it;
            *   if a record is unfixed due to workflow, a user may delete it,
                irrespective of normal permissions; workflow will determine
                which records will appear unfixed to which users;

            If these rules do not clinch it, the normal permission rules will
            be applied:

            *   authenticated users may delete their own records in the
                `contrib`, `assessment` and `review` tables
            *   superusers may delete records if the configured edit
                permissions allow them
        &#34;&#34;&#34;

        context = self.context
        auth = context.auth
        isUserTable = self.isUserTable
        isUserEntryTable = self.isUserEntryTable
        readonly = self.readonly
        perm = self.perm
        fixed = self.fixed

        isAuthenticated = auth.authenticated()
        isSuperuser = auth.superuser()

        normalDelPerm = (
            not isUserEntryTable
            and not readonly
            and isAuthenticated
            and (isSuperuser or isUserTable and G(perm, N.isEdit))
        )
        return normalDelPerm if fixed is None else not fixed

    def reload(
        self, record,
    ):
        &#34;&#34;&#34;Re-initializes a record object if its underlying data has changed.

        This might be caused by an update in the record itself,
        or a change in workflow conditions.
        &#34;&#34;&#34;

        self.record = record
        self.setPerm()
        self.setWorkflow()
        self.mayDelete = self.getDelPerm()

    def getDependencies(self):
        &#34;&#34;&#34;Compute dependent records.

        See `control.db.Db.dependencies`.
        &#34;&#34;&#34;

        context = self.context
        db = context.db
        table = self.table
        record = self.record

        return db.dependencies(table, record)

    def setPerm(self):
        &#34;&#34;&#34;Compute permission info for this record.

        See `control.perm.permRecord`.
        &#34;&#34;&#34;

        context = self.context
        table = self.table
        record = self.record

        self.perm = permRecord(context, table, record)

    def setWorkflow(self):
        &#34;&#34;&#34;Compute a workflow item for this record.

        The workflow item corresponds to this record
        if it is in the contrib table, otherwise to the
        contrib that is the (grand)master of this record.

        See `control.context.Context.getWorkflowItem` and
        `control.workflow.apply.WorkflowItem`.

        Returns
        -------
        void
            The attribute `wfitem` will point to the workflow item.
            If the record is not a valid part of any workflow,
            or if there is no workflow item found,
            `wfitem` will be set to `None`.
        &#34;&#34;&#34;

        context = self.context
        perm = self.perm
        table = self.table
        eid = self.eid
        record = self.record

        contribId = G(perm, N.contribId)

        self.kind = None
        self.fixed = None
        valid = False

        wfitem = context.getWorkflowItem(contribId)
        if wfitem:
            self.kind = wfitem.getKind(table, record)
            valid = wfitem.isValid(table, eid, record)
            self.fixed = wfitem.checkFixed(self)
        else:
            valid = False if table in USER_TABLES - {MAIN_TABLE} else True

        self.valid = valid
        self.wfitem = wfitem if valid and wfitem else None

    def adjustWorkflow(self, update=True, delete=False):
        &#34;&#34;&#34;Recompute workflow information.

        When this record or some other record has changed, it could have had
        an impact on the workflow.
        If there is reason to assume this has happened, this function can be called
        to recompute the workflow item.

        !!! warning
            Do not confuse this method with the one with the same name in Tables:
            `control.table.Table.adjustWorkflow` which does its work after the
            insertion of a record.

        Parameters
        ----------
        update: boolean, optional `True`
            If `True`, reset the attribute `wfitem` to the recomputed workflow.
            Otherwise, recomputation is done, but the attribute is not reset.
            This is done if there is no use of the workflow info for the remaining
            steps in processing the request.
        delete: boolean, optional `False`
            If `True`, delete the workflow item and set the attribute `wfitem`
            to `None`

        Returns
        -------
        void
            The attribute `wfitem` will be set again.
        &#34;&#34;&#34;

        context = self.context
        wf = context.wf
        perm = self.perm

        contribId = G(perm, N.contribId)
        if delete:
            wf.delete(contribId)
            self.wfitem = None
        else:
            wf.recompute(contribId)
            if update:
                self.wfitem = context.getWorkflowItem(contribId, requireFresh=True)

    def command(self, command):
        &#34;&#34;&#34;Perform a workflow command.
        See `control.workflow.apply.WorkflowItem.doCommand`.
        &#34;&#34;&#34;

        wfitem = self.wfitem

        if wfitem:
            return wfitem.doCommand(command, self)

        table = self.table
        eid = self.eid

        return f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;

    def field(self, fieldName, **kwargs):
        table = self.table
        wfitem = self.wfitem

        if wfitem:
            fixed = wfitem.checkFixed(self, field=fieldName)
            if fixed:
                kwargs[N.mayEdit] = False
            if wfitem.isCommand(table, fieldName):
                kwargs[N.mayRead] = False
                kwargs[N.mayEdit] = not fixed
        return Field(self, fieldName, **kwargs)

    def delete(self):
        mayDelete = self.mayDelete
        if not mayDelete:
            return

        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            return

        nCas = G(dependencies, N.cascade, default=0)
        if nCas:
            if not self.deleteDetails():
                return

        context = self.context
        table = self.table
        eid = self.eid

        context.deleteItem(table, eid)

        if table == MAIN_TABLE:
            self.adjustWorkflow(delete=True)
        elif table in WORKFLOW_TABLES:
            self.adjustWorkflow(update=False)

    def deleteDetails(self):
        context = self.context
        db = context.db
        table = self.table
        eid = self.eid

        for dtable in G(CASCADE_SPECS, table, default=[]):
            db.deleteMany(dtable, {table: eid})
        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)
        return nRef == 0

    def body(self, myMasters=None, hideMasters=False):
        fieldSpecs = self.fields
        provSpecs = self.prov

        return H.join(
            self.field(field, asMaster=field in myMasters).wrap()
            for field in fieldSpecs
            if (field not in provSpecs and not (hideMasters and field in myMasters))
        )

    def wrap(
        self,
        inner=True,
        wrapMethod=None,
        expanded=1,
        withProv=True,
        hideMasters=False,
        addCls=E,
    ):
        table = self.table
        eid = self.eid
        record = self.record
        provSpecs = self.prov
        valid = self.valid
        withDetails = self.withDetails

        withRefresh = table in REFRESH_TABLES

        func = getattr(self, wrapMethod, None) if wrapMethod else None
        if func:
            return func()

        bodyMethod = self.bodyMethod
        urlExtra = f&#34;&#34;&#34;?method={bodyMethod}&#34;&#34;&#34; if bodyMethod else E
        fetchUrl = f&#34;&#34;&#34;/api/{table}/{N.item}/{eid}&#34;&#34;&#34;

        itemKey = f&#34;&#34;&#34;{table}/{G(record, N._id)}&#34;&#34;&#34;
        theTitle = self.title()

        if expanded == -1:
            return H.details(
                theTitle,
                H.div(ELLIPS),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=E,
            )

        bodyFunc = (
            getattr(self, f&#34;&#34;&#34;{N.body}{cap1(bodyMethod)}&#34;&#34;&#34;, self.body)
            if bodyMethod
            else self.body
        )
        myMasters = G(MASTERS, table, default=[])

        deleteButton = self.deleteButton()

        innerCls = &#34; inner&#34; if inner else E
        warningCls = E if valid else &#34; warning &#34;

        provenance = (
            H.div(
                H.detailx(
                    (N.prov, N.dismiss),
                    H.div(
                        [self.field(field).wrap() for field in provSpecs], cls=&#34;prov&#34;
                    ),
                    f&#34;&#34;&#34;{table}/{G(record, N._id)}/{N.prov}&#34;&#34;&#34;,
                    openAtts=dict(
                        cls=&#34;button small&#34;,
                        title=&#34;Provenance and editors of this record&#34;,
                    ),
                    closeAtts=dict(cls=&#34;button small&#34;, title=&#34;Hide provenance&#34;),
                    cls=&#34;prov&#34;,
                ),
                cls=&#34;provx&#34;,
            )
            if withProv
            else E
        )

        main = H.div(
            [
                deleteButton,
                H.div(
                    H.join(bodyFunc(myMasters=myMasters, hideMasters=hideMasters)),
                    cls=f&#34;{table.lower()}&#34;,
                ),
                *provenance,
            ],
            cls=f&#34;record{innerCls} {addCls} {warningCls}&#34;,
        )

        rButton = H.iconr(itemKey, &#34;#main&#34;, msg=table) if withRefresh else E
        details = self.DetailsClass(self).wrap() if withDetails else E

        return (
            H.details(
                rButton + theTitle,
                H.div(main + details),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=&#34;&#34;&#34;/title&#34;&#34;&#34;,
                fat=ONE,
                forceopen=ONE,
                open=True,
            )
            if expanded == 1
            else H.div(main + details)
        )

    def deleteButton(self):
        mayDelete = self.mayDelete

        if not mayDelete:
            return E

        record = self.record
        table = self.table
        itemSingle = self.itemLabels[0]

        dependencies = self.getDependencies()

        nCas = G(dependencies, N.cascade, default=0)
        cascadeMsg = (
            H.span(
                f&#34;&#34;&#34;{nCas} detail record{E if nCas == 1 else S}&#34;&#34;&#34;,
                title=f&#34;&#34;&#34;Detail records will be deleted with the master record&#34;&#34;&#34;,
                cls=&#34;label small warning-o right&#34;,
            )
            if nCas
            else E
        )

        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            plural = E if nRef == 1 else S
            return H.span(
                [
                    H.icon(
                        N.chain,
                        cls=&#34;medium right&#34;,
                        title=f&#34;&#34;&#34;Cannot delete because of {nRef} dependent record{plural}&#34;&#34;&#34;,
                    ),
                    H.span(
                        f&#34;&#34;&#34;{nRef} dependent record{plural}&#34;&#34;&#34;,
                        cls=&#34;label small warning-o right&#34;,
                    ),
                    cascadeMsg,
                ]
            )

        if table in TO_MASTER:
            masterTable = G(TO_MASTER, table)
            masterId = G(record, masterTable)
        else:
            masterTable = None
            masterId = None

        url = (
            f&#34;&#34;&#34;/api/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
            if masterTable is None or masterId is None
            else f&#34;&#34;&#34;/api/{masterTable}/{masterId}/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
        )
        return H.span(
            [
                cascadeMsg,
                H.iconx(
                    N.delete,
                    cls=&#34;medium right&#34;,
                    href=url,
                    title=f&#34;&#34;&#34;Delete this {itemSingle}&#34;&#34;&#34;,
                ),
            ]
        )

    def title(self):
        record = self.record
        valid = self.valid

        warningCls = E if valid else &#34; warning &#34;

        return Record.titleRaw(self, record, cls=warningCls)

    @staticmethod
    def titleRaw(obj, record, cls=E):
        table = obj.table
        context = obj.context

        types = context.types
        typesObj = getattr(types, table, None)

        isActual = table not in ACTUAL_TABLES or G(record, N.actual, default=False)
        atts = dict(cls=cls) if isActual else dict(cls=f&#34;inactual {cls}&#34;)

        return H.span(typesObj.title(record=record), **atts)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.record.Record"><code class="flex name class">
<span>class <span class="ident">Record</span></span>
<span>(</span><span>tableObj, eid=None, record=None, withDetails=False, readonly=False, bodyMethod=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Deals with records.</p>
<p>Store the incoming information.</p>
<p>A number of properties will be inherited from the table object
that spawns a record object.</p>
<p>Set the DetailsClass to a suitable derived class of Details,
otherwise to the base class <a title="control.details.Details" href="details.html#control.details.Details"><code>Details</code></a> itself.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tableObj</code></strong> :&ensp;<code>object</code></dt>
<dd>A <a title="control.table.Table" href="table.html#control.table.Table"><code>Table</code></a> object (or one of a derived class)</dd>
<dt><strong><code>eid</code></strong>, <strong><code>record</code></strong>, <strong><code>withDetails</code></strong>, <strong><code>readonly</code></strong>, <strong><code>bodyMethod</code></strong></dt>
<dd>See <a title="control.table.Table.record" href="table.html#control.table.Table.record"><code>Table.record()</code></a></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Record:
    &#34;&#34;&#34;Deals with records.&#34;&#34;&#34;

    inheritProps = (
        N.context,
        N.uid,
        N.eppn,
        N.mkTable,
        N.table,
        N.fields,
        N.prov,
        N.isUserTable,
        N.isUserEntryTable,
        N.itemLabels,
    )

    def __init__(
        self,
        tableObj,
        eid=None,
        record=None,
        withDetails=False,
        readonly=False,
        bodyMethod=None,
    ):
        &#34;&#34;&#34;Store the incoming information.

        A number of properties will be inherited from the table object
        that spawns a record object.

        Set the DetailsClass to a suitable derived class of Details,
        otherwise to the base class `control.details.Details` itself.

        Parameters
        ----------
        tableObj: object
            A `control.table.Table` object (or one of a derived class)
        eid, record, withDetails, readonly, bodyMethod
            See `control.table.Table.record`
        &#34;&#34;&#34;

        for prop in Record.inheritProps:
            setattr(self, prop, getattr(tableObj, prop, None))

        self.tableObj = tableObj
        self.withDetails = withDetails
        self.readonly = readonly
        self.bodyMethod = bodyMethod

        context = self.context
        table = self.table

        self.DetailsClass = detailsFactory(table)

        if record is None:
            record = context.getItem(table, eid)
        self.record = record
        self.eid = G(record, N._id)

        self.setPerm()
        self.setWorkflow()
        self.mayDelete = self.getDelPerm()

    def getDelPerm(self):
        &#34;&#34;&#34;Compute the delete permission for this record.

            The unbreakable rule is:
            *   Records with dependencies cannot be deleted if the dependencies
                are not configured as `cascade-delete` in tables.yaml.

            The next rules are workflow rules:

            *   if a record is fixed due to workflow constraints, no one can delete it;
            *   if a record is unfixed due to workflow, a user may delete it,
                irrespective of normal permissions; workflow will determine
                which records will appear unfixed to which users;

            If these rules do not clinch it, the normal permission rules will
            be applied:

            *   authenticated users may delete their own records in the
                `contrib`, `assessment` and `review` tables
            *   superusers may delete records if the configured edit
                permissions allow them
        &#34;&#34;&#34;

        context = self.context
        auth = context.auth
        isUserTable = self.isUserTable
        isUserEntryTable = self.isUserEntryTable
        readonly = self.readonly
        perm = self.perm
        fixed = self.fixed

        isAuthenticated = auth.authenticated()
        isSuperuser = auth.superuser()

        normalDelPerm = (
            not isUserEntryTable
            and not readonly
            and isAuthenticated
            and (isSuperuser or isUserTable and G(perm, N.isEdit))
        )
        return normalDelPerm if fixed is None else not fixed

    def reload(
        self, record,
    ):
        &#34;&#34;&#34;Re-initializes a record object if its underlying data has changed.

        This might be caused by an update in the record itself,
        or a change in workflow conditions.
        &#34;&#34;&#34;

        self.record = record
        self.setPerm()
        self.setWorkflow()
        self.mayDelete = self.getDelPerm()

    def getDependencies(self):
        &#34;&#34;&#34;Compute dependent records.

        See `control.db.Db.dependencies`.
        &#34;&#34;&#34;

        context = self.context
        db = context.db
        table = self.table
        record = self.record

        return db.dependencies(table, record)

    def setPerm(self):
        &#34;&#34;&#34;Compute permission info for this record.

        See `control.perm.permRecord`.
        &#34;&#34;&#34;

        context = self.context
        table = self.table
        record = self.record

        self.perm = permRecord(context, table, record)

    def setWorkflow(self):
        &#34;&#34;&#34;Compute a workflow item for this record.

        The workflow item corresponds to this record
        if it is in the contrib table, otherwise to the
        contrib that is the (grand)master of this record.

        See `control.context.Context.getWorkflowItem` and
        `control.workflow.apply.WorkflowItem`.

        Returns
        -------
        void
            The attribute `wfitem` will point to the workflow item.
            If the record is not a valid part of any workflow,
            or if there is no workflow item found,
            `wfitem` will be set to `None`.
        &#34;&#34;&#34;

        context = self.context
        perm = self.perm
        table = self.table
        eid = self.eid
        record = self.record

        contribId = G(perm, N.contribId)

        self.kind = None
        self.fixed = None
        valid = False

        wfitem = context.getWorkflowItem(contribId)
        if wfitem:
            self.kind = wfitem.getKind(table, record)
            valid = wfitem.isValid(table, eid, record)
            self.fixed = wfitem.checkFixed(self)
        else:
            valid = False if table in USER_TABLES - {MAIN_TABLE} else True

        self.valid = valid
        self.wfitem = wfitem if valid and wfitem else None

    def adjustWorkflow(self, update=True, delete=False):
        &#34;&#34;&#34;Recompute workflow information.

        When this record or some other record has changed, it could have had
        an impact on the workflow.
        If there is reason to assume this has happened, this function can be called
        to recompute the workflow item.

        !!! warning
            Do not confuse this method with the one with the same name in Tables:
            `control.table.Table.adjustWorkflow` which does its work after the
            insertion of a record.

        Parameters
        ----------
        update: boolean, optional `True`
            If `True`, reset the attribute `wfitem` to the recomputed workflow.
            Otherwise, recomputation is done, but the attribute is not reset.
            This is done if there is no use of the workflow info for the remaining
            steps in processing the request.
        delete: boolean, optional `False`
            If `True`, delete the workflow item and set the attribute `wfitem`
            to `None`

        Returns
        -------
        void
            The attribute `wfitem` will be set again.
        &#34;&#34;&#34;

        context = self.context
        wf = context.wf
        perm = self.perm

        contribId = G(perm, N.contribId)
        if delete:
            wf.delete(contribId)
            self.wfitem = None
        else:
            wf.recompute(contribId)
            if update:
                self.wfitem = context.getWorkflowItem(contribId, requireFresh=True)

    def command(self, command):
        &#34;&#34;&#34;Perform a workflow command.
        See `control.workflow.apply.WorkflowItem.doCommand`.
        &#34;&#34;&#34;

        wfitem = self.wfitem

        if wfitem:
            return wfitem.doCommand(command, self)

        table = self.table
        eid = self.eid

        return f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;

    def field(self, fieldName, **kwargs):
        table = self.table
        wfitem = self.wfitem

        if wfitem:
            fixed = wfitem.checkFixed(self, field=fieldName)
            if fixed:
                kwargs[N.mayEdit] = False
            if wfitem.isCommand(table, fieldName):
                kwargs[N.mayRead] = False
                kwargs[N.mayEdit] = not fixed
        return Field(self, fieldName, **kwargs)

    def delete(self):
        mayDelete = self.mayDelete
        if not mayDelete:
            return

        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            return

        nCas = G(dependencies, N.cascade, default=0)
        if nCas:
            if not self.deleteDetails():
                return

        context = self.context
        table = self.table
        eid = self.eid

        context.deleteItem(table, eid)

        if table == MAIN_TABLE:
            self.adjustWorkflow(delete=True)
        elif table in WORKFLOW_TABLES:
            self.adjustWorkflow(update=False)

    def deleteDetails(self):
        context = self.context
        db = context.db
        table = self.table
        eid = self.eid

        for dtable in G(CASCADE_SPECS, table, default=[]):
            db.deleteMany(dtable, {table: eid})
        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)
        return nRef == 0

    def body(self, myMasters=None, hideMasters=False):
        fieldSpecs = self.fields
        provSpecs = self.prov

        return H.join(
            self.field(field, asMaster=field in myMasters).wrap()
            for field in fieldSpecs
            if (field not in provSpecs and not (hideMasters and field in myMasters))
        )

    def wrap(
        self,
        inner=True,
        wrapMethod=None,
        expanded=1,
        withProv=True,
        hideMasters=False,
        addCls=E,
    ):
        table = self.table
        eid = self.eid
        record = self.record
        provSpecs = self.prov
        valid = self.valid
        withDetails = self.withDetails

        withRefresh = table in REFRESH_TABLES

        func = getattr(self, wrapMethod, None) if wrapMethod else None
        if func:
            return func()

        bodyMethod = self.bodyMethod
        urlExtra = f&#34;&#34;&#34;?method={bodyMethod}&#34;&#34;&#34; if bodyMethod else E
        fetchUrl = f&#34;&#34;&#34;/api/{table}/{N.item}/{eid}&#34;&#34;&#34;

        itemKey = f&#34;&#34;&#34;{table}/{G(record, N._id)}&#34;&#34;&#34;
        theTitle = self.title()

        if expanded == -1:
            return H.details(
                theTitle,
                H.div(ELLIPS),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=E,
            )

        bodyFunc = (
            getattr(self, f&#34;&#34;&#34;{N.body}{cap1(bodyMethod)}&#34;&#34;&#34;, self.body)
            if bodyMethod
            else self.body
        )
        myMasters = G(MASTERS, table, default=[])

        deleteButton = self.deleteButton()

        innerCls = &#34; inner&#34; if inner else E
        warningCls = E if valid else &#34; warning &#34;

        provenance = (
            H.div(
                H.detailx(
                    (N.prov, N.dismiss),
                    H.div(
                        [self.field(field).wrap() for field in provSpecs], cls=&#34;prov&#34;
                    ),
                    f&#34;&#34;&#34;{table}/{G(record, N._id)}/{N.prov}&#34;&#34;&#34;,
                    openAtts=dict(
                        cls=&#34;button small&#34;,
                        title=&#34;Provenance and editors of this record&#34;,
                    ),
                    closeAtts=dict(cls=&#34;button small&#34;, title=&#34;Hide provenance&#34;),
                    cls=&#34;prov&#34;,
                ),
                cls=&#34;provx&#34;,
            )
            if withProv
            else E
        )

        main = H.div(
            [
                deleteButton,
                H.div(
                    H.join(bodyFunc(myMasters=myMasters, hideMasters=hideMasters)),
                    cls=f&#34;{table.lower()}&#34;,
                ),
                *provenance,
            ],
            cls=f&#34;record{innerCls} {addCls} {warningCls}&#34;,
        )

        rButton = H.iconr(itemKey, &#34;#main&#34;, msg=table) if withRefresh else E
        details = self.DetailsClass(self).wrap() if withDetails else E

        return (
            H.details(
                rButton + theTitle,
                H.div(main + details),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=&#34;&#34;&#34;/title&#34;&#34;&#34;,
                fat=ONE,
                forceopen=ONE,
                open=True,
            )
            if expanded == 1
            else H.div(main + details)
        )

    def deleteButton(self):
        mayDelete = self.mayDelete

        if not mayDelete:
            return E

        record = self.record
        table = self.table
        itemSingle = self.itemLabels[0]

        dependencies = self.getDependencies()

        nCas = G(dependencies, N.cascade, default=0)
        cascadeMsg = (
            H.span(
                f&#34;&#34;&#34;{nCas} detail record{E if nCas == 1 else S}&#34;&#34;&#34;,
                title=f&#34;&#34;&#34;Detail records will be deleted with the master record&#34;&#34;&#34;,
                cls=&#34;label small warning-o right&#34;,
            )
            if nCas
            else E
        )

        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            plural = E if nRef == 1 else S
            return H.span(
                [
                    H.icon(
                        N.chain,
                        cls=&#34;medium right&#34;,
                        title=f&#34;&#34;&#34;Cannot delete because of {nRef} dependent record{plural}&#34;&#34;&#34;,
                    ),
                    H.span(
                        f&#34;&#34;&#34;{nRef} dependent record{plural}&#34;&#34;&#34;,
                        cls=&#34;label small warning-o right&#34;,
                    ),
                    cascadeMsg,
                ]
            )

        if table in TO_MASTER:
            masterTable = G(TO_MASTER, table)
            masterId = G(record, masterTable)
        else:
            masterTable = None
            masterId = None

        url = (
            f&#34;&#34;&#34;/api/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
            if masterTable is None or masterId is None
            else f&#34;&#34;&#34;/api/{masterTable}/{masterId}/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
        )
        return H.span(
            [
                cascadeMsg,
                H.iconx(
                    N.delete,
                    cls=&#34;medium right&#34;,
                    href=url,
                    title=f&#34;&#34;&#34;Delete this {itemSingle}&#34;&#34;&#34;,
                ),
            ]
        )

    def title(self):
        record = self.record
        valid = self.valid

        warningCls = E if valid else &#34; warning &#34;

        return Record.titleRaw(self, record, cls=warningCls)

    @staticmethod
    def titleRaw(obj, record, cls=E):
        table = obj.table
        context = obj.context

        types = context.types
        typesObj = getattr(types, table, None)

        isActual = table not in ACTUAL_TABLES or G(record, N.actual, default=False)
        atts = dict(cls=cls) if isActual else dict(cls=f&#34;inactual {cls}&#34;)

        return H.span(typesObj.title(record=record), **atts)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="control.cust.assessment_record.AssessmentR" href="cust/assessment_record.html#control.cust.assessment_record.AssessmentR">AssessmentR</a></li>
<li><a title="control.cust.criteria_record.CriteriaR" href="cust/criteria_record.html#control.cust.criteria_record.CriteriaR">CriteriaR</a></li>
<li><a title="control.cust.criteriaentry_record.CriteriaEntryR" href="cust/criteriaentry_record.html#control.cust.criteriaentry_record.CriteriaEntryR">CriteriaEntryR</a></li>
<li><a title="control.cust.review_record.ReviewR" href="cust/review_record.html#control.cust.review_record.ReviewR">ReviewR</a></li>
<li><a title="control.cust.reviewentry_record.ReviewEntryR" href="cust/reviewentry_record.html#control.cust.reviewentry_record.ReviewEntryR">ReviewEntryR</a></li>
<li><a title="control.cust.score_record.ScoreR" href="cust/score_record.html#control.cust.score_record.ScoreR">ScoreR</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="control.record.Record.inheritProps"><code class="name">var <span class="ident">inheritProps</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="control.record.Record.titleRaw"><code class="name flex">
<span>def <span class="ident">titleRaw</span></span>(<span>obj, record, cls='')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def titleRaw(obj, record, cls=E):
    table = obj.table
    context = obj.context

    types = context.types
    typesObj = getattr(types, table, None)

    isActual = table not in ACTUAL_TABLES or G(record, N.actual, default=False)
    atts = dict(cls=cls) if isActual else dict(cls=f&#34;inactual {cls}&#34;)

    return H.span(typesObj.title(record=record), **atts)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.record.Record.adjustWorkflow"><code class="name flex">
<span>def <span class="ident">adjustWorkflow</span></span>(<span>self, update=True, delete=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Recompute workflow information.</p>
<p>When this record or some other record has changed, it could have had
an impact on the workflow.
If there is reason to assume this has happened, this function can be called
to recompute the workflow item.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not confuse this method with the one with the same name in Tables:
<a title="control.table.Table.adjustWorkflow" href="table.html#control.table.Table.adjustWorkflow"><code>Table.adjustWorkflow()</code></a> which does its work after the
insertion of a record.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>update</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If <code>True</code>, reset the attribute <code>wfitem</code> to the recomputed workflow.
Otherwise, recomputation is done, but the attribute is not reset.
This is done if there is no use of the workflow info for the remaining
steps in processing the request.</dd>
<dt><strong><code>delete</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, delete the workflow item and set the attribute <code>wfitem</code>
to <code>None</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>The attribute <code>wfitem</code> will be set again.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjustWorkflow(self, update=True, delete=False):
    &#34;&#34;&#34;Recompute workflow information.

    When this record or some other record has changed, it could have had
    an impact on the workflow.
    If there is reason to assume this has happened, this function can be called
    to recompute the workflow item.

    !!! warning
        Do not confuse this method with the one with the same name in Tables:
        `control.table.Table.adjustWorkflow` which does its work after the
        insertion of a record.

    Parameters
    ----------
    update: boolean, optional `True`
        If `True`, reset the attribute `wfitem` to the recomputed workflow.
        Otherwise, recomputation is done, but the attribute is not reset.
        This is done if there is no use of the workflow info for the remaining
        steps in processing the request.
    delete: boolean, optional `False`
        If `True`, delete the workflow item and set the attribute `wfitem`
        to `None`

    Returns
    -------
    void
        The attribute `wfitem` will be set again.
    &#34;&#34;&#34;

    context = self.context
    wf = context.wf
    perm = self.perm

    contribId = G(perm, N.contribId)
    if delete:
        wf.delete(contribId)
        self.wfitem = None
    else:
        wf.recompute(contribId)
        if update:
            self.wfitem = context.getWorkflowItem(contribId, requireFresh=True)</code></pre>
</details>
</dd>
<dt id="control.record.Record.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, myMasters=None, hideMasters=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, myMasters=None, hideMasters=False):
    fieldSpecs = self.fields
    provSpecs = self.prov

    return H.join(
        self.field(field, asMaster=field in myMasters).wrap()
        for field in fieldSpecs
        if (field not in provSpecs and not (hideMasters and field in myMasters))
    )</code></pre>
</details>
</dd>
<dt id="control.record.Record.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<section class="desc"><p>Perform a workflow command.
See <a title="control.workflow.apply.WorkflowItem.doCommand" href="workflow/apply.html#control.workflow.apply.WorkflowItem.doCommand"><code>WorkflowItem.doCommand()</code></a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(self, command):
    &#34;&#34;&#34;Perform a workflow command.
    See `control.workflow.apply.WorkflowItem.doCommand`.
    &#34;&#34;&#34;

    wfitem = self.wfitem

    if wfitem:
        return wfitem.doCommand(command, self)

    table = self.table
    eid = self.eid

    return f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="control.record.Record.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    mayDelete = self.mayDelete
    if not mayDelete:
        return

    dependencies = self.getDependencies()
    nRef = G(dependencies, N.reference, default=0)

    if nRef:
        return

    nCas = G(dependencies, N.cascade, default=0)
    if nCas:
        if not self.deleteDetails():
            return

    context = self.context
    table = self.table
    eid = self.eid

    context.deleteItem(table, eid)

    if table == MAIN_TABLE:
        self.adjustWorkflow(delete=True)
    elif table in WORKFLOW_TABLES:
        self.adjustWorkflow(update=False)</code></pre>
</details>
</dd>
<dt id="control.record.Record.deleteButton"><code class="name flex">
<span>def <span class="ident">deleteButton</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteButton(self):
    mayDelete = self.mayDelete

    if not mayDelete:
        return E

    record = self.record
    table = self.table
    itemSingle = self.itemLabels[0]

    dependencies = self.getDependencies()

    nCas = G(dependencies, N.cascade, default=0)
    cascadeMsg = (
        H.span(
            f&#34;&#34;&#34;{nCas} detail record{E if nCas == 1 else S}&#34;&#34;&#34;,
            title=f&#34;&#34;&#34;Detail records will be deleted with the master record&#34;&#34;&#34;,
            cls=&#34;label small warning-o right&#34;,
        )
        if nCas
        else E
    )

    nRef = G(dependencies, N.reference, default=0)

    if nRef:
        plural = E if nRef == 1 else S
        return H.span(
            [
                H.icon(
                    N.chain,
                    cls=&#34;medium right&#34;,
                    title=f&#34;&#34;&#34;Cannot delete because of {nRef} dependent record{plural}&#34;&#34;&#34;,
                ),
                H.span(
                    f&#34;&#34;&#34;{nRef} dependent record{plural}&#34;&#34;&#34;,
                    cls=&#34;label small warning-o right&#34;,
                ),
                cascadeMsg,
            ]
        )

    if table in TO_MASTER:
        masterTable = G(TO_MASTER, table)
        masterId = G(record, masterTable)
    else:
        masterTable = None
        masterId = None

    url = (
        f&#34;&#34;&#34;/api/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
        if masterTable is None or masterId is None
        else f&#34;&#34;&#34;/api/{masterTable}/{masterId}/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
    )
    return H.span(
        [
            cascadeMsg,
            H.iconx(
                N.delete,
                cls=&#34;medium right&#34;,
                href=url,
                title=f&#34;&#34;&#34;Delete this {itemSingle}&#34;&#34;&#34;,
            ),
        ]
    )</code></pre>
</details>
</dd>
<dt id="control.record.Record.deleteDetails"><code class="name flex">
<span>def <span class="ident">deleteDetails</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteDetails(self):
    context = self.context
    db = context.db
    table = self.table
    eid = self.eid

    for dtable in G(CASCADE_SPECS, table, default=[]):
        db.deleteMany(dtable, {table: eid})
    dependencies = self.getDependencies()
    nRef = G(dependencies, N.reference, default=0)
    return nRef == 0</code></pre>
</details>
</dd>
<dt id="control.record.Record.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>self, fieldName, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field(self, fieldName, **kwargs):
    table = self.table
    wfitem = self.wfitem

    if wfitem:
        fixed = wfitem.checkFixed(self, field=fieldName)
        if fixed:
            kwargs[N.mayEdit] = False
        if wfitem.isCommand(table, fieldName):
            kwargs[N.mayRead] = False
            kwargs[N.mayEdit] = not fixed
    return Field(self, fieldName, **kwargs)</code></pre>
</details>
</dd>
<dt id="control.record.Record.getDelPerm"><code class="name flex">
<span>def <span class="ident">getDelPerm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the delete permission for this record.</p>
<p>The unbreakable rule is:
*
Records with dependencies cannot be deleted if the dependencies
are not configured as <code>cascade-delete</code> in tables.yaml.</p>
<p>The next rules are workflow rules:</p>
<ul>
<li>if a record is fixed due to workflow constraints, no one can delete it;</li>
<li>if a record is unfixed due to workflow, a user may delete it,
irrespective of normal permissions; workflow will determine
which records will appear unfixed to which users;</li>
</ul>
<p>If these rules do not clinch it, the normal permission rules will
be applied:</p>
<ul>
<li>authenticated users may delete their own records in the
<code>contrib</code>, <code>assessment</code> and <code>review</code> tables</li>
<li>superusers may delete records if the configured edit
permissions allow them</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDelPerm(self):
    &#34;&#34;&#34;Compute the delete permission for this record.

        The unbreakable rule is:
        *   Records with dependencies cannot be deleted if the dependencies
            are not configured as `cascade-delete` in tables.yaml.

        The next rules are workflow rules:

        *   if a record is fixed due to workflow constraints, no one can delete it;
        *   if a record is unfixed due to workflow, a user may delete it,
            irrespective of normal permissions; workflow will determine
            which records will appear unfixed to which users;

        If these rules do not clinch it, the normal permission rules will
        be applied:

        *   authenticated users may delete their own records in the
            `contrib`, `assessment` and `review` tables
        *   superusers may delete records if the configured edit
            permissions allow them
    &#34;&#34;&#34;

    context = self.context
    auth = context.auth
    isUserTable = self.isUserTable
    isUserEntryTable = self.isUserEntryTable
    readonly = self.readonly
    perm = self.perm
    fixed = self.fixed

    isAuthenticated = auth.authenticated()
    isSuperuser = auth.superuser()

    normalDelPerm = (
        not isUserEntryTable
        and not readonly
        and isAuthenticated
        and (isSuperuser or isUserTable and G(perm, N.isEdit))
    )
    return normalDelPerm if fixed is None else not fixed</code></pre>
</details>
</dd>
<dt id="control.record.Record.getDependencies"><code class="name flex">
<span>def <span class="ident">getDependencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute dependent records.</p>
<p>See <a title="control.db.Db.dependencies" href="db.html#control.db.Db.dependencies"><code>Db.dependencies()</code></a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDependencies(self):
    &#34;&#34;&#34;Compute dependent records.

    See `control.db.Db.dependencies`.
    &#34;&#34;&#34;

    context = self.context
    db = context.db
    table = self.table
    record = self.record

    return db.dependencies(table, record)</code></pre>
</details>
</dd>
<dt id="control.record.Record.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<section class="desc"><p>Re-initializes a record object if its underlying data has changed.</p>
<p>This might be caused by an update in the record itself,
or a change in workflow conditions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(
    self, record,
):
    &#34;&#34;&#34;Re-initializes a record object if its underlying data has changed.

    This might be caused by an update in the record itself,
    or a change in workflow conditions.
    &#34;&#34;&#34;

    self.record = record
    self.setPerm()
    self.setWorkflow()
    self.mayDelete = self.getDelPerm()</code></pre>
</details>
</dd>
<dt id="control.record.Record.setPerm"><code class="name flex">
<span>def <span class="ident">setPerm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute permission info for this record.</p>
<p>See <a title="control.perm.permRecord" href="perm.html#control.perm.permRecord"><code>permRecord()</code></a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPerm(self):
    &#34;&#34;&#34;Compute permission info for this record.

    See `control.perm.permRecord`.
    &#34;&#34;&#34;

    context = self.context
    table = self.table
    record = self.record

    self.perm = permRecord(context, table, record)</code></pre>
</details>
</dd>
<dt id="control.record.Record.setWorkflow"><code class="name flex">
<span>def <span class="ident">setWorkflow</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute a workflow item for this record.</p>
<p>The workflow item corresponds to this record
if it is in the contrib table, otherwise to the
contrib that is the (grand)master of this record.</p>
<p>See <a title="control.context.Context.getWorkflowItem" href="context.html#control.context.Context.getWorkflowItem"><code>Context.getWorkflowItem()</code></a> and
<a title="control.workflow.apply.WorkflowItem" href="workflow/apply.html#control.workflow.apply.WorkflowItem"><code>WorkflowItem</code></a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>The attribute <code>wfitem</code> will point to the workflow item.
If the record is not a valid part of any workflow,
or if there is no workflow item found,
<code>wfitem</code> will be set to <code>None</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setWorkflow(self):
    &#34;&#34;&#34;Compute a workflow item for this record.

    The workflow item corresponds to this record
    if it is in the contrib table, otherwise to the
    contrib that is the (grand)master of this record.

    See `control.context.Context.getWorkflowItem` and
    `control.workflow.apply.WorkflowItem`.

    Returns
    -------
    void
        The attribute `wfitem` will point to the workflow item.
        If the record is not a valid part of any workflow,
        or if there is no workflow item found,
        `wfitem` will be set to `None`.
    &#34;&#34;&#34;

    context = self.context
    perm = self.perm
    table = self.table
    eid = self.eid
    record = self.record

    contribId = G(perm, N.contribId)

    self.kind = None
    self.fixed = None
    valid = False

    wfitem = context.getWorkflowItem(contribId)
    if wfitem:
        self.kind = wfitem.getKind(table, record)
        valid = wfitem.isValid(table, eid, record)
        self.fixed = wfitem.checkFixed(self)
    else:
        valid = False if table in USER_TABLES - {MAIN_TABLE} else True

    self.valid = valid
    self.wfitem = wfitem if valid and wfitem else None</code></pre>
</details>
</dd>
<dt id="control.record.Record.title"><code class="name flex">
<span>def <span class="ident">title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title(self):
    record = self.record
    valid = self.valid

    warningCls = E if valid else &#34; warning &#34;

    return Record.titleRaw(self, record, cls=warningCls)</code></pre>
</details>
</dd>
<dt id="control.record.Record.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>self, inner=True, wrapMethod=None, expanded=1, withProv=True, hideMasters=False, addCls='')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(
    self,
    inner=True,
    wrapMethod=None,
    expanded=1,
    withProv=True,
    hideMasters=False,
    addCls=E,
):
    table = self.table
    eid = self.eid
    record = self.record
    provSpecs = self.prov
    valid = self.valid
    withDetails = self.withDetails

    withRefresh = table in REFRESH_TABLES

    func = getattr(self, wrapMethod, None) if wrapMethod else None
    if func:
        return func()

    bodyMethod = self.bodyMethod
    urlExtra = f&#34;&#34;&#34;?method={bodyMethod}&#34;&#34;&#34; if bodyMethod else E
    fetchUrl = f&#34;&#34;&#34;/api/{table}/{N.item}/{eid}&#34;&#34;&#34;

    itemKey = f&#34;&#34;&#34;{table}/{G(record, N._id)}&#34;&#34;&#34;
    theTitle = self.title()

    if expanded == -1:
        return H.details(
            theTitle,
            H.div(ELLIPS),
            itemKey,
            fetchurl=fetchUrl,
            urlextra=urlExtra,
            urltitle=E,
        )

    bodyFunc = (
        getattr(self, f&#34;&#34;&#34;{N.body}{cap1(bodyMethod)}&#34;&#34;&#34;, self.body)
        if bodyMethod
        else self.body
    )
    myMasters = G(MASTERS, table, default=[])

    deleteButton = self.deleteButton()

    innerCls = &#34; inner&#34; if inner else E
    warningCls = E if valid else &#34; warning &#34;

    provenance = (
        H.div(
            H.detailx(
                (N.prov, N.dismiss),
                H.div(
                    [self.field(field).wrap() for field in provSpecs], cls=&#34;prov&#34;
                ),
                f&#34;&#34;&#34;{table}/{G(record, N._id)}/{N.prov}&#34;&#34;&#34;,
                openAtts=dict(
                    cls=&#34;button small&#34;,
                    title=&#34;Provenance and editors of this record&#34;,
                ),
                closeAtts=dict(cls=&#34;button small&#34;, title=&#34;Hide provenance&#34;),
                cls=&#34;prov&#34;,
            ),
            cls=&#34;provx&#34;,
        )
        if withProv
        else E
    )

    main = H.div(
        [
            deleteButton,
            H.div(
                H.join(bodyFunc(myMasters=myMasters, hideMasters=hideMasters)),
                cls=f&#34;{table.lower()}&#34;,
            ),
            *provenance,
        ],
        cls=f&#34;record{innerCls} {addCls} {warningCls}&#34;,
    )

    rButton = H.iconr(itemKey, &#34;#main&#34;, msg=table) if withRefresh else E
    details = self.DetailsClass(self).wrap() if withDetails else E

    return (
        H.details(
            rButton + theTitle,
            H.div(main + details),
            itemKey,
            fetchurl=fetchUrl,
            urlextra=urlExtra,
            urltitle=&#34;&#34;&#34;/title&#34;&#34;&#34;,
            fat=ONE,
            forceopen=ONE,
            open=True,
        )
        if expanded == 1
        else H.div(main + details)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.record.Record" href="#control.record.Record">Record</a></code></h4>
<ul class="two-column">
<li><code><a title="control.record.Record.adjustWorkflow" href="#control.record.Record.adjustWorkflow">adjustWorkflow</a></code></li>
<li><code><a title="control.record.Record.body" href="#control.record.Record.body">body</a></code></li>
<li><code><a title="control.record.Record.command" href="#control.record.Record.command">command</a></code></li>
<li><code><a title="control.record.Record.delete" href="#control.record.Record.delete">delete</a></code></li>
<li><code><a title="control.record.Record.deleteButton" href="#control.record.Record.deleteButton">deleteButton</a></code></li>
<li><code><a title="control.record.Record.deleteDetails" href="#control.record.Record.deleteDetails">deleteDetails</a></code></li>
<li><code><a title="control.record.Record.field" href="#control.record.Record.field">field</a></code></li>
<li><code><a title="control.record.Record.getDelPerm" href="#control.record.Record.getDelPerm">getDelPerm</a></code></li>
<li><code><a title="control.record.Record.getDependencies" href="#control.record.Record.getDependencies">getDependencies</a></code></li>
<li><code><a title="control.record.Record.inheritProps" href="#control.record.Record.inheritProps">inheritProps</a></code></li>
<li><code><a title="control.record.Record.reload" href="#control.record.Record.reload">reload</a></code></li>
<li><code><a title="control.record.Record.setPerm" href="#control.record.Record.setPerm">setPerm</a></code></li>
<li><code><a title="control.record.Record.setWorkflow" href="#control.record.Record.setWorkflow">setWorkflow</a></code></li>
<li><code><a title="control.record.Record.title" href="#control.record.Record.title">title</a></code></li>
<li><code><a title="control.record.Record.titleRaw" href="#control.record.Record.titleRaw">titleRaw</a></code></li>
<li><code><a title="control.record.Record.wrap" href="#control.record.Record.wrap">wrap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>