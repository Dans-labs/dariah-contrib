<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>control.workflow.apply API documentation</title>
<meta name="description" content="Applying workflow â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.workflow.apply</code></h1>
</header>
<section id="section-intro">
<p>Applying workflow</p>
<ul>
<li>Compute workflow permissions</li>
<li>Show workflow state</li>
<li>Perform workflow commands</li>
<li>Enforce workflow constraints</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Applying workflow

*   Compute workflow permissions
*   Show workflow state
*   Perform workflow commands
*   Enforce workflow constraints
&#34;&#34;&#34;

from datetime import timedelta
from flask import flash

from config import Config as C, Names as N
from control.utils import pick as G, E, now
from control.html import HtmlElements as H
from control.typ.datetime import Datetime
from control.cust.score import presentScore
from control.cust.factory_table import make as mkTable


CT = C.tables
CF = C.workflow

USER_TABLES_LIST = CT.userTables
USER_TABLES = set(USER_TABLES_LIST)

STAGE_ATTS = CF.stageAtts
COMMANDS = CF.commands
COMMAND_FIELDS = CF.commandFields
STATUS_REP = CF.statusRep
DECISION_DELAY = CF.decisionDelay

datetime = Datetime()


class WorkflowItem:
    &#34;&#34;&#34;Supports the application of workflow information.

    A WorkflowItem singleton has a bunch of workflow attributes as dict in its
    attribute `data` and offers methods to

    *   address selected pieces of that information;
    *   compute permissions for workflow actions and database actions;
    *   determine the workflow stage (see workflow.yaml) the contribution is in.

    Attributes
    ----------
    data: dict
        All workflow attributes.
    myKind: string
        The kind of reviewer the current user is, if any.
    &#34;&#34;&#34;

    def __init__(self, context, data):
        &#34;&#34;&#34;## Initialization

        Wraps a workflow item record around a workflow data record.

        Workflow item records are created per contribution,
        but they will be referenced by contribution, assessment and review records
        in their attribute `wfitem`.

        Workflow items also store details of the current user, which will be needed
        for the computation of permissions.

        !!! note
            The user attributes `uid` and `eppn` will be stored in this `WorkflowItem`
            object.
            At this point, it is also possible to what kind of reviewer the current
            user is, if any, and store that in attribute `myKind`.

        Parameters
        ----------
        context: object
            The `control.context.Context singleton`, from which the
            `control.auth.Auth` singleton can be picked up, from which the
            details of the current user can be read off.
        data: dict
            See below.
        &#34;&#34;&#34;

        auth = context.auth
        user = auth.user

        self.auth = auth
        &#34;&#34;&#34;*object* The `control.auth.Auth` singleton

        Provides methods to access the attributes of the current user.
        &#34;&#34;&#34;

        self.uid = G(user, N._id)
        &#34;&#34;&#34;*ObjectId* The id of the current user.
        &#34;&#34;&#34;

        self.eppn = G(user, N.eppn)
        &#34;&#34;&#34;*ObjectId* The eppn of the current user.

        !!! hint
            The eppn is the user identifying attribute from the identity provider.
        &#34;&#34;&#34;

        self.data = data
        &#34;&#34;&#34;*dict* The  workflow attributes.
        &#34;&#34;&#34;

        self.myKind = self.myReviewerKind()
        &#34;&#34;&#34;*dict* The kind of reviewer that the current user is.

        A user is `expert` reviewer or `final` reviewer, or `None`.
        &#34;&#34;&#34;

    def getKind(self, table, record):
        &#34;&#34;&#34;Determine whether a review(Entry) is `expert` or `final`.

        !!! warning
            The value `None` (not a string!) is returned for reviews that are
            no (longer) part of the workflow.
            They could be reviews with a type that does not match the type
            of the contribution, or reviews that have been superseded by newer
            reviews.

        Parameters
        ----------
        table: string
            Either `review` or `reviewEntry`.
        record: dict
            Either a `review` record or a `reviewEntry` record.

        Returns
        -------
        string {`expert`, `final`}
            Or `None`.
        &#34;&#34;&#34;

        if table in {N.review, N.reviewEntry}:
            eid = G(record, N._id) if table == N.review else G(record, N.review)
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            kind = (
                N.expert
                if G(G(reviews, N.expert), N._id) == eid
                else N.final
                if G(G(reviews, N.final), N._id) == eid
                else None
            )
        else:
            kind = None
        return kind

    def isValid(self, table, eid, record):
        &#34;&#34;&#34;Is a record a valid part of the workflow?

        Valid parts are contributions, assessment and review detail records of
        contributions satisfying:

        *   they have the same type as their master contribution
        *   they are not superseded by other assessments or reviews
            with the correct type

        Parameters
        ----------
        table: string {`review`, `assessment`, `criteriaEntry`, `reviewEntry`}.
        eid: ObjectId
            (Entity) id of the record to be validated.
        record: dict
            The full record to be validated.
            Only needed for `reviewEntry` and `criteriaEntry` in order to look
            up the master `review` or `assessment` record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        if eid is None:
            return False

        refId = (
            G(record, N.assessment)
            if table == N.criteriaEntry
            else G(record, N.review)
            if table == N.reviewEntry
            else eid
        )
        if refId is None:
            return False

        if table in {N.contrib, N.assessment, N.criteriaEntry}:
            data = self.getWf(table)
            return refId == G(data, N._id)
        elif table in {N.review, N.reviewEntry}:
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            return refId in {
                G(reviewInfo, N._id) for (kind, reviewInfo) in reviews.items()
            }

    def info(self, table, *atts, kind=None):
        &#34;&#34;&#34;Retrieve selected attributes of the workflow

        A workflow record contains attributes at the outermost level,
        but also within its enclosed assessment workflow record and
        the enclosed review workflow records.

        Parameters
        ----------
        table: string
            In order to read attributes, we must specify the source of those
            attributes: `contrib` (outermost), `assessment` or `review`.
        *atts: iterable
            The workflow attribute names to fetch.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        generator
            Yields attribute values, corresponding to `*atts`.
        &#34;&#34;&#34;

        thisData = self.getWf(table, kind=kind)
        return (G(thisData, att) for att in atts)

    def checkFixed(self, recordObj, field=None):
        &#34;&#34;&#34;Whether a record or field is fixed because of workflow.

        When a contribution, assessment, review is in a certain stage
        in the workflow, its record or some fields in its record may be
        fixated, either temporarily or permanently.

        This method checks whether a record or field is currently fixed,
        i.e. whether editing is possible.

        !!! note
            It might also depend on the current user.

        Parameters
        ----------
        recordObj: object
            The record in question (from which the table and the kind
            maybe inferred. It should be the record that contains this
            WorkflowItem object as its `wfitem` attribute.
        field: string, optional `None`
            If None, we check for the fixity of the record as a whole.
            Otherwise, we check for the fixity of this field in the record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        auth = self.auth
        table = recordObj.table
        kind = recordObj.kind

        (frozen, done, locked) = self.info(table, N.frozen, N.done, N.locked, kind=kind)

        if field is None:
            return frozen or done or locked

        if frozen or done:
            return True

        if not locked:
            return False

        isOffice = auth.officeuser()
        if isOffice and table == N.assessment:
            return field not in {N.reviewerE, N.reviewerF}

        return True

    def permission(self, table, command, kind=None):
        &#34;&#34;&#34;Checks whether a workflow command is permitted.

        Note that the commands are listed per kind of record they apply to:
        contrib, assessment, review.
        They are typically triggered by big workflow buttons on the interface.

        When the request to execute such a command reachees the server, it will
        check whether the current user is allowed to execute this command
        on the records in question.

        !!! hint
            Workflow commands are listed in workflow.yaml, under `commands`.

        !!! note
            If you try to run a command on a kind of record that it is not
            designed for, it will be detected and no permission will be given.

        Parameters
        ----------
        table: string
            In order to check permissions, we must specify the kind of record that
            the command acts on: contrib, assessment, or review.
        command: string
            An string consisting of the name of a command as listed in
            workflow.yaml under `commands`.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        auth = self.auth
        uid = self.uid

        allowedCommands = G(COMMANDS, table, default={})
        if command not in allowedCommands:
            return False

        if uid is None or table not in USER_TABLES:
            return False

        myKind = self.myKind

        (
            locked,
            done,
            frozen,
            mayAdd,
            stage,
            stageDate,
            creators,
            countryId,
        ) = self.info(
            table,
            N.locked,
            N.done,
            N.frozen,
            N.mayAdd,
            N.stage,
            N.stageDate,
            N.creators,
            N.country,
            kind=kind,
        )

        (contribId,) = self.info(N.contrib, N._id)

        isCoord = countryId and auth.coordinator(countryId=countryId)
        isSuper = auth.superuser()

        commandInfo = allowedCommands[command]
        decisionDelay = G(commandInfo, N.delay)
        if decisionDelay:
            decisionDelay = timedelta(hours=decisionDelay)

        justNow = now()
        remaining = False
        if decisionDelay and stageDate:
            remaining = stageDate + decisionDelay - justNow
            if remaining &lt;= timedelta(hours=0):
                remaining = False

        if frozen and not remaining:
            return False

        if table == N.contrib:
            if uid not in creators and not isCoord and not isSuper:
                return False

            if command == N.startAssessment:
                return mayAdd and not frozen and not done

            if not isCoord:
                return False

            answer = not frozen or remaining

            if command == N.selectContrib:
                return stage != N.selectYes and answer

            if command == N.deselectContrib:
                return stage != N.selectNo and answer

            if command == N.unselectContrib:
                return stage != N.selectNone and answer

            return False

        if frozen or done:
            return False

        if table == N.assessment:
            if command == N.startReview:
                return G(mayAdd, myKind)

            if uid not in creators:
                return False

            answer = not locked or remaining
            if not answer:
                return False

            if command == N.submitAssessment:
                return stage == N.complete

            if command == N.resubmitAssessment:
                return stage == N.completeWithdrawn

            if command == N.submitRevised:
                return stage == N.completeRevised

            if command == N.withdrawAssessment:
                return stage in {N.submitted, N.submittedRevised} and stage not in {
                    N.incompleteWithdrawn,
                    N.completeWithdrawn,
                }

            return False

        if table == N.review:
            commandInfo = G(allowedCommands, command)
            commandKind = G(commandInfo, N.kind)
            if not kind or kind != commandKind or kind != myKind:
                return False

            answer = not locked or remaining
            if not answer:
                return False

            if command in {
                N.expertReviewRevise,
                N.expertReviewAccept,
                N.expertReviewReject,
            }:
                return kind == N.expert

            if command in {
                N.finalReviewRevise,
                N.finalReviewAccept,
                N.finalReviewReject,
            }:
                (expertStage,) = self.info(table, N.stage, kind=N.expert)
                return kind == N.final and not not expertStage

            return False

        return False

    def stage(self, table, kind=None):
        &#34;&#34;&#34;Find the workflow stage that a record is in.

        Workflow stages are listed in workflow.yaml, under `stageAtts`.

        The stage of a record is stored in the workflow attribute `stage`,
        so the only thing needed is to ask for that attribute with
        `control.workflow.apply.WorkflowItem.info`.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string {`selectYes`, `submittedRevised`, `reviewAccept`, ...}
            See workflow.yaml for the complete list.
        &#34;&#34;&#34;

        return list(self.info(table, N.stage, kind=kind))[0]

    def status(self, table, kind=None):
        &#34;&#34;&#34;Present all workflow info and controls relevant to the record.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the status:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        eid = list(self.info(table, N._id, kind=kind))[0]
        itemKey = f&#34;&#34;&#34;{table}/{eid}&#34;&#34;&#34;
        rButton = H.iconr(itemKey, &#34;#workflow&#34;, msg=N.status)

        return H.div(
            [
                rButton,
                self.statusOverview(table, kind=kind),
                self.commands(table, kind=kind),
            ],
            cls=f&#34;workflow&#34;,
        )

    @staticmethod
    def isCommand(table, field):
        &#34;&#34;&#34;Whether a field in a record is involved in a workflow command.

        Fields that are involved in workflow commands can not be read or edited
        directly:

        *   they are represented as workflow status, not as a value
            (see `control.workflow.apply.WorkflowItem.status`);
        *   they only change as a result of a  workflow command
            (see `control.workflow.apply.WorkflowItem.doCommand`).

        !!! hint
            Workflow commands are listed in workflow.yaml, under `commands`.

        !!! caution
            If a record is not a valid part of a workflow, then all its fields
            are represented and actionable in the normal way.

        Parameters
        ----------
        table: string
            The table in question.
        field: string
            The field in question.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        commandFields = G(COMMAND_FIELDS, table, default=set())
        return field in commandFields

    def doCommand(self, command, recordObj):
        &#34;&#34;&#34;Execute a workflow command on a record.

        The permission to execute the command will be checked first.

        !!! hint
            Workflow commands are listed in workflow.yaml, under `commands`.

        Parameters
        ----------
        recordObj: object
            The record must be passed as a record object.

        Returns
        -------
        url | `None`
            To navigate to after the action has been performed.
            If the action has not been performed, `None` is returned.
        &#34;&#34;&#34;

        context = recordObj.context
        table = recordObj.table
        eid = recordObj.eid
        kind = recordObj.kind
        commands = G(COMMANDS, table)
        (contribId,) = self.info(N.contrib, N._id)
        commandInfo = commands[command]
        acro = G(commandInfo, N.acro)

        urlExtra = E

        done = False
        if self.permission(table, command, kind=kind):
            operator = G(commandInfo, N.operator)
            if operator == N.add:
                oTable = G(commandInfo, N.table)
                tableObj = mkTable(context, oTable)
                oeid = tableObj.insert(masterTable=table, masterId=eid, force=True) or E
                if oeid:
                    urlExtra = f&#34;&#34;&#34;/{N.open}/{oTable}/{oeid}&#34;&#34;&#34;
                    done = True
            elif operator == N.set:
                field = G(commandInfo, N.field)
                value = G(commandInfo, N.value)
                if recordObj.field(field, mayEdit=True).save(value):
                    done = True
            if done:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; done&#34;&#34;&#34;, &#34;message&#34;)
            else:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; failed&#34;&#34;&#34;, &#34;error&#34;)
        else:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; not permitted&#34;&#34;&#34;, &#34;error&#34;)

        return f&#34;&#34;&#34;/{N.contrib}/{N.item}/{contribId}{urlExtra}&#34;&#34;&#34; if done else None

    def statusOverview(self, table, kind=None):
        &#34;&#34;&#34;Present the current status of a record on the interface.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to present the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        (stage, stageDate, locked, done, frozen, score, eid) = self.info(
            table,
            N.stage,
            N.stageDate,
            N.locked,
            N.done,
            N.frozen,
            N.score,
            N._id,
            kind=kind,
        )
        stageInfo = G(STAGE_ATTS, stage)
        statusCls = G(stageInfo, N.cls)
        stageOn = (
            H.span(f&#34;&#34;&#34; on {datetime.toDisplay(stageDate)}&#34;&#34;&#34;, cls=&#34;date&#34;)
            if stageDate
            else E
        )
        statusMsg = H.span(
            [G(stageInfo, N.msg) or E, stageOn], cls=f&#34;large status {statusCls}&#34;
        )
        lockedCls = N.locked if locked else E
        lockedMsg = (
            H.span(G(STATUS_REP, N.locked), cls=f&#34;large status {lockedCls}&#34;)
            if locked
            else E
        )
        doneCls = N.done if done else E
        doneMsg = (
            H.span(G(STATUS_REP, N.done), cls=f&#34;large status {doneCls}&#34;) if done else E
        )
        frozenCls = N.frozen if frozen else E
        frozenMsg = (
            H.span(G(STATUS_REP, N.frozen), cls=f&#34;large status info&#34;) if frozen else E
        )

        statusRep = H.div([statusMsg, lockedMsg, doneMsg, frozenMsg], cls=frozenCls)

        scorePart = E
        if table == N.assessment:
            scoreParts = presentScore(score, table, eid)
            scorePart = (
                H.span(scoreParts)
                if table == N.assessment
                else (scoreParts[0] if scoreParts else E)
                if table == N.contrib
                else E
            )

        return H.div([statusRep, scorePart], cls=&#34;workflow-line&#34;)

    def commands(self, table, kind=None):
        &#34;&#34;&#34;Present the currently available commands as buttons on the interface.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to present the
            commands: contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        uid = self.uid

        if not uid or table not in USER_TABLES:
            return E

        eid = list(self.info(table, N._id, kind=kind))[0]
        commandParts = []

        allowedCommands = G(COMMANDS, table, default={})
        justNow = now()

        for (command, commandInfo) in sorted(allowedCommands.items()):
            permitted = self.permission(table, command, kind=kind)
            if not permitted:
                continue

            remaining = type(permitted) is timedelta and permitted
            commandUntil = E
            if remaining:
                remainingRep = datetime.toDisplay(justNow + remaining)
                commandUntil = H.span(f&#34;&#34;&#34; before {remainingRep}&#34;&#34;&#34;, cls=&#34;datex&#34;)
            commandMsg = G(commandInfo, N.msg)
            commandCls = G(commandInfo, N.cls)

            commandPart = H.a(
                [commandMsg, commandUntil],
                f&#34;&#34;&#34;/api/command/{command}/{table}/{eid}&#34;&#34;&#34;,
                cls=f&#34;large command {commandCls}&#34;,
            )
            commandParts.append(commandPart)

        return H.join(commandParts)

    def getWf(self, table, kind=None):
        &#34;&#34;&#34;Select a source of attributes within a workflow item.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want the attributes:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        dict
        &#34;&#34;&#34;

        data = self.data
        if table == N.contrib:
            return data

        data = G(data, N.assessment)
        if table in {N.assessment, N.criteriaEntry}:
            return data

        if table in {N.review, N.reviewEntry}:
            data = G(G(data, N.reviews), kind)
            return data

        return None

    def myReviewerKind(self, reviewer=None):
        &#34;&#34;&#34;Determine whether the current user is `expert` or `final`.

        Parameters
        ----------
        reviewer: dict, optional `None`
            If absent, the assessment in the workflow info will be inspected
            to get a dict of its reviewers by kind.
            Otherwise, it should be a dict of user ids keyed by `expert` and
            `final`.

        Returns
        -------
        string {`expert`, `final`} | `None`
            Depending on whether the current user is such a reviewer of the
            assessment of this contribution. Or `None` if (s)he is not a reviewer
            at all.
        &#34;&#34;&#34;
        uid = self.uid

        if reviewer is None:
            reviewer = G(self.getWf(N.assessment), N.reviewer)

        return (
            N.expert
            if G(reviewer, N.expert) == uid
            else N.final
            if G(reviewer, N.final) == uid
            else None
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.workflow.apply.WorkflowItem"><code class="flex name class">
<span>class <span class="ident">WorkflowItem</span></span>
<span>(</span><span>context, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Supports the application of workflow information.</p>
<p>A WorkflowItem singleton has a bunch of workflow attributes as dict in its
attribute <code>data</code> and offers methods to</p>
<ul>
<li>address selected pieces of that information;</li>
<li>compute permissions for workflow actions and database actions;</li>
<li>determine the workflow stage (see workflow.yaml) the contribution is in.</li>
</ul>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>All workflow attributes.</dd>
<dt><strong><code>myKind</code></strong> :&ensp;<code>string</code></dt>
<dd>The kind of reviewer the current user is, if any.</dd>
</dl>
<h2 id="initialization">Initialization</h2>
<p>Wraps a workflow item record around a workflow data record.</p>
<p>Workflow item records are created per contribution,
but they will be referenced by contribution, assessment and review records
in their attribute <code>wfitem</code>.</p>
<p>Workflow items also store details of the current user, which will be needed
for the computation of permissions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The user attributes <code>uid</code> and <code>eppn</code> will be stored in this <a title="control.workflow.apply.WorkflowItem" href="#control.workflow.apply.WorkflowItem"><code>WorkflowItem</code></a>
object.
At this point, it is also possible to what kind of reviewer the current
user is, if any, and store that in attribute <code>myKind</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>object</code></dt>
<dd>The <code>control.context.Context singleton</code>, from which the
<a title="control.auth.Auth" href="../auth.html#control.auth.Auth"><code>Auth</code></a> singleton can be picked up, from which the
details of the current user can be read off.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>See below.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkflowItem:
    &#34;&#34;&#34;Supports the application of workflow information.

    A WorkflowItem singleton has a bunch of workflow attributes as dict in its
    attribute `data` and offers methods to

    *   address selected pieces of that information;
    *   compute permissions for workflow actions and database actions;
    *   determine the workflow stage (see workflow.yaml) the contribution is in.

    Attributes
    ----------
    data: dict
        All workflow attributes.
    myKind: string
        The kind of reviewer the current user is, if any.
    &#34;&#34;&#34;

    def __init__(self, context, data):
        &#34;&#34;&#34;## Initialization

        Wraps a workflow item record around a workflow data record.

        Workflow item records are created per contribution,
        but they will be referenced by contribution, assessment and review records
        in their attribute `wfitem`.

        Workflow items also store details of the current user, which will be needed
        for the computation of permissions.

        !!! note
            The user attributes `uid` and `eppn` will be stored in this `WorkflowItem`
            object.
            At this point, it is also possible to what kind of reviewer the current
            user is, if any, and store that in attribute `myKind`.

        Parameters
        ----------
        context: object
            The `control.context.Context singleton`, from which the
            `control.auth.Auth` singleton can be picked up, from which the
            details of the current user can be read off.
        data: dict
            See below.
        &#34;&#34;&#34;

        auth = context.auth
        user = auth.user

        self.auth = auth
        &#34;&#34;&#34;*object* The `control.auth.Auth` singleton

        Provides methods to access the attributes of the current user.
        &#34;&#34;&#34;

        self.uid = G(user, N._id)
        &#34;&#34;&#34;*ObjectId* The id of the current user.
        &#34;&#34;&#34;

        self.eppn = G(user, N.eppn)
        &#34;&#34;&#34;*ObjectId* The eppn of the current user.

        !!! hint
            The eppn is the user identifying attribute from the identity provider.
        &#34;&#34;&#34;

        self.data = data
        &#34;&#34;&#34;*dict* The  workflow attributes.
        &#34;&#34;&#34;

        self.myKind = self.myReviewerKind()
        &#34;&#34;&#34;*dict* The kind of reviewer that the current user is.

        A user is `expert` reviewer or `final` reviewer, or `None`.
        &#34;&#34;&#34;

    def getKind(self, table, record):
        &#34;&#34;&#34;Determine whether a review(Entry) is `expert` or `final`.

        !!! warning
            The value `None` (not a string!) is returned for reviews that are
            no (longer) part of the workflow.
            They could be reviews with a type that does not match the type
            of the contribution, or reviews that have been superseded by newer
            reviews.

        Parameters
        ----------
        table: string
            Either `review` or `reviewEntry`.
        record: dict
            Either a `review` record or a `reviewEntry` record.

        Returns
        -------
        string {`expert`, `final`}
            Or `None`.
        &#34;&#34;&#34;

        if table in {N.review, N.reviewEntry}:
            eid = G(record, N._id) if table == N.review else G(record, N.review)
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            kind = (
                N.expert
                if G(G(reviews, N.expert), N._id) == eid
                else N.final
                if G(G(reviews, N.final), N._id) == eid
                else None
            )
        else:
            kind = None
        return kind

    def isValid(self, table, eid, record):
        &#34;&#34;&#34;Is a record a valid part of the workflow?

        Valid parts are contributions, assessment and review detail records of
        contributions satisfying:

        *   they have the same type as their master contribution
        *   they are not superseded by other assessments or reviews
            with the correct type

        Parameters
        ----------
        table: string {`review`, `assessment`, `criteriaEntry`, `reviewEntry`}.
        eid: ObjectId
            (Entity) id of the record to be validated.
        record: dict
            The full record to be validated.
            Only needed for `reviewEntry` and `criteriaEntry` in order to look
            up the master `review` or `assessment` record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        if eid is None:
            return False

        refId = (
            G(record, N.assessment)
            if table == N.criteriaEntry
            else G(record, N.review)
            if table == N.reviewEntry
            else eid
        )
        if refId is None:
            return False

        if table in {N.contrib, N.assessment, N.criteriaEntry}:
            data = self.getWf(table)
            return refId == G(data, N._id)
        elif table in {N.review, N.reviewEntry}:
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            return refId in {
                G(reviewInfo, N._id) for (kind, reviewInfo) in reviews.items()
            }

    def info(self, table, *atts, kind=None):
        &#34;&#34;&#34;Retrieve selected attributes of the workflow

        A workflow record contains attributes at the outermost level,
        but also within its enclosed assessment workflow record and
        the enclosed review workflow records.

        Parameters
        ----------
        table: string
            In order to read attributes, we must specify the source of those
            attributes: `contrib` (outermost), `assessment` or `review`.
        *atts: iterable
            The workflow attribute names to fetch.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        generator
            Yields attribute values, corresponding to `*atts`.
        &#34;&#34;&#34;

        thisData = self.getWf(table, kind=kind)
        return (G(thisData, att) for att in atts)

    def checkFixed(self, recordObj, field=None):
        &#34;&#34;&#34;Whether a record or field is fixed because of workflow.

        When a contribution, assessment, review is in a certain stage
        in the workflow, its record or some fields in its record may be
        fixated, either temporarily or permanently.

        This method checks whether a record or field is currently fixed,
        i.e. whether editing is possible.

        !!! note
            It might also depend on the current user.

        Parameters
        ----------
        recordObj: object
            The record in question (from which the table and the kind
            maybe inferred. It should be the record that contains this
            WorkflowItem object as its `wfitem` attribute.
        field: string, optional `None`
            If None, we check for the fixity of the record as a whole.
            Otherwise, we check for the fixity of this field in the record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        auth = self.auth
        table = recordObj.table
        kind = recordObj.kind

        (frozen, done, locked) = self.info(table, N.frozen, N.done, N.locked, kind=kind)

        if field is None:
            return frozen or done or locked

        if frozen or done:
            return True

        if not locked:
            return False

        isOffice = auth.officeuser()
        if isOffice and table == N.assessment:
            return field not in {N.reviewerE, N.reviewerF}

        return True

    def permission(self, table, command, kind=None):
        &#34;&#34;&#34;Checks whether a workflow command is permitted.

        Note that the commands are listed per kind of record they apply to:
        contrib, assessment, review.
        They are typically triggered by big workflow buttons on the interface.

        When the request to execute such a command reachees the server, it will
        check whether the current user is allowed to execute this command
        on the records in question.

        !!! hint
            Workflow commands are listed in workflow.yaml, under `commands`.

        !!! note
            If you try to run a command on a kind of record that it is not
            designed for, it will be detected and no permission will be given.

        Parameters
        ----------
        table: string
            In order to check permissions, we must specify the kind of record that
            the command acts on: contrib, assessment, or review.
        command: string
            An string consisting of the name of a command as listed in
            workflow.yaml under `commands`.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        auth = self.auth
        uid = self.uid

        allowedCommands = G(COMMANDS, table, default={})
        if command not in allowedCommands:
            return False

        if uid is None or table not in USER_TABLES:
            return False

        myKind = self.myKind

        (
            locked,
            done,
            frozen,
            mayAdd,
            stage,
            stageDate,
            creators,
            countryId,
        ) = self.info(
            table,
            N.locked,
            N.done,
            N.frozen,
            N.mayAdd,
            N.stage,
            N.stageDate,
            N.creators,
            N.country,
            kind=kind,
        )

        (contribId,) = self.info(N.contrib, N._id)

        isCoord = countryId and auth.coordinator(countryId=countryId)
        isSuper = auth.superuser()

        commandInfo = allowedCommands[command]
        decisionDelay = G(commandInfo, N.delay)
        if decisionDelay:
            decisionDelay = timedelta(hours=decisionDelay)

        justNow = now()
        remaining = False
        if decisionDelay and stageDate:
            remaining = stageDate + decisionDelay - justNow
            if remaining &lt;= timedelta(hours=0):
                remaining = False

        if frozen and not remaining:
            return False

        if table == N.contrib:
            if uid not in creators and not isCoord and not isSuper:
                return False

            if command == N.startAssessment:
                return mayAdd and not frozen and not done

            if not isCoord:
                return False

            answer = not frozen or remaining

            if command == N.selectContrib:
                return stage != N.selectYes and answer

            if command == N.deselectContrib:
                return stage != N.selectNo and answer

            if command == N.unselectContrib:
                return stage != N.selectNone and answer

            return False

        if frozen or done:
            return False

        if table == N.assessment:
            if command == N.startReview:
                return G(mayAdd, myKind)

            if uid not in creators:
                return False

            answer = not locked or remaining
            if not answer:
                return False

            if command == N.submitAssessment:
                return stage == N.complete

            if command == N.resubmitAssessment:
                return stage == N.completeWithdrawn

            if command == N.submitRevised:
                return stage == N.completeRevised

            if command == N.withdrawAssessment:
                return stage in {N.submitted, N.submittedRevised} and stage not in {
                    N.incompleteWithdrawn,
                    N.completeWithdrawn,
                }

            return False

        if table == N.review:
            commandInfo = G(allowedCommands, command)
            commandKind = G(commandInfo, N.kind)
            if not kind or kind != commandKind or kind != myKind:
                return False

            answer = not locked or remaining
            if not answer:
                return False

            if command in {
                N.expertReviewRevise,
                N.expertReviewAccept,
                N.expertReviewReject,
            }:
                return kind == N.expert

            if command in {
                N.finalReviewRevise,
                N.finalReviewAccept,
                N.finalReviewReject,
            }:
                (expertStage,) = self.info(table, N.stage, kind=N.expert)
                return kind == N.final and not not expertStage

            return False

        return False

    def stage(self, table, kind=None):
        &#34;&#34;&#34;Find the workflow stage that a record is in.

        Workflow stages are listed in workflow.yaml, under `stageAtts`.

        The stage of a record is stored in the workflow attribute `stage`,
        so the only thing needed is to ask for that attribute with
        `control.workflow.apply.WorkflowItem.info`.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string {`selectYes`, `submittedRevised`, `reviewAccept`, ...}
            See workflow.yaml for the complete list.
        &#34;&#34;&#34;

        return list(self.info(table, N.stage, kind=kind))[0]

    def status(self, table, kind=None):
        &#34;&#34;&#34;Present all workflow info and controls relevant to the record.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the status:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        eid = list(self.info(table, N._id, kind=kind))[0]
        itemKey = f&#34;&#34;&#34;{table}/{eid}&#34;&#34;&#34;
        rButton = H.iconr(itemKey, &#34;#workflow&#34;, msg=N.status)

        return H.div(
            [
                rButton,
                self.statusOverview(table, kind=kind),
                self.commands(table, kind=kind),
            ],
            cls=f&#34;workflow&#34;,
        )

    @staticmethod
    def isCommand(table, field):
        &#34;&#34;&#34;Whether a field in a record is involved in a workflow command.

        Fields that are involved in workflow commands can not be read or edited
        directly:

        *   they are represented as workflow status, not as a value
            (see `control.workflow.apply.WorkflowItem.status`);
        *   they only change as a result of a  workflow command
            (see `control.workflow.apply.WorkflowItem.doCommand`).

        !!! hint
            Workflow commands are listed in workflow.yaml, under `commands`.

        !!! caution
            If a record is not a valid part of a workflow, then all its fields
            are represented and actionable in the normal way.

        Parameters
        ----------
        table: string
            The table in question.
        field: string
            The field in question.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        commandFields = G(COMMAND_FIELDS, table, default=set())
        return field in commandFields

    def doCommand(self, command, recordObj):
        &#34;&#34;&#34;Execute a workflow command on a record.

        The permission to execute the command will be checked first.

        !!! hint
            Workflow commands are listed in workflow.yaml, under `commands`.

        Parameters
        ----------
        recordObj: object
            The record must be passed as a record object.

        Returns
        -------
        url | `None`
            To navigate to after the action has been performed.
            If the action has not been performed, `None` is returned.
        &#34;&#34;&#34;

        context = recordObj.context
        table = recordObj.table
        eid = recordObj.eid
        kind = recordObj.kind
        commands = G(COMMANDS, table)
        (contribId,) = self.info(N.contrib, N._id)
        commandInfo = commands[command]
        acro = G(commandInfo, N.acro)

        urlExtra = E

        done = False
        if self.permission(table, command, kind=kind):
            operator = G(commandInfo, N.operator)
            if operator == N.add:
                oTable = G(commandInfo, N.table)
                tableObj = mkTable(context, oTable)
                oeid = tableObj.insert(masterTable=table, masterId=eid, force=True) or E
                if oeid:
                    urlExtra = f&#34;&#34;&#34;/{N.open}/{oTable}/{oeid}&#34;&#34;&#34;
                    done = True
            elif operator == N.set:
                field = G(commandInfo, N.field)
                value = G(commandInfo, N.value)
                if recordObj.field(field, mayEdit=True).save(value):
                    done = True
            if done:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; done&#34;&#34;&#34;, &#34;message&#34;)
            else:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; failed&#34;&#34;&#34;, &#34;error&#34;)
        else:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; not permitted&#34;&#34;&#34;, &#34;error&#34;)

        return f&#34;&#34;&#34;/{N.contrib}/{N.item}/{contribId}{urlExtra}&#34;&#34;&#34; if done else None

    def statusOverview(self, table, kind=None):
        &#34;&#34;&#34;Present the current status of a record on the interface.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to present the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        (stage, stageDate, locked, done, frozen, score, eid) = self.info(
            table,
            N.stage,
            N.stageDate,
            N.locked,
            N.done,
            N.frozen,
            N.score,
            N._id,
            kind=kind,
        )
        stageInfo = G(STAGE_ATTS, stage)
        statusCls = G(stageInfo, N.cls)
        stageOn = (
            H.span(f&#34;&#34;&#34; on {datetime.toDisplay(stageDate)}&#34;&#34;&#34;, cls=&#34;date&#34;)
            if stageDate
            else E
        )
        statusMsg = H.span(
            [G(stageInfo, N.msg) or E, stageOn], cls=f&#34;large status {statusCls}&#34;
        )
        lockedCls = N.locked if locked else E
        lockedMsg = (
            H.span(G(STATUS_REP, N.locked), cls=f&#34;large status {lockedCls}&#34;)
            if locked
            else E
        )
        doneCls = N.done if done else E
        doneMsg = (
            H.span(G(STATUS_REP, N.done), cls=f&#34;large status {doneCls}&#34;) if done else E
        )
        frozenCls = N.frozen if frozen else E
        frozenMsg = (
            H.span(G(STATUS_REP, N.frozen), cls=f&#34;large status info&#34;) if frozen else E
        )

        statusRep = H.div([statusMsg, lockedMsg, doneMsg, frozenMsg], cls=frozenCls)

        scorePart = E
        if table == N.assessment:
            scoreParts = presentScore(score, table, eid)
            scorePart = (
                H.span(scoreParts)
                if table == N.assessment
                else (scoreParts[0] if scoreParts else E)
                if table == N.contrib
                else E
            )

        return H.div([statusRep, scorePart], cls=&#34;workflow-line&#34;)

    def commands(self, table, kind=None):
        &#34;&#34;&#34;Present the currently available commands as buttons on the interface.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to present the
            commands: contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        uid = self.uid

        if not uid or table not in USER_TABLES:
            return E

        eid = list(self.info(table, N._id, kind=kind))[0]
        commandParts = []

        allowedCommands = G(COMMANDS, table, default={})
        justNow = now()

        for (command, commandInfo) in sorted(allowedCommands.items()):
            permitted = self.permission(table, command, kind=kind)
            if not permitted:
                continue

            remaining = type(permitted) is timedelta and permitted
            commandUntil = E
            if remaining:
                remainingRep = datetime.toDisplay(justNow + remaining)
                commandUntil = H.span(f&#34;&#34;&#34; before {remainingRep}&#34;&#34;&#34;, cls=&#34;datex&#34;)
            commandMsg = G(commandInfo, N.msg)
            commandCls = G(commandInfo, N.cls)

            commandPart = H.a(
                [commandMsg, commandUntil],
                f&#34;&#34;&#34;/api/command/{command}/{table}/{eid}&#34;&#34;&#34;,
                cls=f&#34;large command {commandCls}&#34;,
            )
            commandParts.append(commandPart)

        return H.join(commandParts)

    def getWf(self, table, kind=None):
        &#34;&#34;&#34;Select a source of attributes within a workflow item.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want the attributes:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        dict
        &#34;&#34;&#34;

        data = self.data
        if table == N.contrib:
            return data

        data = G(data, N.assessment)
        if table in {N.assessment, N.criteriaEntry}:
            return data

        if table in {N.review, N.reviewEntry}:
            data = G(G(data, N.reviews), kind)
            return data

        return None

    def myReviewerKind(self, reviewer=None):
        &#34;&#34;&#34;Determine whether the current user is `expert` or `final`.

        Parameters
        ----------
        reviewer: dict, optional `None`
            If absent, the assessment in the workflow info will be inspected
            to get a dict of its reviewers by kind.
            Otherwise, it should be a dict of user ids keyed by `expert` and
            `final`.

        Returns
        -------
        string {`expert`, `final`} | `None`
            Depending on whether the current user is such a reviewer of the
            assessment of this contribution. Or `None` if (s)he is not a reviewer
            at all.
        &#34;&#34;&#34;
        uid = self.uid

        if reviewer is None:
            reviewer = G(self.getWf(N.assessment), N.reviewer)

        return (
            N.expert
            if G(reviewer, N.expert) == uid
            else N.final
            if G(reviewer, N.final) == uid
            else None
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="control.workflow.apply.WorkflowItem.isCommand"><code class="name flex">
<span>def <span class="ident">isCommand</span></span>(<span>table, field)</span>
</code></dt>
<dd>
<section class="desc"><p>Whether a field in a record is involved in a workflow command.</p>
<p>Fields that are involved in workflow commands can not be read or edited
directly:</p>
<ul>
<li>they are represented as workflow status, not as a value
(see <a title="control.workflow.apply.WorkflowItem.status" href="#control.workflow.apply.WorkflowItem.status"><code>WorkflowItem.status()</code></a>);</li>
<li>they only change as a result of a
workflow command
(see <a title="control.workflow.apply.WorkflowItem.doCommand" href="#control.workflow.apply.WorkflowItem.doCommand"><code>WorkflowItem.doCommand()</code></a>).</li>
</ul>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Workflow commands are listed in workflow.yaml, under <code>commands</code>.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>If a record is not a valid part of a workflow, then all its fields
are represented and actionable in the normal way.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table in question.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>The field in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isCommand(table, field):
    &#34;&#34;&#34;Whether a field in a record is involved in a workflow command.

    Fields that are involved in workflow commands can not be read or edited
    directly:

    *   they are represented as workflow status, not as a value
        (see `control.workflow.apply.WorkflowItem.status`);
    *   they only change as a result of a  workflow command
        (see `control.workflow.apply.WorkflowItem.doCommand`).

    !!! hint
        Workflow commands are listed in workflow.yaml, under `commands`.

    !!! caution
        If a record is not a valid part of a workflow, then all its fields
        are represented and actionable in the normal way.

    Parameters
    ----------
    table: string
        The table in question.
    field: string
        The field in question.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    commandFields = G(COMMAND_FIELDS, table, default=set())
    return field in commandFields</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="control.workflow.apply.WorkflowItem.auth"><code class="name">var <span class="ident">auth</span></code></dt>
<dd>
<section class="desc"><p><em>object</em> The <a title="control.auth.Auth" href="../auth.html#control.auth.Auth"><code>Auth</code></a> singleton</p>
<p>Provides methods to access the attributes of the current user.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"><p><em>dict</em> The
workflow attributes.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.eppn"><code class="name">var <span class="ident">eppn</span></code></dt>
<dd>
<section class="desc"><p><em>ObjectId</em> The eppn of the current user.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>The eppn is the user identifying attribute from the identity provider.</p>
</div></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.myKind"><code class="name">var <span class="ident">myKind</span></code></dt>
<dd>
<section class="desc"><p><em>dict</em> The kind of reviewer that the current user is.</p>
<p>A user is <code>expert</code> reviewer or <code>final</code> reviewer, or <code>None</code>.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.uid"><code class="name">var <span class="ident">uid</span></code></dt>
<dd>
<section class="desc"><p><em>ObjectId</em> The id of the current user.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.workflow.apply.WorkflowItem.checkFixed"><code class="name flex">
<span>def <span class="ident">checkFixed</span></span>(<span>self, recordObj, field=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Whether a record or field is fixed because of workflow.</p>
<p>When a contribution, assessment, review is in a certain stage
in the workflow, its record or some fields in its record may be
fixated, either temporarily or permanently.</p>
<p>This method checks whether a record or field is currently fixed,
i.e. whether editing is possible.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It might also depend on the current user.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recordObj</code></strong> :&ensp;<code>object</code></dt>
<dd>The record in question (from which the table and the kind
maybe inferred. It should be the record that contains this
WorkflowItem object as its <code>wfitem</code> attribute.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If None, we check for the fixity of the record as a whole.
Otherwise, we check for the fixity of this field in the record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkFixed(self, recordObj, field=None):
    &#34;&#34;&#34;Whether a record or field is fixed because of workflow.

    When a contribution, assessment, review is in a certain stage
    in the workflow, its record or some fields in its record may be
    fixated, either temporarily or permanently.

    This method checks whether a record or field is currently fixed,
    i.e. whether editing is possible.

    !!! note
        It might also depend on the current user.

    Parameters
    ----------
    recordObj: object
        The record in question (from which the table and the kind
        maybe inferred. It should be the record that contains this
        WorkflowItem object as its `wfitem` attribute.
    field: string, optional `None`
        If None, we check for the fixity of the record as a whole.
        Otherwise, we check for the fixity of this field in the record.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    auth = self.auth
    table = recordObj.table
    kind = recordObj.kind

    (frozen, done, locked) = self.info(table, N.frozen, N.done, N.locked, kind=kind)

    if field is None:
        return frozen or done or locked

    if frozen or done:
        return True

    if not locked:
        return False

    isOffice = auth.officeuser()
    if isOffice and table == N.assessment:
        return field not in {N.reviewerE, N.reviewerF}

    return True</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.commands"><code class="name flex">
<span>def <span class="ident">commands</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Present the currently available commands as buttons on the interface.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to present the
commands: contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code>(<code>html</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commands(self, table, kind=None):
    &#34;&#34;&#34;Present the currently available commands as buttons on the interface.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to present the
        commands: contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    uid = self.uid

    if not uid or table not in USER_TABLES:
        return E

    eid = list(self.info(table, N._id, kind=kind))[0]
    commandParts = []

    allowedCommands = G(COMMANDS, table, default={})
    justNow = now()

    for (command, commandInfo) in sorted(allowedCommands.items()):
        permitted = self.permission(table, command, kind=kind)
        if not permitted:
            continue

        remaining = type(permitted) is timedelta and permitted
        commandUntil = E
        if remaining:
            remainingRep = datetime.toDisplay(justNow + remaining)
            commandUntil = H.span(f&#34;&#34;&#34; before {remainingRep}&#34;&#34;&#34;, cls=&#34;datex&#34;)
        commandMsg = G(commandInfo, N.msg)
        commandCls = G(commandInfo, N.cls)

        commandPart = H.a(
            [commandMsg, commandUntil],
            f&#34;&#34;&#34;/api/command/{command}/{table}/{eid}&#34;&#34;&#34;,
            cls=f&#34;large command {commandCls}&#34;,
        )
        commandParts.append(commandPart)

    return H.join(commandParts)</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.doCommand"><code class="name flex">
<span>def <span class="ident">doCommand</span></span>(<span>self, command, recordObj)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute a workflow command on a record.</p>
<p>The permission to execute the command will be checked first.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Workflow commands are listed in workflow.yaml, under <code>commands</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recordObj</code></strong> :&ensp;<code>object</code></dt>
<dd>The record must be passed as a record object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>url | <code>None</code>
To navigate to after the action has been performed.
If the action has not been performed, <code>None</code> is returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doCommand(self, command, recordObj):
    &#34;&#34;&#34;Execute a workflow command on a record.

    The permission to execute the command will be checked first.

    !!! hint
        Workflow commands are listed in workflow.yaml, under `commands`.

    Parameters
    ----------
    recordObj: object
        The record must be passed as a record object.

    Returns
    -------
    url | `None`
        To navigate to after the action has been performed.
        If the action has not been performed, `None` is returned.
    &#34;&#34;&#34;

    context = recordObj.context
    table = recordObj.table
    eid = recordObj.eid
    kind = recordObj.kind
    commands = G(COMMANDS, table)
    (contribId,) = self.info(N.contrib, N._id)
    commandInfo = commands[command]
    acro = G(commandInfo, N.acro)

    urlExtra = E

    done = False
    if self.permission(table, command, kind=kind):
        operator = G(commandInfo, N.operator)
        if operator == N.add:
            oTable = G(commandInfo, N.table)
            tableObj = mkTable(context, oTable)
            oeid = tableObj.insert(masterTable=table, masterId=eid, force=True) or E
            if oeid:
                urlExtra = f&#34;&#34;&#34;/{N.open}/{oTable}/{oeid}&#34;&#34;&#34;
                done = True
        elif operator == N.set:
            field = G(commandInfo, N.field)
            value = G(commandInfo, N.value)
            if recordObj.field(field, mayEdit=True).save(value):
                done = True
        if done:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; done&#34;&#34;&#34;, &#34;message&#34;)
        else:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; failed&#34;&#34;&#34;, &#34;error&#34;)
    else:
        flash(f&#34;&#34;&#34;&lt;{acro}&gt; not permitted&#34;&#34;&#34;, &#34;error&#34;)

    return f&#34;&#34;&#34;/{N.contrib}/{N.item}/{contribId}{urlExtra}&#34;&#34;&#34; if done else None</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.getKind"><code class="name flex">
<span>def <span class="ident">getKind</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine whether a review(Entry) is <code>expert</code> or <code>final</code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The value <code>None</code> (not a string!) is returned for reviews that are
no (longer) part of the workflow.
They could be reviews with a type that does not match the type
of the contribution, or reviews that have been superseded by newer
reviews.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Either <code>review</code> or <code>reviewEntry</code>.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>dict</code></dt>
<dd>Either a <code>review</code> record or a <code>reviewEntry</code> record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>string {<code>expert</code>, <code>final</code>}
Or <code>None</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKind(self, table, record):
    &#34;&#34;&#34;Determine whether a review(Entry) is `expert` or `final`.

    !!! warning
        The value `None` (not a string!) is returned for reviews that are
        no (longer) part of the workflow.
        They could be reviews with a type that does not match the type
        of the contribution, or reviews that have been superseded by newer
        reviews.

    Parameters
    ----------
    table: string
        Either `review` or `reviewEntry`.
    record: dict
        Either a `review` record or a `reviewEntry` record.

    Returns
    -------
    string {`expert`, `final`}
        Or `None`.
    &#34;&#34;&#34;

    if table in {N.review, N.reviewEntry}:
        eid = G(record, N._id) if table == N.review else G(record, N.review)
        data = self.getWf(N.assessment)
        reviews = G(data, N.reviews, default={})
        kind = (
            N.expert
            if G(G(reviews, N.expert), N._id) == eid
            else N.final
            if G(G(reviews, N.final), N._id) == eid
            else None
        )
    else:
        kind = None
    return kind</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.getWf"><code class="name flex">
<span>def <span class="ident">getWf</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Select a source of attributes within a workflow item.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want the attributes:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWf(self, table, kind=None):
    &#34;&#34;&#34;Select a source of attributes within a workflow item.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want the attributes:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    dict
    &#34;&#34;&#34;

    data = self.data
    if table == N.contrib:
        return data

    data = G(data, N.assessment)
    if table in {N.assessment, N.criteriaEntry}:
        return data

    if table in {N.review, N.reviewEntry}:
        data = G(G(data, N.reviews), kind)
        return data

    return None</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, table, *atts, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve selected attributes of the workflow</p>
<p>A workflow record contains attributes at the outermost level,
but also within its enclosed assessment workflow record and
the enclosed review workflow records.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>In order to read attributes, we must specify the source of those
attributes: <code>contrib</code> (outermost), <code>assessment</code> or <code>review</code>.</dd>
<dt><strong><code>*atts</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The workflow attribute names to fetch.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>generator</code></dt>
<dd>Yields attribute values, corresponding to <code>*atts</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, table, *atts, kind=None):
    &#34;&#34;&#34;Retrieve selected attributes of the workflow

    A workflow record contains attributes at the outermost level,
    but also within its enclosed assessment workflow record and
    the enclosed review workflow records.

    Parameters
    ----------
    table: string
        In order to read attributes, we must specify the source of those
        attributes: `contrib` (outermost), `assessment` or `review`.
    *atts: iterable
        The workflow attribute names to fetch.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    generator
        Yields attribute values, corresponding to `*atts`.
    &#34;&#34;&#34;

    thisData = self.getWf(table, kind=kind)
    return (G(thisData, att) for att in atts)</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.isValid"><code class="name flex">
<span>def <span class="ident">isValid</span></span>(<span>self, table, eid, record)</span>
</code></dt>
<dd>
<section class="desc"><p>Is a record a valid part of the workflow?</p>
<p>Valid parts are contributions, assessment and review detail records of
contributions satisfying:</p>
<ul>
<li>they have the same type as their master contribution</li>
<li>they are not superseded by other assessments or reviews
with the correct type</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>table: string {<code>review</code>, <code>assessment</code>, <code>criteriaEntry</code>, <code>reviewEntry</code>}.</dt>
<dt><strong><code>eid</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>(Entity) id of the record to be validated.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>dict</code></dt>
<dd>The full record to be validated.
Only needed for <code>reviewEntry</code> and <code>criteriaEntry</code> in order to look
up the master <code>review</code> or <code>assessment</code> record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isValid(self, table, eid, record):
    &#34;&#34;&#34;Is a record a valid part of the workflow?

    Valid parts are contributions, assessment and review detail records of
    contributions satisfying:

    *   they have the same type as their master contribution
    *   they are not superseded by other assessments or reviews
        with the correct type

    Parameters
    ----------
    table: string {`review`, `assessment`, `criteriaEntry`, `reviewEntry`}.
    eid: ObjectId
        (Entity) id of the record to be validated.
    record: dict
        The full record to be validated.
        Only needed for `reviewEntry` and `criteriaEntry` in order to look
        up the master `review` or `assessment` record.

    Returns
    -------
    boolean
    &#34;&#34;&#34;
    if eid is None:
        return False

    refId = (
        G(record, N.assessment)
        if table == N.criteriaEntry
        else G(record, N.review)
        if table == N.reviewEntry
        else eid
    )
    if refId is None:
        return False

    if table in {N.contrib, N.assessment, N.criteriaEntry}:
        data = self.getWf(table)
        return refId == G(data, N._id)
    elif table in {N.review, N.reviewEntry}:
        data = self.getWf(N.assessment)
        reviews = G(data, N.reviews, default={})
        return refId in {
            G(reviewInfo, N._id) for (kind, reviewInfo) in reviews.items()
        }</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.myReviewerKind"><code class="name flex">
<span>def <span class="ident">myReviewerKind</span></span>(<span>self, reviewer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine whether the current user is <code>expert</code> or <code>final</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reviewer</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>If absent, the assessment in the workflow info will be inspected
to get a dict of its reviewers by kind.
Otherwise, it should be a dict of user ids keyed by <code>expert</code> and
<code>final</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>string {<code>expert</code>, <code>final</code>} | <code>None</code>
Depending on whether the current user is such a reviewer of the
assessment of this contribution. Or <code>None</code> if (s)he is not a reviewer
at all.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def myReviewerKind(self, reviewer=None):
    &#34;&#34;&#34;Determine whether the current user is `expert` or `final`.

    Parameters
    ----------
    reviewer: dict, optional `None`
        If absent, the assessment in the workflow info will be inspected
        to get a dict of its reviewers by kind.
        Otherwise, it should be a dict of user ids keyed by `expert` and
        `final`.

    Returns
    -------
    string {`expert`, `final`} | `None`
        Depending on whether the current user is such a reviewer of the
        assessment of this contribution. Or `None` if (s)he is not a reviewer
        at all.
    &#34;&#34;&#34;
    uid = self.uid

    if reviewer is None:
        reviewer = G(self.getWf(N.assessment), N.reviewer)

    return (
        N.expert
        if G(reviewer, N.expert) == uid
        else N.final
        if G(reviewer, N.final) == uid
        else None
    )</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.permission"><code class="name flex">
<span>def <span class="ident">permission</span></span>(<span>self, table, command, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether a workflow command is permitted.</p>
<p>Note that the commands are listed per kind of record they apply to:
contrib, assessment, review.
They are typically triggered by big workflow buttons on the interface.</p>
<p>When the request to execute such a command reachees the server, it will
check whether the current user is allowed to execute this command
on the records in question.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Workflow commands are listed in workflow.yaml, under <code>commands</code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you try to run a command on a kind of record that it is not
designed for, it will be detected and no permission will be given.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>In order to check permissions, we must specify the kind of record that
the command acts on: contrib, assessment, or review.</dd>
<dt><strong><code>command</code></strong> :&ensp;<code>string</code></dt>
<dd>An string consisting of the name of a command as listed in
workflow.yaml under <code>commands</code>.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permission(self, table, command, kind=None):
    &#34;&#34;&#34;Checks whether a workflow command is permitted.

    Note that the commands are listed per kind of record they apply to:
    contrib, assessment, review.
    They are typically triggered by big workflow buttons on the interface.

    When the request to execute such a command reachees the server, it will
    check whether the current user is allowed to execute this command
    on the records in question.

    !!! hint
        Workflow commands are listed in workflow.yaml, under `commands`.

    !!! note
        If you try to run a command on a kind of record that it is not
        designed for, it will be detected and no permission will be given.

    Parameters
    ----------
    table: string
        In order to check permissions, we must specify the kind of record that
        the command acts on: contrib, assessment, or review.
    command: string
        An string consisting of the name of a command as listed in
        workflow.yaml under `commands`.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    boolean
    &#34;&#34;&#34;
    auth = self.auth
    uid = self.uid

    allowedCommands = G(COMMANDS, table, default={})
    if command not in allowedCommands:
        return False

    if uid is None or table not in USER_TABLES:
        return False

    myKind = self.myKind

    (
        locked,
        done,
        frozen,
        mayAdd,
        stage,
        stageDate,
        creators,
        countryId,
    ) = self.info(
        table,
        N.locked,
        N.done,
        N.frozen,
        N.mayAdd,
        N.stage,
        N.stageDate,
        N.creators,
        N.country,
        kind=kind,
    )

    (contribId,) = self.info(N.contrib, N._id)

    isCoord = countryId and auth.coordinator(countryId=countryId)
    isSuper = auth.superuser()

    commandInfo = allowedCommands[command]
    decisionDelay = G(commandInfo, N.delay)
    if decisionDelay:
        decisionDelay = timedelta(hours=decisionDelay)

    justNow = now()
    remaining = False
    if decisionDelay and stageDate:
        remaining = stageDate + decisionDelay - justNow
        if remaining &lt;= timedelta(hours=0):
            remaining = False

    if frozen and not remaining:
        return False

    if table == N.contrib:
        if uid not in creators and not isCoord and not isSuper:
            return False

        if command == N.startAssessment:
            return mayAdd and not frozen and not done

        if not isCoord:
            return False

        answer = not frozen or remaining

        if command == N.selectContrib:
            return stage != N.selectYes and answer

        if command == N.deselectContrib:
            return stage != N.selectNo and answer

        if command == N.unselectContrib:
            return stage != N.selectNone and answer

        return False

    if frozen or done:
        return False

    if table == N.assessment:
        if command == N.startReview:
            return G(mayAdd, myKind)

        if uid not in creators:
            return False

        answer = not locked or remaining
        if not answer:
            return False

        if command == N.submitAssessment:
            return stage == N.complete

        if command == N.resubmitAssessment:
            return stage == N.completeWithdrawn

        if command == N.submitRevised:
            return stage == N.completeRevised

        if command == N.withdrawAssessment:
            return stage in {N.submitted, N.submittedRevised} and stage not in {
                N.incompleteWithdrawn,
                N.completeWithdrawn,
            }

        return False

    if table == N.review:
        commandInfo = G(allowedCommands, command)
        commandKind = G(commandInfo, N.kind)
        if not kind or kind != commandKind or kind != myKind:
            return False

        answer = not locked or remaining
        if not answer:
            return False

        if command in {
            N.expertReviewRevise,
            N.expertReviewAccept,
            N.expertReviewReject,
        }:
            return kind == N.expert

        if command in {
            N.finalReviewRevise,
            N.finalReviewAccept,
            N.finalReviewReject,
        }:
            (expertStage,) = self.info(table, N.stage, kind=N.expert)
            return kind == N.final and not not expertStage

        return False

    return False</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.stage"><code class="name flex">
<span>def <span class="ident">stage</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the workflow stage that a record is in.</p>
<p>Workflow stages are listed in workflow.yaml, under <code>stageAtts</code>.</p>
<p>The stage of a record is stored in the workflow attribute <code>stage</code>,
so the only thing needed is to ask for that attribute with
<a title="control.workflow.apply.WorkflowItem.info" href="#control.workflow.apply.WorkflowItem.info"><code>WorkflowItem.info()</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to see the stage:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>string {<code>selectYes</code>, <code>submittedRevised</code>, <code>reviewAccept</code>, &hellip;}
See workflow.yaml for the complete list.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stage(self, table, kind=None):
    &#34;&#34;&#34;Find the workflow stage that a record is in.

    Workflow stages are listed in workflow.yaml, under `stageAtts`.

    The stage of a record is stored in the workflow attribute `stage`,
    so the only thing needed is to ask for that attribute with
    `control.workflow.apply.WorkflowItem.info`.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to see the stage:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string {`selectYes`, `submittedRevised`, `reviewAccept`, ...}
        See workflow.yaml for the complete list.
    &#34;&#34;&#34;

    return list(self.info(table, N.stage, kind=kind))[0]</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Present all workflow info and controls relevant to the record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to see the status:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code>(<code>html</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status(self, table, kind=None):
    &#34;&#34;&#34;Present all workflow info and controls relevant to the record.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to see the status:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    eid = list(self.info(table, N._id, kind=kind))[0]
    itemKey = f&#34;&#34;&#34;{table}/{eid}&#34;&#34;&#34;
    rButton = H.iconr(itemKey, &#34;#workflow&#34;, msg=N.status)

    return H.div(
        [
            rButton,
            self.statusOverview(table, kind=kind),
            self.commands(table, kind=kind),
        ],
        cls=f&#34;workflow&#34;,
    )</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.statusOverview"><code class="name flex">
<span>def <span class="ident">statusOverview</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Present the current status of a record on the interface.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to present the stage:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code>(<code>html</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statusOverview(self, table, kind=None):
    &#34;&#34;&#34;Present the current status of a record on the interface.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to present the stage:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    (stage, stageDate, locked, done, frozen, score, eid) = self.info(
        table,
        N.stage,
        N.stageDate,
        N.locked,
        N.done,
        N.frozen,
        N.score,
        N._id,
        kind=kind,
    )
    stageInfo = G(STAGE_ATTS, stage)
    statusCls = G(stageInfo, N.cls)
    stageOn = (
        H.span(f&#34;&#34;&#34; on {datetime.toDisplay(stageDate)}&#34;&#34;&#34;, cls=&#34;date&#34;)
        if stageDate
        else E
    )
    statusMsg = H.span(
        [G(stageInfo, N.msg) or E, stageOn], cls=f&#34;large status {statusCls}&#34;
    )
    lockedCls = N.locked if locked else E
    lockedMsg = (
        H.span(G(STATUS_REP, N.locked), cls=f&#34;large status {lockedCls}&#34;)
        if locked
        else E
    )
    doneCls = N.done if done else E
    doneMsg = (
        H.span(G(STATUS_REP, N.done), cls=f&#34;large status {doneCls}&#34;) if done else E
    )
    frozenCls = N.frozen if frozen else E
    frozenMsg = (
        H.span(G(STATUS_REP, N.frozen), cls=f&#34;large status info&#34;) if frozen else E
    )

    statusRep = H.div([statusMsg, lockedMsg, doneMsg, frozenMsg], cls=frozenCls)

    scorePart = E
    if table == N.assessment:
        scoreParts = presentScore(score, table, eid)
        scorePart = (
            H.span(scoreParts)
            if table == N.assessment
            else (scoreParts[0] if scoreParts else E)
            if table == N.contrib
            else E
        )

    return H.div([statusRep, scorePart], cls=&#34;workflow-line&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control.workflow" href="index.html">control.workflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.workflow.apply.WorkflowItem" href="#control.workflow.apply.WorkflowItem">WorkflowItem</a></code></h4>
<ul class="two-column">
<li><code><a title="control.workflow.apply.WorkflowItem.auth" href="#control.workflow.apply.WorkflowItem.auth">auth</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.checkFixed" href="#control.workflow.apply.WorkflowItem.checkFixed">checkFixed</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.commands" href="#control.workflow.apply.WorkflowItem.commands">commands</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.data" href="#control.workflow.apply.WorkflowItem.data">data</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.doCommand" href="#control.workflow.apply.WorkflowItem.doCommand">doCommand</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.eppn" href="#control.workflow.apply.WorkflowItem.eppn">eppn</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.getKind" href="#control.workflow.apply.WorkflowItem.getKind">getKind</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.getWf" href="#control.workflow.apply.WorkflowItem.getWf">getWf</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.info" href="#control.workflow.apply.WorkflowItem.info">info</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.isCommand" href="#control.workflow.apply.WorkflowItem.isCommand">isCommand</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.isValid" href="#control.workflow.apply.WorkflowItem.isValid">isValid</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.myKind" href="#control.workflow.apply.WorkflowItem.myKind">myKind</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.myReviewerKind" href="#control.workflow.apply.WorkflowItem.myReviewerKind">myReviewerKind</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.permission" href="#control.workflow.apply.WorkflowItem.permission">permission</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.stage" href="#control.workflow.apply.WorkflowItem.stage">stage</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.status" href="#control.workflow.apply.WorkflowItem.status">status</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.statusOverview" href="#control.workflow.apply.WorkflowItem.statusOverview">statusOverview</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.uid" href="#control.workflow.apply.WorkflowItem.uid">uid</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>