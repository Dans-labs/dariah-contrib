<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>control.workflow.apply API documentation</title>
<meta name="description" content="Applying workflow â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.workflow.apply</code></h1>
</header>
<section id="section-intro">
<p>Applying workflow</p>
<ul>
<li>Compute workflow permissions</li>
<li>Show workflow state</li>
<li>Perform workflow tasks</li>
<li>Enforce workflow constraints</li>
</ul>
<h2 id="workflow-tasks">Workflow tasks</h2>
<p>The heart of the tool consists of a set of workflow tasks
that can be executed safely by a workflow engine.</p>
<p>A task is is triggered by a url:</p>
<p><code>/api/task/</code><em>taskName</em><code>/</code><em>eid</em></p>
<p>Here the <em>eid</em> is the id of the central record of the task, e.g. a particular
contribution, assessment, or review.</p>
<p>Workflow tasks are listed in workflow.yaml, under <code>tasks</code>.
Every task name is associated with properties,
which are used in determining the permissions of a task.
They also steer the execution of the task.</p>
<h3 id="properties-of-workflow-tasks">Properties of workflow tasks</h3>
<p>Here is a list that explains the task properties.</p>
<dl>
<dt>operator</dt>
<dd>
<p>There are two kinds of operator: <code>add</code> and <code>set</code>.</p>
<p>The effect of <code>add</code> is the insertion of a new record in a
table given in the <code>detail</code> property.</p>
<p>The effect of <code>set</code> is the setting of specific fields in a record in
the table inndicated by the <code>table</code> property.
The fields are indicated in the <code>field</code> and <code>date</code> properties.</p>
</dd>
<dt>table</dt>
<dd>The table in which the record resides that is central to the task.</dd>
<dt>detail</dt>
<dd>The detail table in case the operator is <code>add</code>: it will add a detail
record of the central record into this table.</dd>
<dt>kind</dt>
<dd>In case the task operates on reviews: whether the task is relevant for
an <code>expert</code> review or a <code>final</code> review.</dd>
<dt>field</dt>
<dd>In case the operator is <code>set</code>: the field in the central record that will be changed.</dd>
<dt>value</dt>
<dd>In case the operator is <code>set</code>: the new value for the field in the central
record that will be changed.</dd>
<dt>date</dt>
<dd>In case the operator is <code>set</code>: the name of the field that will receive the
timestamp.</dd>
<dt>delay</dt>
<dd>All <code>set</code> tasks are not meant to be revoked. But there is some leeway:
Within the amount of hours specified here, the user can revoke the task.</dd>
<dt>msg</dt>
<dd>How the task is called on the interface.</dd>
<dt>acro</dt>
<dd>An acronym of the task to be used in flash messages.</dd>
<dt>cls</dt>
<dd>A CSS class that determines the color of the workflow button, usually
<code>info</code>, <code>good</code>, <code>warning</code>, <code>error</code>. <code>info</code> is the neutral color.</dd>
</dl>
<h2 id="workflow-stages">Workflow stages</h2>
<p>Workflow stages are listed in workflow.yaml, under <code>stageAtts</code>.</p>
<p>The stage of a record is stored in the workflow attribute <code>stage</code>,
so the only thing needed is to ask for that attribute with
<a title="control.workflow.apply.WorkflowItem.info" href="#control.workflow.apply.WorkflowItem.info"><code>WorkflowItem.info()</code></a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Applying workflow

*   Compute workflow permissions
*   Show workflow state
*   Perform workflow tasks
*   Enforce workflow constraints

## Workflow tasks

The heart of the tool consists of a set of workflow tasks
that can be executed safely by a workflow engine.

A task is is triggered by a url:

`/api/task/`*taskName*`/`*eid*

Here the *eid* is the id of the central record of the task, e.g. a particular
contribution, assessment, or review.

Workflow tasks are listed in workflow.yaml, under `tasks`.
Every task name is associated with properties,
which are used in determining the permissions of a task.
They also steer the execution of the task.

### Properties of workflow tasks

Here is a list that explains the task properties.

operator
:   There are two kinds of operator: `add` and `set`.

    The effect of `add` is the insertion of a new record in a
    table given in the `detail` property.

    The effect of `set` is the setting of specific fields in a record in
    the table inndicated by the `table` property.
    The fields are indicated in the `field` and `date` properties.

table
:   The table in which the record resides that is central to the task.

detail
:   The detail table in case the operator is `add`: it will add a detail
    record of the central record into this table.

kind
:   In case the task operates on reviews: whether the task is relevant for
    an `expert` review or a `final` review.

field
:   In case the operator is `set`: the field in the central record that will be changed.

value
:   In case the operator is `set`: the new value for the field in the central
    record that will be changed.

date
:   In case the operator is `set`: the name of the field that will receive the
    timestamp.

delay
:   All `set` tasks are not meant to be revoked. But there is some leeway:
    Within the amount of hours specified here, the user can revoke the task.

msg
:   How the task is called on the interface.

acro
:   An acronym of the task to be used in flash messages.

cls
:   A CSS class that determines the color of the workflow button, usually
    `info`, `good`, `warning`, `error`. `info` is the neutral color.

## Workflow stages

Workflow stages are listed in workflow.yaml, under `stageAtts`.

The stage of a record is stored in the workflow attribute `stage`,
so the only thing needed is to ask for that attribute with
`control.workflow.apply.WorkflowItem.info`.
&#34;&#34;&#34;

from datetime import timedelta
from flask import flash

from config import Config as C, Names as N
from control.utils import pick as G, E, now
from control.html import HtmlElements as H
from control.typ.datetime import Datetime
from control.cust.score import presentScore
from control.cust.factory_table import make as mkTable


CT = C.tables
CF = C.workflow

ALL_TABLES = CT.all

USER_TABLES_LIST = CT.userTables
MAIN_TABLE = USER_TABLES_LIST[0]
USER_ENTRY_TABLES = set(CT.userEntryTables)
USER_TABLES = set(USER_TABLES_LIST)
SENSITIVE_TABLES = (USER_TABLES - {MAIN_TABLE}) | USER_ENTRY_TABLES

STAGE_ATTS = CF.stageAtts
TASKS = CF.tasks
TASK_FIELDS = CF.taskFields
STATUS_REP = CF.statusRep
DECISION_DELAY = CF.decisionDelay

datetime = Datetime()


def execute(context, task, eid):
    &#34;&#34;&#34;Executes a workflow task.

    First a table object is constructed, based on the `table` property
    of the task, using `context`.

    Then a record object is constructed in that table, based on the `eid`
    parameter.

    If that all succeeds, all information is at hand to verify permissions
    and perform the task.

    Parameters
    ----------
    context: object
        A `control.context.Context` singleton
    task: string
        The name of the task
    eid: string(objectId)
        The id of the relevant record
    &#34;&#34;&#34;

    taskInfo = G(TASKS, task)
    acro = G(taskInfo, N.acro)
    table = G(taskInfo, N.table)
    if table not in ALL_TABLES:
        flash(f&#34;&#34;&#34;Workflow {acro} operates on wrong table: &#34;{table or E}&#34;&#34;&#34;, &#34;error&#34;)
        return (False, None)
    return mkTable(context, table).record(eid=eid).task(task)


class WorkflowItem:
    &#34;&#34;&#34;Supports the application of workflow information.

    A WorkflowItem singleton has a bunch of workflow attributes as dict in its
    attribute `data` and offers methods to

    *   address selected pieces of that information;
    *   compute permissions for workflow actions and database actions;
    *   determine the workflow stage the contribution is in.

    Attributes
    ----------
    data: dict
        All workflow attributes.
    myKind: string
        The kind of reviewer the current user is, if any.
    &#34;&#34;&#34;

    def __init__(self, context, data):
        &#34;&#34;&#34;## Initialization

        Wraps a workflow item record around a workflow data record.

        Workflow item records are created per contribution,
        but they will be referenced by contribution, assessment and review records
        in their attribute `wfitem`.

        Workflow items also store details of the current user, which will be needed
        for the computation of permissions.

        !!! note
            The user attributes `uid` and `eppn` will be stored in this `WorkflowItem`
            object.
            At this point, it is also possible to what kind of reviewer the current
            user is, if any, and store that in attribute `myKind`.

        Parameters
        ----------
        context: object
            The `control.context.Context singleton`, from which the
            `control.auth.Auth` singleton can be picked up, from which the
            details of the current user can be read off.
        data: dict
            See below.
        &#34;&#34;&#34;

        db = context.db
        auth = context.auth
        user = auth.user

        self.db = db
        &#34;&#34;&#34;*object* The `control.db.Db` singleton

        Provides methods to deal with values  from the table `decision`.
        &#34;&#34;&#34;

        self.auth = auth
        &#34;&#34;&#34;*object* The `control.auth.Auth` singleton

        Provides methods to access the attributes of the current user.
        &#34;&#34;&#34;

        self.uid = G(user, N._id)
        &#34;&#34;&#34;*ObjectId* The id of the current user.
        &#34;&#34;&#34;

        self.eppn = G(user, N.eppn)
        &#34;&#34;&#34;*ObjectId* The eppn of the current user.

        !!! hint
            The eppn is the user identifying attribute from the identity provider.
        &#34;&#34;&#34;

        self.isSuperuser = auth.superuser()
        &#34;&#34;&#34;*boolean* Whether the current user is a superuser.

        See `control.auth.Auth.superuser`.
        &#34;&#34;&#34;

        self.data = data
        &#34;&#34;&#34;*dict* The  workflow attributes.
        &#34;&#34;&#34;

        self.myKind = self.myReviewerKind()
        &#34;&#34;&#34;*dict* The kind of reviewer that the current user is.

        A user is `expert` reviewer or `final` reviewer, or `None`.
        &#34;&#34;&#34;

    def getKind(self, table, record):
        &#34;&#34;&#34;Determine whether a review(Entry) is `expert` or `final`.

        !!! warning
            The value `None` (not a string!) is returned for reviews that are
            no (longer) part of the workflow.
            They could be reviews with a type that does not match the type
            of the contribution, or reviews that have been superseded by newer
            reviews.

        Parameters
        ----------
        table: string
            Either `review` or `reviewEntry`.
        record: dict
            Either a `review` record or a `reviewEntry` record.

        Returns
        -------
        string {`expert`, `final`}
            Or `None`.
        &#34;&#34;&#34;

        if table in {N.review, N.reviewEntry}:
            eid = G(record, N._id) if table == N.review else G(record, N.review)
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            kind = (
                N.expert
                if G(G(reviews, N.expert), N._id) == eid
                else N.final
                if G(G(reviews, N.final), N._id) == eid
                else None
            )
        else:
            kind = None
        return kind

    def isValid(self, table, eid, record):
        &#34;&#34;&#34;Is a record a valid part of the workflow?

        Valid parts are contributions, assessment and review detail records of
        contributions satisfying:

        *   they have the same type as their master contribution
        *   they are not superseded by other assessments or reviews
            with the correct type

        Parameters
        ----------
        table: string {`review`, `assessment`, `criteriaEntry`, `reviewEntry`}.
        eid: ObjectId
            (Entity) id of the record to be validated.
        record: dict
            The full record to be validated.
            Only needed for `reviewEntry` and `criteriaEntry` in order to look
            up the master `review` or `assessment` record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        if eid is None:
            return False

        refId = (
            G(record, N.assessment)
            if table == N.criteriaEntry
            else G(record, N.review)
            if table == N.reviewEntry
            else eid
        )
        if refId is None:
            return False

        if table in {N.contrib, N.assessment, N.criteriaEntry}:
            data = self.getWf(table)
            return refId == G(data, N._id)
        elif table in {N.review, N.reviewEntry}:
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            return refId in {
                G(reviewInfo, N._id) for (kind, reviewInfo) in reviews.items()
            }

    def info(self, table, *atts, kind=None):
        &#34;&#34;&#34;Retrieve selected attributes of the workflow

        A workflow record contains attributes at the outermost level,
        but also within its enclosed assessment workflow record and
        the enclosed review workflow records.

        Parameters
        ----------
        table: string
            In order to read attributes, we must specify the source of those
            attributes: `contrib` (outermost), `assessment` or `review`.
        *atts: iterable
            The workflow attribute names to fetch.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        generator
            Yields attribute values, corresponding to `*atts`.
        &#34;&#34;&#34;

        thisData = self.getWf(table, kind=kind)
        return (G(thisData, att) for att in atts)

    def checkReadable(self, recordObj):
        &#34;&#34;&#34;Whether a record is readable because of workflow.

        When a contribution, assessment, review is in a certain stage
        in the workflow, its record may be closed to others than the owner, and
        after finalization,  some fields may be open to authenticated users or
        the public.

        This method determines the record is readable by the current user.

        If the record is not part of the workflow, `None` is returned, and
        the normal permission rules apply.

        !!! note
            It also depends on the current user.
            Power users will not be prevented to read records because of
            workflow conditions.

        Here are the rules:

        #### Assessment, Criteria Entry

        Not submitted:
        : authors and editors only

        Submitted, review not yet complete, or negative outcome
        :   authors, editors, reviewers, national coordinator only

        Review with positive outcome
        :   public

        Negative outcome
        :   authors, editors, reviewers, national coordinator only

        #### Review, Review Entry

        Review has no decision and there is no final decision
        :   authors, editors

        Review in question has a decision, but still no final positive decision
        :   authors/editors, other reviewer, authors/editors of the assessment,
            national coordinator

        There is a positive final decision
        :   public

        !!! caution &#34;The influence of selection is nihil&#34;
            Whether a contribution is selected or not has no influence on the
            readability of the assessment and review.

        !!! caution &#34;The influence on the contribution records is nihil&#34;
            Whether a contribution is readable does not depend on the
            workflow, only on the normal rules.

        Parameters
        ----------
        recordObj: object
            The record in question (from which the table and the kind
            maybe inferred. It should be the record that contains this
            WorkflowItem object as its `wfitem` attribute.
        field: string, optional `None`
            If None, we check for the readability of the record as a whole.
            Otherwise, we check for the readability of this field in the record.

        Returns
        -------
        boolean | `None`
        &#34;&#34;&#34;

        isSuperuser = self.isSuperuser
        if isSuperuser:
            return None

        table = recordObj.table
        if table not in SENSITIVE_TABLES:
            return None

        kind = recordObj.kind
        perm = recordObj.perm
        uid = self.uid

        (done, stage) = self.info(table, N.done, N.stage, kind=kind)

        if table in {N.assessment, N.criteriaEntry}:
            (rStage,) = self.info(N.review, N.stage, kind=N.final)
            return (
                True
                if rStage == N.reviewAccept
                else perm[N.isOur]
                if stage in {N.submitted, N.submittedRevised}
                else perm[N.isEdit]
            )

        if table in {N.review, N.reviewEntry}:
            (creators,) = self.info(N.assessment, N.creators)
            (rStage,) = self.info(N.review, N.stage, kind=N.final)
            result = (
                True
                if rStage == N.reviewAccept
                else uid in creators or perm[N.isOur]
                if stage
                in {
                    N.reviewAdviseRevise,
                    N.reviewAdviseAccept,
                    N.reviewAdviseReject,
                    N.reviewRevise,
                    N.reviewReject,
                }
                or rStage in {N.reviewRevise, N.reviewReject}
                else perm[N.isEdit]
            )
            return result
        return None

    def checkFixed(self, recordObj, field=None):
        &#34;&#34;&#34;Whether a record or field is fixed because of workflow.

        When a contribution, assessment, review is in a certain stage
        in the workflow, its record or some fields in its record may be
        fixated, either temporarily or permanently.

        This method checks whether a record or field is currently fixed,
        i.e. whether editing is possible.

        !!! note
            It might also depend on the current user.

        !!! caution
            Here is a case where the sysadmin and the root are less powerful
            than the office users: only the office users can assign reviewers,
            i.e. only they can update `reviewerE` and `reviewerF` inn assessment fields.

        Parameters
        ----------
        recordObj: object
            The record in question (from which the table and the kind
            maybe inferred. It should be the record that contains this
            WorkflowItem object as its `wfitem` attribute.
        field: string, optional `None`
            If None, we check for the fixity of the record as a whole.
            Otherwise, we check for the fixity of this field in the record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        auth = self.auth
        table = recordObj.table
        kind = recordObj.kind

        (frozen, done, locked) = self.info(table, N.frozen, N.done, N.locked, kind=kind)

        if field is None:
            return frozen or done or locked

        if frozen or done:
            return True

        if not locked:
            return False

        isOffice = auth.officeuser()
        if isOffice and table == N.assessment:
            return field not in {N.reviewerE, N.reviewerF}

        return True

    def permission(self, task, kind=None):
        &#34;&#34;&#34;Checks whether a workflow task is permitted.

        Note that the tasks are listed per kind of record they apply to:
        contrib, assessment, review.
        They are typically triggered by big workflow buttons on the interface.

        When the request to execute such a task reaches the server, it will
        check whether the current user is allowed to execute this task
        on the records in question.

        !!! hint
            See above for explanation of the properties of the tasks.

        !!! note
            If you try to run a task on a kind of record that it is not
            designed for, it will be detected and no permission will be given.

        !!! note
            Some tasks are designed to set a field to a value.
            If that field already has that value, the task will not be permitted.
            This already rules out a lot of things and relieves the burden of
            prohibiting non-sensical tasks.

        It may be that the task is only permitted for some limited time from now on.
        Then a timedelta object with the amount of time left is returned.

        Parameters
        ----------
        table: string
            In order to check permissions, we must specify the kind of record that
            the task acts on: contrib, assessment, or review.
        task: string
            An string consisting of the name of a task.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        boolean | timedelta
        &#34;&#34;&#34;

        db = self.db
        auth = self.auth
        uid = self.uid

        if task not in TASKS:
            return False

        taskInfo = TASKS[task]
        table = G(taskInfo, N.table)

        if uid is None or table not in USER_TABLES:
            return False

        taskField = (
            N.selected
            if table == N.contrib
            else N.submitted
            if table == N.assessment
            else N.decision
            if table == N.review
            else None
        )
        myKind = self.myKind

        (
            locked,
            done,
            frozen,
            mayAdd,
            stage,
            stageDate,
            creators,
            countryId,
            taskValue,
        ) = self.info(
            table,
            N.locked,
            N.done,
            N.frozen,
            N.mayAdd,
            N.stage,
            N.stageDate,
            N.creators,
            N.country,
            taskField,
            kind=kind,
        )

        operator = G(taskInfo, N.operator)
        value = G(taskInfo, N.value)
        if operator == N.set:
            if taskField == N.decision:
                value = G(db.decisionInv, value)
            if value == taskValue:
                return False

        (contribId,) = self.info(N.contrib, N._id)

        isOwn = uid in creators
        isCoord = countryId and auth.coordinator(countryId=countryId)
        isSuper = auth.superuser()

        decisionDelay = G(taskInfo, N.delay)
        if decisionDelay:
            decisionDelay = timedelta(hours=decisionDelay)

        justNow = now()
        remaining = False
        if decisionDelay and stageDate:
            remaining = stageDate + decisionDelay - justNow
            if remaining &lt;= timedelta(hours=0):
                remaining = False

        if frozen and not remaining:
            return False

        if table == N.contrib:
            if not isOwn and not isCoord and not isSuper:
                return False

            if task == N.startAssessment:
                return isOwn and mayAdd and not frozen and not done

            if not isCoord:
                return False

            answer = not frozen or remaining

            if task == N.selectContrib:
                return stage != N.selectYes and answer

            if task == N.deselectContrib:
                return stage != N.selectNo and answer

            if task == N.unselectContrib:
                return stage != N.selectNone and answer

            return False

        if (frozen or done) and not remaining:
            return False

        if table == N.assessment:
            if task == N.startReview:
                return G(mayAdd, myKind)

            if uid not in creators:
                return False

            answer = not locked or remaining
            if not answer:
                return False

            if task == N.submitAssessment:
                return stage == N.complete and answer

            if task == N.resubmitAssessment:
                return stage == N.completeWithdrawn and answer

            if task == N.submitRevised:
                return stage == N.completeRevised and answer

            if task == N.withdrawAssessment:
                return (
                    stage in {N.submitted, N.submittedRevised}
                    and stage not in {N.incompleteWithdrawn, N.completeWithdrawn}
                    and answer
                )

            return False

        if table == N.review:
            taskKind = G(taskInfo, N.kind)
            if not kind or kind != taskKind or kind != myKind:
                return False

            answer = remaining or not locked or remaining
            if not answer:
                return False

            if task in {
                N.expertReviewRevise,
                N.expertReviewAccept,
                N.expertReviewReject,
            }:
                return kind == N.expert and answer

            if task in {
                N.finalReviewRevise,
                N.finalReviewAccept,
                N.finalReviewReject,
            }:
                (expertStage,) = self.info(table, N.stage, kind=N.expert)
                return kind == N.final and not not expertStage and answer

            return False

        return False

    def stage(self, table, kind=None):
        &#34;&#34;&#34;Find the workflow stage that a record is in.

        !!! hint
            See above for a description of the stages.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string {`selectYes`, `submittedRevised`, `reviewAccept`, ...}
            See above for the complete list.
        &#34;&#34;&#34;

        return list(self.info(table, N.stage, kind=kind))[0]

    def creators(self, table, kind=None):
        &#34;&#34;&#34;Find the creators from a workflow related record.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the creators:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        (list of ObjectId)
        &#34;&#34;&#34;

        return list(self.info(table, N.creators, kind=kind))[0]

    def status(self, table, kind=None):
        &#34;&#34;&#34;Present all workflow info and controls relevant to the record.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the status:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        eid = list(self.info(table, N._id, kind=kind))[0]
        itemKey = f&#34;&#34;&#34;{table}/{eid}&#34;&#34;&#34;
        rButton = H.iconr(itemKey, &#34;#workflow&#34;, msg=N.status)

        return H.div(
            [
                rButton,
                self.statusOverview(table, kind=kind),
                self.tasks(table, kind=kind),
            ],
            cls=f&#34;workflow&#34;,
        )

    @staticmethod
    def isTask(table, field):
        &#34;&#34;&#34;Whether a field in a record is involved in a workflow task.

        Fields that are involved in workflow tasks can not be read or edited
        directly:

        *   they are represented as workflow status, not as a value
            (see `control.workflow.apply.WorkflowItem.status`);
        *   they only change as a result of a  workflow task
            (see `control.workflow.apply.WorkflowItem.doTask`).

        !!! hint
            Workflow tasks are described above.

        !!! caution
            If a record is not a valid part of a workflow, then all its fields
            are represented and actionable in the normal way.

        Parameters
        ----------
        table: string
            The table in question.
        field: string
            The field in question.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        taskFields = G(TASK_FIELDS, table, default=set())
        return field in taskFields

    def doTask(self, task, recordObj):
        &#34;&#34;&#34;Execute a workflow task on a record.

        The permission to execute the task will be checked first.

        !!! hint
            Workflow tasks are described above.

        Parameters
        ----------
        recordObj: object
            The record must be passed as a record object.

        Returns
        -------
        url | `None`
            To navigate to after the action has been performed.
            If the action has not been performed, `None` is returned.
        &#34;&#34;&#34;

        context = recordObj.context
        table = recordObj.table
        eid = recordObj.eid
        kind = recordObj.kind
        (contribId,) = self.info(N.contrib, N._id)

        taskInfo = G(TASKS, task)
        acro = G(taskInfo, N.acro)

        urlExtra = E

        done = False
        if self.permission(task, kind=kind):
            operator = G(taskInfo, N.operator)
            if operator == N.add:
                dtable = G(taskInfo, N.detail)
                tableObj = mkTable(context, dtable)
                deid = tableObj.insert(masterTable=table, masterId=eid, force=True) or E
                if deid:
                    urlExtra = f&#34;&#34;&#34;/{N.open}/{dtable}/{deid}&#34;&#34;&#34;
                    done = True
            elif operator == N.set:
                field = G(taskInfo, N.field)
                value = G(taskInfo, N.value)
                if recordObj.field(field, mayEdit=True).save(value):
                    done = True
            if done:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; done&#34;&#34;&#34;, &#34;message&#34;)
            else:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; failed&#34;&#34;&#34;, &#34;error&#34;)
        else:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; not permitted&#34;&#34;&#34;, &#34;error&#34;)

        return f&#34;&#34;&#34;/{N.contrib}/{N.item}/{contribId}{urlExtra}&#34;&#34;&#34; if done else None

    def statusOverview(self, table, kind=None):
        &#34;&#34;&#34;Present the current status of a record on the interface.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to present the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        (stage, stageDate, locked, done, frozen, score, eid) = self.info(
            table,
            N.stage,
            N.stageDate,
            N.locked,
            N.done,
            N.frozen,
            N.score,
            N._id,
            kind=kind,
        )
        stageInfo = G(STAGE_ATTS, stage)
        statusCls = G(stageInfo, N.cls)
        stageOn = (
            H.span(f&#34;&#34;&#34; on {datetime.toDisplay(stageDate)}&#34;&#34;&#34;, cls=&#34;date&#34;)
            if stageDate
            else E
        )
        statusMsg = H.span(
            [G(stageInfo, N.msg) or E, stageOn], cls=f&#34;large status {statusCls}&#34;
        )
        lockedCls = N.locked if locked else E
        lockedMsg = (
            H.span(G(STATUS_REP, N.locked), cls=f&#34;large status {lockedCls}&#34;)
            if locked
            else E
        )
        doneCls = N.done if done else E
        doneMsg = (
            H.span(G(STATUS_REP, N.done), cls=f&#34;large status {doneCls}&#34;) if done else E
        )
        frozenCls = N.frozen if frozen else E
        frozenMsg = (
            H.span(G(STATUS_REP, N.frozen), cls=f&#34;large status info&#34;) if frozen else E
        )

        statusRep = f&#34;&lt;!-- stage:{stage} --&gt;&#34; + H.div(
            [statusMsg, lockedMsg, doneMsg, frozenMsg], cls=frozenCls
        )

        scorePart = E
        if table == N.assessment:
            scoreParts = presentScore(score, eid)
            scorePart = (
                H.span(scoreParts)
                if table == N.assessment
                else (scoreParts[0] if scoreParts else E)
                if table == N.contrib
                else E
            )

        return H.div([statusRep, scorePart], cls=&#34;workflow-line&#34;)

    def tasks(self, table, kind=None):
        &#34;&#34;&#34;Present the currently available tasks as buttons on the interface.

        !!! hint &#34;easy comments&#34;
            We also include a comment `&lt;!-- task~!taskName:eid --&gt;
            for the ease of testing.

        Parameters
        ----------
        table: string
            We must specify the table for which we want to present the
            tasks: contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        uid = self.uid

        if not uid or table not in USER_TABLES:
            return E

        eid = list(self.info(table, N._id, kind=kind))[0]
        taskParts = []

        allowedTasks = sorted(
            (task, taskInfo)
            for (task, taskInfo) in TASKS.items()
            if G(taskInfo, N.table) == table
        )
        justNow = now()

        for (task, taskInfo) in allowedTasks:
            permitted = self.permission(task, kind=kind)
            if not permitted:
                continue

            remaining = type(permitted) is timedelta and permitted
            taskUntil = E
            if remaining:
                remainingRep = datetime.toDisplay(justNow + remaining)
                taskUntil = H.span(f&#34;&#34;&#34; before {remainingRep}&#34;&#34;&#34;, cls=&#34;datex&#34;)
            taskMsg = G(taskInfo, N.msg)
            taskCls = G(taskInfo, N.cls)

            taskPart = H.a(
                [taskMsg, taskUntil],
                f&#34;&#34;&#34;/api/task/{task}/{eid}&#34;&#34;&#34;,
                cls=f&#34;large task {taskCls}&#34;,
            ) + f&#34;&#34;&#34;&lt;!-- task!{task}:{eid} --&gt;&#34;&#34;&#34;
            taskParts.append(taskPart)

        return H.join(taskParts)

    def getWf(self, table, kind=None):
        &#34;&#34;&#34;Select a source of attributes within a workflow item.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want the attributes:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        dict
        &#34;&#34;&#34;

        data = self.data
        if table == N.contrib:
            return data

        data = G(data, N.assessment)
        if table in {N.assessment, N.criteriaEntry}:
            return data

        if table in {N.review, N.reviewEntry}:
            data = G(G(data, N.reviews), kind)
            return data

        return None

    def myReviewerKind(self, reviewer=None):
        &#34;&#34;&#34;Determine whether the current user is `expert` or `final`.

        Parameters
        ----------
        reviewer: dict, optional `None`
            If absent, the assessment in the workflow info will be inspected
            to get a dict of its reviewers by kind.
            Otherwise, it should be a dict of user ids keyed by `expert` and
            `final`.

        Returns
        -------
        string {`expert`, `final`} | `None`
            Depending on whether the current user is such a reviewer of the
            assessment of this contribution. Or `None` if (s)he is not a reviewer
            at all.
        &#34;&#34;&#34;
        uid = self.uid

        if reviewer is None:
            reviewer = G(self.getWf(N.assessment), N.reviewer)

        return (
            N.expert
            if G(reviewer, N.expert) == uid
            else N.final
            if G(reviewer, N.final) == uid
            else None
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="control.workflow.apply.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>context, task, eid)</span>
</code></dt>
<dd>
<section class="desc"><p>Executes a workflow task.</p>
<p>First a table object is constructed, based on the <code>table</code> property
of the task, using <code>context</code>.</p>
<p>Then a record object is constructed in that table, based on the <code>eid</code>
parameter.</p>
<p>If that all succeeds, all information is at hand to verify permissions
and perform the task.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>object</code></dt>
<dd>A <a title="control.context.Context" href="../context.html#control.context.Context"><code>Context</code></a> singleton</dd>
<dt><strong><code>task</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the task</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string</code>(<code>objectId</code>)</dt>
<dd>The id of the relevant record</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(context, task, eid):
    &#34;&#34;&#34;Executes a workflow task.

    First a table object is constructed, based on the `table` property
    of the task, using `context`.

    Then a record object is constructed in that table, based on the `eid`
    parameter.

    If that all succeeds, all information is at hand to verify permissions
    and perform the task.

    Parameters
    ----------
    context: object
        A `control.context.Context` singleton
    task: string
        The name of the task
    eid: string(objectId)
        The id of the relevant record
    &#34;&#34;&#34;

    taskInfo = G(TASKS, task)
    acro = G(taskInfo, N.acro)
    table = G(taskInfo, N.table)
    if table not in ALL_TABLES:
        flash(f&#34;&#34;&#34;Workflow {acro} operates on wrong table: &#34;{table or E}&#34;&#34;&#34;, &#34;error&#34;)
        return (False, None)
    return mkTable(context, table).record(eid=eid).task(task)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.workflow.apply.WorkflowItem"><code class="flex name class">
<span>class <span class="ident">WorkflowItem</span></span>
<span>(</span><span>context, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Supports the application of workflow information.</p>
<p>A WorkflowItem singleton has a bunch of workflow attributes as dict in its
attribute <code>data</code> and offers methods to</p>
<ul>
<li>address selected pieces of that information;</li>
<li>compute permissions for workflow actions and database actions;</li>
<li>determine the workflow stage the contribution is in.</li>
</ul>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>All workflow attributes.</dd>
<dt><strong><code>myKind</code></strong> :&ensp;<code>string</code></dt>
<dd>The kind of reviewer the current user is, if any.</dd>
</dl>
<h2 id="initialization">Initialization</h2>
<p>Wraps a workflow item record around a workflow data record.</p>
<p>Workflow item records are created per contribution,
but they will be referenced by contribution, assessment and review records
in their attribute <code>wfitem</code>.</p>
<p>Workflow items also store details of the current user, which will be needed
for the computation of permissions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The user attributes <code>uid</code> and <code>eppn</code> will be stored in this <a title="control.workflow.apply.WorkflowItem" href="#control.workflow.apply.WorkflowItem"><code>WorkflowItem</code></a>
object.
At this point, it is also possible to what kind of reviewer the current
user is, if any, and store that in attribute <code>myKind</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>object</code></dt>
<dd>The <code>control.context.Context singleton</code>, from which the
<a title="control.auth.Auth" href="../auth.html#control.auth.Auth"><code>Auth</code></a> singleton can be picked up, from which the
details of the current user can be read off.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>See below.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkflowItem:
    &#34;&#34;&#34;Supports the application of workflow information.

    A WorkflowItem singleton has a bunch of workflow attributes as dict in its
    attribute `data` and offers methods to

    *   address selected pieces of that information;
    *   compute permissions for workflow actions and database actions;
    *   determine the workflow stage the contribution is in.

    Attributes
    ----------
    data: dict
        All workflow attributes.
    myKind: string
        The kind of reviewer the current user is, if any.
    &#34;&#34;&#34;

    def __init__(self, context, data):
        &#34;&#34;&#34;## Initialization

        Wraps a workflow item record around a workflow data record.

        Workflow item records are created per contribution,
        but they will be referenced by contribution, assessment and review records
        in their attribute `wfitem`.

        Workflow items also store details of the current user, which will be needed
        for the computation of permissions.

        !!! note
            The user attributes `uid` and `eppn` will be stored in this `WorkflowItem`
            object.
            At this point, it is also possible to what kind of reviewer the current
            user is, if any, and store that in attribute `myKind`.

        Parameters
        ----------
        context: object
            The `control.context.Context singleton`, from which the
            `control.auth.Auth` singleton can be picked up, from which the
            details of the current user can be read off.
        data: dict
            See below.
        &#34;&#34;&#34;

        db = context.db
        auth = context.auth
        user = auth.user

        self.db = db
        &#34;&#34;&#34;*object* The `control.db.Db` singleton

        Provides methods to deal with values  from the table `decision`.
        &#34;&#34;&#34;

        self.auth = auth
        &#34;&#34;&#34;*object* The `control.auth.Auth` singleton

        Provides methods to access the attributes of the current user.
        &#34;&#34;&#34;

        self.uid = G(user, N._id)
        &#34;&#34;&#34;*ObjectId* The id of the current user.
        &#34;&#34;&#34;

        self.eppn = G(user, N.eppn)
        &#34;&#34;&#34;*ObjectId* The eppn of the current user.

        !!! hint
            The eppn is the user identifying attribute from the identity provider.
        &#34;&#34;&#34;

        self.isSuperuser = auth.superuser()
        &#34;&#34;&#34;*boolean* Whether the current user is a superuser.

        See `control.auth.Auth.superuser`.
        &#34;&#34;&#34;

        self.data = data
        &#34;&#34;&#34;*dict* The  workflow attributes.
        &#34;&#34;&#34;

        self.myKind = self.myReviewerKind()
        &#34;&#34;&#34;*dict* The kind of reviewer that the current user is.

        A user is `expert` reviewer or `final` reviewer, or `None`.
        &#34;&#34;&#34;

    def getKind(self, table, record):
        &#34;&#34;&#34;Determine whether a review(Entry) is `expert` or `final`.

        !!! warning
            The value `None` (not a string!) is returned for reviews that are
            no (longer) part of the workflow.
            They could be reviews with a type that does not match the type
            of the contribution, or reviews that have been superseded by newer
            reviews.

        Parameters
        ----------
        table: string
            Either `review` or `reviewEntry`.
        record: dict
            Either a `review` record or a `reviewEntry` record.

        Returns
        -------
        string {`expert`, `final`}
            Or `None`.
        &#34;&#34;&#34;

        if table in {N.review, N.reviewEntry}:
            eid = G(record, N._id) if table == N.review else G(record, N.review)
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            kind = (
                N.expert
                if G(G(reviews, N.expert), N._id) == eid
                else N.final
                if G(G(reviews, N.final), N._id) == eid
                else None
            )
        else:
            kind = None
        return kind

    def isValid(self, table, eid, record):
        &#34;&#34;&#34;Is a record a valid part of the workflow?

        Valid parts are contributions, assessment and review detail records of
        contributions satisfying:

        *   they have the same type as their master contribution
        *   they are not superseded by other assessments or reviews
            with the correct type

        Parameters
        ----------
        table: string {`review`, `assessment`, `criteriaEntry`, `reviewEntry`}.
        eid: ObjectId
            (Entity) id of the record to be validated.
        record: dict
            The full record to be validated.
            Only needed for `reviewEntry` and `criteriaEntry` in order to look
            up the master `review` or `assessment` record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        if eid is None:
            return False

        refId = (
            G(record, N.assessment)
            if table == N.criteriaEntry
            else G(record, N.review)
            if table == N.reviewEntry
            else eid
        )
        if refId is None:
            return False

        if table in {N.contrib, N.assessment, N.criteriaEntry}:
            data = self.getWf(table)
            return refId == G(data, N._id)
        elif table in {N.review, N.reviewEntry}:
            data = self.getWf(N.assessment)
            reviews = G(data, N.reviews, default={})
            return refId in {
                G(reviewInfo, N._id) for (kind, reviewInfo) in reviews.items()
            }

    def info(self, table, *atts, kind=None):
        &#34;&#34;&#34;Retrieve selected attributes of the workflow

        A workflow record contains attributes at the outermost level,
        but also within its enclosed assessment workflow record and
        the enclosed review workflow records.

        Parameters
        ----------
        table: string
            In order to read attributes, we must specify the source of those
            attributes: `contrib` (outermost), `assessment` or `review`.
        *atts: iterable
            The workflow attribute names to fetch.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        generator
            Yields attribute values, corresponding to `*atts`.
        &#34;&#34;&#34;

        thisData = self.getWf(table, kind=kind)
        return (G(thisData, att) for att in atts)

    def checkReadable(self, recordObj):
        &#34;&#34;&#34;Whether a record is readable because of workflow.

        When a contribution, assessment, review is in a certain stage
        in the workflow, its record may be closed to others than the owner, and
        after finalization,  some fields may be open to authenticated users or
        the public.

        This method determines the record is readable by the current user.

        If the record is not part of the workflow, `None` is returned, and
        the normal permission rules apply.

        !!! note
            It also depends on the current user.
            Power users will not be prevented to read records because of
            workflow conditions.

        Here are the rules:

        #### Assessment, Criteria Entry

        Not submitted:
        : authors and editors only

        Submitted, review not yet complete, or negative outcome
        :   authors, editors, reviewers, national coordinator only

        Review with positive outcome
        :   public

        Negative outcome
        :   authors, editors, reviewers, national coordinator only

        #### Review, Review Entry

        Review has no decision and there is no final decision
        :   authors, editors

        Review in question has a decision, but still no final positive decision
        :   authors/editors, other reviewer, authors/editors of the assessment,
            national coordinator

        There is a positive final decision
        :   public

        !!! caution &#34;The influence of selection is nihil&#34;
            Whether a contribution is selected or not has no influence on the
            readability of the assessment and review.

        !!! caution &#34;The influence on the contribution records is nihil&#34;
            Whether a contribution is readable does not depend on the
            workflow, only on the normal rules.

        Parameters
        ----------
        recordObj: object
            The record in question (from which the table and the kind
            maybe inferred. It should be the record that contains this
            WorkflowItem object as its `wfitem` attribute.
        field: string, optional `None`
            If None, we check for the readability of the record as a whole.
            Otherwise, we check for the readability of this field in the record.

        Returns
        -------
        boolean | `None`
        &#34;&#34;&#34;

        isSuperuser = self.isSuperuser
        if isSuperuser:
            return None

        table = recordObj.table
        if table not in SENSITIVE_TABLES:
            return None

        kind = recordObj.kind
        perm = recordObj.perm
        uid = self.uid

        (done, stage) = self.info(table, N.done, N.stage, kind=kind)

        if table in {N.assessment, N.criteriaEntry}:
            (rStage,) = self.info(N.review, N.stage, kind=N.final)
            return (
                True
                if rStage == N.reviewAccept
                else perm[N.isOur]
                if stage in {N.submitted, N.submittedRevised}
                else perm[N.isEdit]
            )

        if table in {N.review, N.reviewEntry}:
            (creators,) = self.info(N.assessment, N.creators)
            (rStage,) = self.info(N.review, N.stage, kind=N.final)
            result = (
                True
                if rStage == N.reviewAccept
                else uid in creators or perm[N.isOur]
                if stage
                in {
                    N.reviewAdviseRevise,
                    N.reviewAdviseAccept,
                    N.reviewAdviseReject,
                    N.reviewRevise,
                    N.reviewReject,
                }
                or rStage in {N.reviewRevise, N.reviewReject}
                else perm[N.isEdit]
            )
            return result
        return None

    def checkFixed(self, recordObj, field=None):
        &#34;&#34;&#34;Whether a record or field is fixed because of workflow.

        When a contribution, assessment, review is in a certain stage
        in the workflow, its record or some fields in its record may be
        fixated, either temporarily or permanently.

        This method checks whether a record or field is currently fixed,
        i.e. whether editing is possible.

        !!! note
            It might also depend on the current user.

        !!! caution
            Here is a case where the sysadmin and the root are less powerful
            than the office users: only the office users can assign reviewers,
            i.e. only they can update `reviewerE` and `reviewerF` inn assessment fields.

        Parameters
        ----------
        recordObj: object
            The record in question (from which the table and the kind
            maybe inferred. It should be the record that contains this
            WorkflowItem object as its `wfitem` attribute.
        field: string, optional `None`
            If None, we check for the fixity of the record as a whole.
            Otherwise, we check for the fixity of this field in the record.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        auth = self.auth
        table = recordObj.table
        kind = recordObj.kind

        (frozen, done, locked) = self.info(table, N.frozen, N.done, N.locked, kind=kind)

        if field is None:
            return frozen or done or locked

        if frozen or done:
            return True

        if not locked:
            return False

        isOffice = auth.officeuser()
        if isOffice and table == N.assessment:
            return field not in {N.reviewerE, N.reviewerF}

        return True

    def permission(self, task, kind=None):
        &#34;&#34;&#34;Checks whether a workflow task is permitted.

        Note that the tasks are listed per kind of record they apply to:
        contrib, assessment, review.
        They are typically triggered by big workflow buttons on the interface.

        When the request to execute such a task reaches the server, it will
        check whether the current user is allowed to execute this task
        on the records in question.

        !!! hint
            See above for explanation of the properties of the tasks.

        !!! note
            If you try to run a task on a kind of record that it is not
            designed for, it will be detected and no permission will be given.

        !!! note
            Some tasks are designed to set a field to a value.
            If that field already has that value, the task will not be permitted.
            This already rules out a lot of things and relieves the burden of
            prohibiting non-sensical tasks.

        It may be that the task is only permitted for some limited time from now on.
        Then a timedelta object with the amount of time left is returned.

        Parameters
        ----------
        table: string
            In order to check permissions, we must specify the kind of record that
            the task acts on: contrib, assessment, or review.
        task: string
            An string consisting of the name of a task.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        boolean | timedelta
        &#34;&#34;&#34;

        db = self.db
        auth = self.auth
        uid = self.uid

        if task not in TASKS:
            return False

        taskInfo = TASKS[task]
        table = G(taskInfo, N.table)

        if uid is None or table not in USER_TABLES:
            return False

        taskField = (
            N.selected
            if table == N.contrib
            else N.submitted
            if table == N.assessment
            else N.decision
            if table == N.review
            else None
        )
        myKind = self.myKind

        (
            locked,
            done,
            frozen,
            mayAdd,
            stage,
            stageDate,
            creators,
            countryId,
            taskValue,
        ) = self.info(
            table,
            N.locked,
            N.done,
            N.frozen,
            N.mayAdd,
            N.stage,
            N.stageDate,
            N.creators,
            N.country,
            taskField,
            kind=kind,
        )

        operator = G(taskInfo, N.operator)
        value = G(taskInfo, N.value)
        if operator == N.set:
            if taskField == N.decision:
                value = G(db.decisionInv, value)
            if value == taskValue:
                return False

        (contribId,) = self.info(N.contrib, N._id)

        isOwn = uid in creators
        isCoord = countryId and auth.coordinator(countryId=countryId)
        isSuper = auth.superuser()

        decisionDelay = G(taskInfo, N.delay)
        if decisionDelay:
            decisionDelay = timedelta(hours=decisionDelay)

        justNow = now()
        remaining = False
        if decisionDelay and stageDate:
            remaining = stageDate + decisionDelay - justNow
            if remaining &lt;= timedelta(hours=0):
                remaining = False

        if frozen and not remaining:
            return False

        if table == N.contrib:
            if not isOwn and not isCoord and not isSuper:
                return False

            if task == N.startAssessment:
                return isOwn and mayAdd and not frozen and not done

            if not isCoord:
                return False

            answer = not frozen or remaining

            if task == N.selectContrib:
                return stage != N.selectYes and answer

            if task == N.deselectContrib:
                return stage != N.selectNo and answer

            if task == N.unselectContrib:
                return stage != N.selectNone and answer

            return False

        if (frozen or done) and not remaining:
            return False

        if table == N.assessment:
            if task == N.startReview:
                return G(mayAdd, myKind)

            if uid not in creators:
                return False

            answer = not locked or remaining
            if not answer:
                return False

            if task == N.submitAssessment:
                return stage == N.complete and answer

            if task == N.resubmitAssessment:
                return stage == N.completeWithdrawn and answer

            if task == N.submitRevised:
                return stage == N.completeRevised and answer

            if task == N.withdrawAssessment:
                return (
                    stage in {N.submitted, N.submittedRevised}
                    and stage not in {N.incompleteWithdrawn, N.completeWithdrawn}
                    and answer
                )

            return False

        if table == N.review:
            taskKind = G(taskInfo, N.kind)
            if not kind or kind != taskKind or kind != myKind:
                return False

            answer = remaining or not locked or remaining
            if not answer:
                return False

            if task in {
                N.expertReviewRevise,
                N.expertReviewAccept,
                N.expertReviewReject,
            }:
                return kind == N.expert and answer

            if task in {
                N.finalReviewRevise,
                N.finalReviewAccept,
                N.finalReviewReject,
            }:
                (expertStage,) = self.info(table, N.stage, kind=N.expert)
                return kind == N.final and not not expertStage and answer

            return False

        return False

    def stage(self, table, kind=None):
        &#34;&#34;&#34;Find the workflow stage that a record is in.

        !!! hint
            See above for a description of the stages.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string {`selectYes`, `submittedRevised`, `reviewAccept`, ...}
            See above for the complete list.
        &#34;&#34;&#34;

        return list(self.info(table, N.stage, kind=kind))[0]

    def creators(self, table, kind=None):
        &#34;&#34;&#34;Find the creators from a workflow related record.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the creators:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        (list of ObjectId)
        &#34;&#34;&#34;

        return list(self.info(table, N.creators, kind=kind))[0]

    def status(self, table, kind=None):
        &#34;&#34;&#34;Present all workflow info and controls relevant to the record.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to see the status:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        eid = list(self.info(table, N._id, kind=kind))[0]
        itemKey = f&#34;&#34;&#34;{table}/{eid}&#34;&#34;&#34;
        rButton = H.iconr(itemKey, &#34;#workflow&#34;, msg=N.status)

        return H.div(
            [
                rButton,
                self.statusOverview(table, kind=kind),
                self.tasks(table, kind=kind),
            ],
            cls=f&#34;workflow&#34;,
        )

    @staticmethod
    def isTask(table, field):
        &#34;&#34;&#34;Whether a field in a record is involved in a workflow task.

        Fields that are involved in workflow tasks can not be read or edited
        directly:

        *   they are represented as workflow status, not as a value
            (see `control.workflow.apply.WorkflowItem.status`);
        *   they only change as a result of a  workflow task
            (see `control.workflow.apply.WorkflowItem.doTask`).

        !!! hint
            Workflow tasks are described above.

        !!! caution
            If a record is not a valid part of a workflow, then all its fields
            are represented and actionable in the normal way.

        Parameters
        ----------
        table: string
            The table in question.
        field: string
            The field in question.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        taskFields = G(TASK_FIELDS, table, default=set())
        return field in taskFields

    def doTask(self, task, recordObj):
        &#34;&#34;&#34;Execute a workflow task on a record.

        The permission to execute the task will be checked first.

        !!! hint
            Workflow tasks are described above.

        Parameters
        ----------
        recordObj: object
            The record must be passed as a record object.

        Returns
        -------
        url | `None`
            To navigate to after the action has been performed.
            If the action has not been performed, `None` is returned.
        &#34;&#34;&#34;

        context = recordObj.context
        table = recordObj.table
        eid = recordObj.eid
        kind = recordObj.kind
        (contribId,) = self.info(N.contrib, N._id)

        taskInfo = G(TASKS, task)
        acro = G(taskInfo, N.acro)

        urlExtra = E

        done = False
        if self.permission(task, kind=kind):
            operator = G(taskInfo, N.operator)
            if operator == N.add:
                dtable = G(taskInfo, N.detail)
                tableObj = mkTable(context, dtable)
                deid = tableObj.insert(masterTable=table, masterId=eid, force=True) or E
                if deid:
                    urlExtra = f&#34;&#34;&#34;/{N.open}/{dtable}/{deid}&#34;&#34;&#34;
                    done = True
            elif operator == N.set:
                field = G(taskInfo, N.field)
                value = G(taskInfo, N.value)
                if recordObj.field(field, mayEdit=True).save(value):
                    done = True
            if done:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; done&#34;&#34;&#34;, &#34;message&#34;)
            else:
                flash(f&#34;&#34;&#34;&lt;{acro}&gt; failed&#34;&#34;&#34;, &#34;error&#34;)
        else:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; not permitted&#34;&#34;&#34;, &#34;error&#34;)

        return f&#34;&#34;&#34;/{N.contrib}/{N.item}/{contribId}{urlExtra}&#34;&#34;&#34; if done else None

    def statusOverview(self, table, kind=None):
        &#34;&#34;&#34;Present the current status of a record on the interface.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want to present the stage:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        (stage, stageDate, locked, done, frozen, score, eid) = self.info(
            table,
            N.stage,
            N.stageDate,
            N.locked,
            N.done,
            N.frozen,
            N.score,
            N._id,
            kind=kind,
        )
        stageInfo = G(STAGE_ATTS, stage)
        statusCls = G(stageInfo, N.cls)
        stageOn = (
            H.span(f&#34;&#34;&#34; on {datetime.toDisplay(stageDate)}&#34;&#34;&#34;, cls=&#34;date&#34;)
            if stageDate
            else E
        )
        statusMsg = H.span(
            [G(stageInfo, N.msg) or E, stageOn], cls=f&#34;large status {statusCls}&#34;
        )
        lockedCls = N.locked if locked else E
        lockedMsg = (
            H.span(G(STATUS_REP, N.locked), cls=f&#34;large status {lockedCls}&#34;)
            if locked
            else E
        )
        doneCls = N.done if done else E
        doneMsg = (
            H.span(G(STATUS_REP, N.done), cls=f&#34;large status {doneCls}&#34;) if done else E
        )
        frozenCls = N.frozen if frozen else E
        frozenMsg = (
            H.span(G(STATUS_REP, N.frozen), cls=f&#34;large status info&#34;) if frozen else E
        )

        statusRep = f&#34;&lt;!-- stage:{stage} --&gt;&#34; + H.div(
            [statusMsg, lockedMsg, doneMsg, frozenMsg], cls=frozenCls
        )

        scorePart = E
        if table == N.assessment:
            scoreParts = presentScore(score, eid)
            scorePart = (
                H.span(scoreParts)
                if table == N.assessment
                else (scoreParts[0] if scoreParts else E)
                if table == N.contrib
                else E
            )

        return H.div([statusRep, scorePart], cls=&#34;workflow-line&#34;)

    def tasks(self, table, kind=None):
        &#34;&#34;&#34;Present the currently available tasks as buttons on the interface.

        !!! hint &#34;easy comments&#34;
            We also include a comment `&lt;!-- task~!taskName:eid --&gt;
            for the ease of testing.

        Parameters
        ----------
        table: string
            We must specify the table for which we want to present the
            tasks: contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        uid = self.uid

        if not uid or table not in USER_TABLES:
            return E

        eid = list(self.info(table, N._id, kind=kind))[0]
        taskParts = []

        allowedTasks = sorted(
            (task, taskInfo)
            for (task, taskInfo) in TASKS.items()
            if G(taskInfo, N.table) == table
        )
        justNow = now()

        for (task, taskInfo) in allowedTasks:
            permitted = self.permission(task, kind=kind)
            if not permitted:
                continue

            remaining = type(permitted) is timedelta and permitted
            taskUntil = E
            if remaining:
                remainingRep = datetime.toDisplay(justNow + remaining)
                taskUntil = H.span(f&#34;&#34;&#34; before {remainingRep}&#34;&#34;&#34;, cls=&#34;datex&#34;)
            taskMsg = G(taskInfo, N.msg)
            taskCls = G(taskInfo, N.cls)

            taskPart = H.a(
                [taskMsg, taskUntil],
                f&#34;&#34;&#34;/api/task/{task}/{eid}&#34;&#34;&#34;,
                cls=f&#34;large task {taskCls}&#34;,
            ) + f&#34;&#34;&#34;&lt;!-- task!{task}:{eid} --&gt;&#34;&#34;&#34;
            taskParts.append(taskPart)

        return H.join(taskParts)

    def getWf(self, table, kind=None):
        &#34;&#34;&#34;Select a source of attributes within a workflow item.

        Parameters
        ----------
        table: string
            We must specify the kind of record for which we want the attributes:
            contrib, assessment, or review.
        kind: string {`expert`, `final`}, optional `None`
            Only if we want review attributes

        Returns
        -------
        dict
        &#34;&#34;&#34;

        data = self.data
        if table == N.contrib:
            return data

        data = G(data, N.assessment)
        if table in {N.assessment, N.criteriaEntry}:
            return data

        if table in {N.review, N.reviewEntry}:
            data = G(G(data, N.reviews), kind)
            return data

        return None

    def myReviewerKind(self, reviewer=None):
        &#34;&#34;&#34;Determine whether the current user is `expert` or `final`.

        Parameters
        ----------
        reviewer: dict, optional `None`
            If absent, the assessment in the workflow info will be inspected
            to get a dict of its reviewers by kind.
            Otherwise, it should be a dict of user ids keyed by `expert` and
            `final`.

        Returns
        -------
        string {`expert`, `final`} | `None`
            Depending on whether the current user is such a reviewer of the
            assessment of this contribution. Or `None` if (s)he is not a reviewer
            at all.
        &#34;&#34;&#34;
        uid = self.uid

        if reviewer is None:
            reviewer = G(self.getWf(N.assessment), N.reviewer)

        return (
            N.expert
            if G(reviewer, N.expert) == uid
            else N.final
            if G(reviewer, N.final) == uid
            else None
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="control.workflow.apply.WorkflowItem.isTask"><code class="name flex">
<span>def <span class="ident">isTask</span></span>(<span>table, field)</span>
</code></dt>
<dd>
<section class="desc"><p>Whether a field in a record is involved in a workflow task.</p>
<p>Fields that are involved in workflow tasks can not be read or edited
directly:</p>
<ul>
<li>they are represented as workflow status, not as a value
(see <a title="control.workflow.apply.WorkflowItem.status" href="#control.workflow.apply.WorkflowItem.status"><code>WorkflowItem.status()</code></a>);</li>
<li>they only change as a result of a
workflow task
(see <a title="control.workflow.apply.WorkflowItem.doTask" href="#control.workflow.apply.WorkflowItem.doTask"><code>WorkflowItem.doTask()</code></a>).</li>
</ul>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Workflow tasks are described above.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>If a record is not a valid part of a workflow, then all its fields
are represented and actionable in the normal way.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table in question.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>The field in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isTask(table, field):
    &#34;&#34;&#34;Whether a field in a record is involved in a workflow task.

    Fields that are involved in workflow tasks can not be read or edited
    directly:

    *   they are represented as workflow status, not as a value
        (see `control.workflow.apply.WorkflowItem.status`);
    *   they only change as a result of a  workflow task
        (see `control.workflow.apply.WorkflowItem.doTask`).

    !!! hint
        Workflow tasks are described above.

    !!! caution
        If a record is not a valid part of a workflow, then all its fields
        are represented and actionable in the normal way.

    Parameters
    ----------
    table: string
        The table in question.
    field: string
        The field in question.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    taskFields = G(TASK_FIELDS, table, default=set())
    return field in taskFields</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="control.workflow.apply.WorkflowItem.auth"><code class="name">var <span class="ident">auth</span></code></dt>
<dd>
<section class="desc"><p><em>object</em> The <a title="control.auth.Auth" href="../auth.html#control.auth.Auth"><code>Auth</code></a> singleton</p>
<p>Provides methods to access the attributes of the current user.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"><p><em>dict</em> The
workflow attributes.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.db"><code class="name">var <span class="ident">db</span></code></dt>
<dd>
<section class="desc"><p><em>object</em> The <a title="control.db.Db" href="../db.html#control.db.Db"><code>Db</code></a> singleton</p>
<p>Provides methods to deal with values
from the table <code>decision</code>.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.eppn"><code class="name">var <span class="ident">eppn</span></code></dt>
<dd>
<section class="desc"><p><em>ObjectId</em> The eppn of the current user.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>The eppn is the user identifying attribute from the identity provider.</p>
</div></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.isSuperuser"><code class="name">var <span class="ident">isSuperuser</span></code></dt>
<dd>
<section class="desc"><p><em>boolean</em> Whether the current user is a superuser.</p>
<p>See <a title="control.auth.Auth.superuser" href="../auth.html#control.auth.Auth.superuser"><code>Auth.superuser()</code></a>.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.myKind"><code class="name">var <span class="ident">myKind</span></code></dt>
<dd>
<section class="desc"><p><em>dict</em> The kind of reviewer that the current user is.</p>
<p>A user is <code>expert</code> reviewer or <code>final</code> reviewer, or <code>None</code>.</p></section>
</dd>
<dt id="control.workflow.apply.WorkflowItem.uid"><code class="name">var <span class="ident">uid</span></code></dt>
<dd>
<section class="desc"><p><em>ObjectId</em> The id of the current user.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.workflow.apply.WorkflowItem.checkFixed"><code class="name flex">
<span>def <span class="ident">checkFixed</span></span>(<span>self, recordObj, field=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Whether a record or field is fixed because of workflow.</p>
<p>When a contribution, assessment, review is in a certain stage
in the workflow, its record or some fields in its record may be
fixated, either temporarily or permanently.</p>
<p>This method checks whether a record or field is currently fixed,
i.e. whether editing is possible.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It might also depend on the current user.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Here is a case where the sysadmin and the root are less powerful
than the office users: only the office users can assign reviewers,
i.e. only they can update <code>reviewerE</code> and <code>reviewerF</code> inn assessment fields.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recordObj</code></strong> :&ensp;<code>object</code></dt>
<dd>The record in question (from which the table and the kind
maybe inferred. It should be the record that contains this
WorkflowItem object as its <code>wfitem</code> attribute.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If None, we check for the fixity of the record as a whole.
Otherwise, we check for the fixity of this field in the record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkFixed(self, recordObj, field=None):
    &#34;&#34;&#34;Whether a record or field is fixed because of workflow.

    When a contribution, assessment, review is in a certain stage
    in the workflow, its record or some fields in its record may be
    fixated, either temporarily or permanently.

    This method checks whether a record or field is currently fixed,
    i.e. whether editing is possible.

    !!! note
        It might also depend on the current user.

    !!! caution
        Here is a case where the sysadmin and the root are less powerful
        than the office users: only the office users can assign reviewers,
        i.e. only they can update `reviewerE` and `reviewerF` inn assessment fields.

    Parameters
    ----------
    recordObj: object
        The record in question (from which the table and the kind
        maybe inferred. It should be the record that contains this
        WorkflowItem object as its `wfitem` attribute.
    field: string, optional `None`
        If None, we check for the fixity of the record as a whole.
        Otherwise, we check for the fixity of this field in the record.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    auth = self.auth
    table = recordObj.table
    kind = recordObj.kind

    (frozen, done, locked) = self.info(table, N.frozen, N.done, N.locked, kind=kind)

    if field is None:
        return frozen or done or locked

    if frozen or done:
        return True

    if not locked:
        return False

    isOffice = auth.officeuser()
    if isOffice and table == N.assessment:
        return field not in {N.reviewerE, N.reviewerF}

    return True</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.checkReadable"><code class="name flex">
<span>def <span class="ident">checkReadable</span></span>(<span>self, recordObj)</span>
</code></dt>
<dd>
<section class="desc"><p>Whether a record is readable because of workflow.</p>
<p>When a contribution, assessment, review is in a certain stage
in the workflow, its record may be closed to others than the owner, and
after finalization,
some fields may be open to authenticated users or
the public.</p>
<p>This method determines the record is readable by the current user.</p>
<p>If the record is not part of the workflow, <code>None</code> is returned, and
the normal permission rules apply.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It also depends on the current user.
Power users will not be prevented to read records because of
workflow conditions.</p>
</div>
<p>Here are the rules:</p>
<h4 id="assessment-criteria-entry">Assessment, Criteria Entry</h4>
<dl>
<dt>Not submitted:</dt>
<dd>authors and editors only</dd>
<dt>Submitted, review not yet complete, or negative outcome</dt>
<dd>authors, editors, reviewers, national coordinator only</dd>
<dt>Review with positive outcome</dt>
<dd>public</dd>
<dt>Negative outcome</dt>
<dd>authors, editors, reviewers, national coordinator only</dd>
</dl>
<h4 id="review-review-entry">Review, Review Entry</h4>
<dl>
<dt>Review has no decision and there is no final decision</dt>
<dd>authors, editors</dd>
<dt>Review in question has a decision, but still no final positive decision</dt>
<dd>authors/editors, other reviewer, authors/editors of the assessment,
national coordinator</dd>
<dt>There is a positive final decision</dt>
<dd>public</dd>
</dl>
<div class="admonition caution">
<p class="admonition-title">The influence of selection is nihil</p>
<p>Whether a contribution is selected or not has no influence on the
readability of the assessment and review.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">The influence on the contribution records is nihil</p>
<p>Whether a contribution is readable does not depend on the
workflow, only on the normal rules.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recordObj</code></strong> :&ensp;<code>object</code></dt>
<dd>The record in question (from which the table and the kind
maybe inferred. It should be the record that contains this
WorkflowItem object as its <code>wfitem</code> attribute.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If None, we check for the readability of the record as a whole.
Otherwise, we check for the readability of this field in the record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>boolean | <code>None</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkReadable(self, recordObj):
    &#34;&#34;&#34;Whether a record is readable because of workflow.

    When a contribution, assessment, review is in a certain stage
    in the workflow, its record may be closed to others than the owner, and
    after finalization,  some fields may be open to authenticated users or
    the public.

    This method determines the record is readable by the current user.

    If the record is not part of the workflow, `None` is returned, and
    the normal permission rules apply.

    !!! note
        It also depends on the current user.
        Power users will not be prevented to read records because of
        workflow conditions.

    Here are the rules:

    #### Assessment, Criteria Entry

    Not submitted:
    : authors and editors only

    Submitted, review not yet complete, or negative outcome
    :   authors, editors, reviewers, national coordinator only

    Review with positive outcome
    :   public

    Negative outcome
    :   authors, editors, reviewers, national coordinator only

    #### Review, Review Entry

    Review has no decision and there is no final decision
    :   authors, editors

    Review in question has a decision, but still no final positive decision
    :   authors/editors, other reviewer, authors/editors of the assessment,
        national coordinator

    There is a positive final decision
    :   public

    !!! caution &#34;The influence of selection is nihil&#34;
        Whether a contribution is selected or not has no influence on the
        readability of the assessment and review.

    !!! caution &#34;The influence on the contribution records is nihil&#34;
        Whether a contribution is readable does not depend on the
        workflow, only on the normal rules.

    Parameters
    ----------
    recordObj: object
        The record in question (from which the table and the kind
        maybe inferred. It should be the record that contains this
        WorkflowItem object as its `wfitem` attribute.
    field: string, optional `None`
        If None, we check for the readability of the record as a whole.
        Otherwise, we check for the readability of this field in the record.

    Returns
    -------
    boolean | `None`
    &#34;&#34;&#34;

    isSuperuser = self.isSuperuser
    if isSuperuser:
        return None

    table = recordObj.table
    if table not in SENSITIVE_TABLES:
        return None

    kind = recordObj.kind
    perm = recordObj.perm
    uid = self.uid

    (done, stage) = self.info(table, N.done, N.stage, kind=kind)

    if table in {N.assessment, N.criteriaEntry}:
        (rStage,) = self.info(N.review, N.stage, kind=N.final)
        return (
            True
            if rStage == N.reviewAccept
            else perm[N.isOur]
            if stage in {N.submitted, N.submittedRevised}
            else perm[N.isEdit]
        )

    if table in {N.review, N.reviewEntry}:
        (creators,) = self.info(N.assessment, N.creators)
        (rStage,) = self.info(N.review, N.stage, kind=N.final)
        result = (
            True
            if rStage == N.reviewAccept
            else uid in creators or perm[N.isOur]
            if stage
            in {
                N.reviewAdviseRevise,
                N.reviewAdviseAccept,
                N.reviewAdviseReject,
                N.reviewRevise,
                N.reviewReject,
            }
            or rStage in {N.reviewRevise, N.reviewReject}
            else perm[N.isEdit]
        )
        return result
    return None</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.creators"><code class="name flex">
<span>def <span class="ident">creators</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the creators from a workflow related record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to see the creators:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(list of ObjectId)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creators(self, table, kind=None):
    &#34;&#34;&#34;Find the creators from a workflow related record.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to see the creators:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    (list of ObjectId)
    &#34;&#34;&#34;

    return list(self.info(table, N.creators, kind=kind))[0]</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.doTask"><code class="name flex">
<span>def <span class="ident">doTask</span></span>(<span>self, task, recordObj)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute a workflow task on a record.</p>
<p>The permission to execute the task will be checked first.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Workflow tasks are described above.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recordObj</code></strong> :&ensp;<code>object</code></dt>
<dd>The record must be passed as a record object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>url | <code>None</code>
To navigate to after the action has been performed.
If the action has not been performed, <code>None</code> is returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doTask(self, task, recordObj):
    &#34;&#34;&#34;Execute a workflow task on a record.

    The permission to execute the task will be checked first.

    !!! hint
        Workflow tasks are described above.

    Parameters
    ----------
    recordObj: object
        The record must be passed as a record object.

    Returns
    -------
    url | `None`
        To navigate to after the action has been performed.
        If the action has not been performed, `None` is returned.
    &#34;&#34;&#34;

    context = recordObj.context
    table = recordObj.table
    eid = recordObj.eid
    kind = recordObj.kind
    (contribId,) = self.info(N.contrib, N._id)

    taskInfo = G(TASKS, task)
    acro = G(taskInfo, N.acro)

    urlExtra = E

    done = False
    if self.permission(task, kind=kind):
        operator = G(taskInfo, N.operator)
        if operator == N.add:
            dtable = G(taskInfo, N.detail)
            tableObj = mkTable(context, dtable)
            deid = tableObj.insert(masterTable=table, masterId=eid, force=True) or E
            if deid:
                urlExtra = f&#34;&#34;&#34;/{N.open}/{dtable}/{deid}&#34;&#34;&#34;
                done = True
        elif operator == N.set:
            field = G(taskInfo, N.field)
            value = G(taskInfo, N.value)
            if recordObj.field(field, mayEdit=True).save(value):
                done = True
        if done:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; done&#34;&#34;&#34;, &#34;message&#34;)
        else:
            flash(f&#34;&#34;&#34;&lt;{acro}&gt; failed&#34;&#34;&#34;, &#34;error&#34;)
    else:
        flash(f&#34;&#34;&#34;&lt;{acro}&gt; not permitted&#34;&#34;&#34;, &#34;error&#34;)

    return f&#34;&#34;&#34;/{N.contrib}/{N.item}/{contribId}{urlExtra}&#34;&#34;&#34; if done else None</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.getKind"><code class="name flex">
<span>def <span class="ident">getKind</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine whether a review(Entry) is <code>expert</code> or <code>final</code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The value <code>None</code> (not a string!) is returned for reviews that are
no (longer) part of the workflow.
They could be reviews with a type that does not match the type
of the contribution, or reviews that have been superseded by newer
reviews.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Either <code>review</code> or <code>reviewEntry</code>.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>dict</code></dt>
<dd>Either a <code>review</code> record or a <code>reviewEntry</code> record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>string {<code>expert</code>, <code>final</code>}
Or <code>None</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKind(self, table, record):
    &#34;&#34;&#34;Determine whether a review(Entry) is `expert` or `final`.

    !!! warning
        The value `None` (not a string!) is returned for reviews that are
        no (longer) part of the workflow.
        They could be reviews with a type that does not match the type
        of the contribution, or reviews that have been superseded by newer
        reviews.

    Parameters
    ----------
    table: string
        Either `review` or `reviewEntry`.
    record: dict
        Either a `review` record or a `reviewEntry` record.

    Returns
    -------
    string {`expert`, `final`}
        Or `None`.
    &#34;&#34;&#34;

    if table in {N.review, N.reviewEntry}:
        eid = G(record, N._id) if table == N.review else G(record, N.review)
        data = self.getWf(N.assessment)
        reviews = G(data, N.reviews, default={})
        kind = (
            N.expert
            if G(G(reviews, N.expert), N._id) == eid
            else N.final
            if G(G(reviews, N.final), N._id) == eid
            else None
        )
    else:
        kind = None
    return kind</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.getWf"><code class="name flex">
<span>def <span class="ident">getWf</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Select a source of attributes within a workflow item.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want the attributes:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWf(self, table, kind=None):
    &#34;&#34;&#34;Select a source of attributes within a workflow item.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want the attributes:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    dict
    &#34;&#34;&#34;

    data = self.data
    if table == N.contrib:
        return data

    data = G(data, N.assessment)
    if table in {N.assessment, N.criteriaEntry}:
        return data

    if table in {N.review, N.reviewEntry}:
        data = G(G(data, N.reviews), kind)
        return data

    return None</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, table, *atts, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve selected attributes of the workflow</p>
<p>A workflow record contains attributes at the outermost level,
but also within its enclosed assessment workflow record and
the enclosed review workflow records.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>In order to read attributes, we must specify the source of those
attributes: <code>contrib</code> (outermost), <code>assessment</code> or <code>review</code>.</dd>
<dt><strong><code>*atts</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The workflow attribute names to fetch.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>generator</code></dt>
<dd>Yields attribute values, corresponding to <code>*atts</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, table, *atts, kind=None):
    &#34;&#34;&#34;Retrieve selected attributes of the workflow

    A workflow record contains attributes at the outermost level,
    but also within its enclosed assessment workflow record and
    the enclosed review workflow records.

    Parameters
    ----------
    table: string
        In order to read attributes, we must specify the source of those
        attributes: `contrib` (outermost), `assessment` or `review`.
    *atts: iterable
        The workflow attribute names to fetch.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    generator
        Yields attribute values, corresponding to `*atts`.
    &#34;&#34;&#34;

    thisData = self.getWf(table, kind=kind)
    return (G(thisData, att) for att in atts)</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.isValid"><code class="name flex">
<span>def <span class="ident">isValid</span></span>(<span>self, table, eid, record)</span>
</code></dt>
<dd>
<section class="desc"><p>Is a record a valid part of the workflow?</p>
<p>Valid parts are contributions, assessment and review detail records of
contributions satisfying:</p>
<ul>
<li>they have the same type as their master contribution</li>
<li>they are not superseded by other assessments or reviews
with the correct type</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>table: string {<code>review</code>, <code>assessment</code>, <code>criteriaEntry</code>, <code>reviewEntry</code>}.</dt>
<dt><strong><code>eid</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>(Entity) id of the record to be validated.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>dict</code></dt>
<dd>The full record to be validated.
Only needed for <code>reviewEntry</code> and <code>criteriaEntry</code> in order to look
up the master <code>review</code> or <code>assessment</code> record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isValid(self, table, eid, record):
    &#34;&#34;&#34;Is a record a valid part of the workflow?

    Valid parts are contributions, assessment and review detail records of
    contributions satisfying:

    *   they have the same type as their master contribution
    *   they are not superseded by other assessments or reviews
        with the correct type

    Parameters
    ----------
    table: string {`review`, `assessment`, `criteriaEntry`, `reviewEntry`}.
    eid: ObjectId
        (Entity) id of the record to be validated.
    record: dict
        The full record to be validated.
        Only needed for `reviewEntry` and `criteriaEntry` in order to look
        up the master `review` or `assessment` record.

    Returns
    -------
    boolean
    &#34;&#34;&#34;
    if eid is None:
        return False

    refId = (
        G(record, N.assessment)
        if table == N.criteriaEntry
        else G(record, N.review)
        if table == N.reviewEntry
        else eid
    )
    if refId is None:
        return False

    if table in {N.contrib, N.assessment, N.criteriaEntry}:
        data = self.getWf(table)
        return refId == G(data, N._id)
    elif table in {N.review, N.reviewEntry}:
        data = self.getWf(N.assessment)
        reviews = G(data, N.reviews, default={})
        return refId in {
            G(reviewInfo, N._id) for (kind, reviewInfo) in reviews.items()
        }</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.myReviewerKind"><code class="name flex">
<span>def <span class="ident">myReviewerKind</span></span>(<span>self, reviewer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine whether the current user is <code>expert</code> or <code>final</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reviewer</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>If absent, the assessment in the workflow info will be inspected
to get a dict of its reviewers by kind.
Otherwise, it should be a dict of user ids keyed by <code>expert</code> and
<code>final</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>string {<code>expert</code>, <code>final</code>} | <code>None</code>
Depending on whether the current user is such a reviewer of the
assessment of this contribution. Or <code>None</code> if (s)he is not a reviewer
at all.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def myReviewerKind(self, reviewer=None):
    &#34;&#34;&#34;Determine whether the current user is `expert` or `final`.

    Parameters
    ----------
    reviewer: dict, optional `None`
        If absent, the assessment in the workflow info will be inspected
        to get a dict of its reviewers by kind.
        Otherwise, it should be a dict of user ids keyed by `expert` and
        `final`.

    Returns
    -------
    string {`expert`, `final`} | `None`
        Depending on whether the current user is such a reviewer of the
        assessment of this contribution. Or `None` if (s)he is not a reviewer
        at all.
    &#34;&#34;&#34;
    uid = self.uid

    if reviewer is None:
        reviewer = G(self.getWf(N.assessment), N.reviewer)

    return (
        N.expert
        if G(reviewer, N.expert) == uid
        else N.final
        if G(reviewer, N.final) == uid
        else None
    )</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.permission"><code class="name flex">
<span>def <span class="ident">permission</span></span>(<span>self, task, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether a workflow task is permitted.</p>
<p>Note that the tasks are listed per kind of record they apply to:
contrib, assessment, review.
They are typically triggered by big workflow buttons on the interface.</p>
<p>When the request to execute such a task reaches the server, it will
check whether the current user is allowed to execute this task
on the records in question.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See above for explanation of the properties of the tasks.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you try to run a task on a kind of record that it is not
designed for, it will be detected and no permission will be given.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some tasks are designed to set a field to a value.
If that field already has that value, the task will not be permitted.
This already rules out a lot of things and relieves the burden of
prohibiting non-sensical tasks.</p>
</div>
<p>It may be that the task is only permitted for some limited time from now on.
Then a timedelta object with the amount of time left is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>In order to check permissions, we must specify the kind of record that
the task acts on: contrib, assessment, or review.</dd>
<dt><strong><code>task</code></strong> :&ensp;<code>string</code></dt>
<dd>An string consisting of the name of a task.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code> | <code>timedelta</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permission(self, task, kind=None):
    &#34;&#34;&#34;Checks whether a workflow task is permitted.

    Note that the tasks are listed per kind of record they apply to:
    contrib, assessment, review.
    They are typically triggered by big workflow buttons on the interface.

    When the request to execute such a task reaches the server, it will
    check whether the current user is allowed to execute this task
    on the records in question.

    !!! hint
        See above for explanation of the properties of the tasks.

    !!! note
        If you try to run a task on a kind of record that it is not
        designed for, it will be detected and no permission will be given.

    !!! note
        Some tasks are designed to set a field to a value.
        If that field already has that value, the task will not be permitted.
        This already rules out a lot of things and relieves the burden of
        prohibiting non-sensical tasks.

    It may be that the task is only permitted for some limited time from now on.
    Then a timedelta object with the amount of time left is returned.

    Parameters
    ----------
    table: string
        In order to check permissions, we must specify the kind of record that
        the task acts on: contrib, assessment, or review.
    task: string
        An string consisting of the name of a task.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    boolean | timedelta
    &#34;&#34;&#34;

    db = self.db
    auth = self.auth
    uid = self.uid

    if task not in TASKS:
        return False

    taskInfo = TASKS[task]
    table = G(taskInfo, N.table)

    if uid is None or table not in USER_TABLES:
        return False

    taskField = (
        N.selected
        if table == N.contrib
        else N.submitted
        if table == N.assessment
        else N.decision
        if table == N.review
        else None
    )
    myKind = self.myKind

    (
        locked,
        done,
        frozen,
        mayAdd,
        stage,
        stageDate,
        creators,
        countryId,
        taskValue,
    ) = self.info(
        table,
        N.locked,
        N.done,
        N.frozen,
        N.mayAdd,
        N.stage,
        N.stageDate,
        N.creators,
        N.country,
        taskField,
        kind=kind,
    )

    operator = G(taskInfo, N.operator)
    value = G(taskInfo, N.value)
    if operator == N.set:
        if taskField == N.decision:
            value = G(db.decisionInv, value)
        if value == taskValue:
            return False

    (contribId,) = self.info(N.contrib, N._id)

    isOwn = uid in creators
    isCoord = countryId and auth.coordinator(countryId=countryId)
    isSuper = auth.superuser()

    decisionDelay = G(taskInfo, N.delay)
    if decisionDelay:
        decisionDelay = timedelta(hours=decisionDelay)

    justNow = now()
    remaining = False
    if decisionDelay and stageDate:
        remaining = stageDate + decisionDelay - justNow
        if remaining &lt;= timedelta(hours=0):
            remaining = False

    if frozen and not remaining:
        return False

    if table == N.contrib:
        if not isOwn and not isCoord and not isSuper:
            return False

        if task == N.startAssessment:
            return isOwn and mayAdd and not frozen and not done

        if not isCoord:
            return False

        answer = not frozen or remaining

        if task == N.selectContrib:
            return stage != N.selectYes and answer

        if task == N.deselectContrib:
            return stage != N.selectNo and answer

        if task == N.unselectContrib:
            return stage != N.selectNone and answer

        return False

    if (frozen or done) and not remaining:
        return False

    if table == N.assessment:
        if task == N.startReview:
            return G(mayAdd, myKind)

        if uid not in creators:
            return False

        answer = not locked or remaining
        if not answer:
            return False

        if task == N.submitAssessment:
            return stage == N.complete and answer

        if task == N.resubmitAssessment:
            return stage == N.completeWithdrawn and answer

        if task == N.submitRevised:
            return stage == N.completeRevised and answer

        if task == N.withdrawAssessment:
            return (
                stage in {N.submitted, N.submittedRevised}
                and stage not in {N.incompleteWithdrawn, N.completeWithdrawn}
                and answer
            )

        return False

    if table == N.review:
        taskKind = G(taskInfo, N.kind)
        if not kind or kind != taskKind or kind != myKind:
            return False

        answer = remaining or not locked or remaining
        if not answer:
            return False

        if task in {
            N.expertReviewRevise,
            N.expertReviewAccept,
            N.expertReviewReject,
        }:
            return kind == N.expert and answer

        if task in {
            N.finalReviewRevise,
            N.finalReviewAccept,
            N.finalReviewReject,
        }:
            (expertStage,) = self.info(table, N.stage, kind=N.expert)
            return kind == N.final and not not expertStage and answer

        return False

    return False</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.stage"><code class="name flex">
<span>def <span class="ident">stage</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the workflow stage that a record is in.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See above for a description of the stages.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to see the stage:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>string {<code>selectYes</code>, <code>submittedRevised</code>, <code>reviewAccept</code>, &hellip;}
See above for the complete list.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stage(self, table, kind=None):
    &#34;&#34;&#34;Find the workflow stage that a record is in.

    !!! hint
        See above for a description of the stages.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to see the stage:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string {`selectYes`, `submittedRevised`, `reviewAccept`, ...}
        See above for the complete list.
    &#34;&#34;&#34;

    return list(self.info(table, N.stage, kind=kind))[0]</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Present all workflow info and controls relevant to the record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to see the status:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code>(<code>html</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status(self, table, kind=None):
    &#34;&#34;&#34;Present all workflow info and controls relevant to the record.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to see the status:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    eid = list(self.info(table, N._id, kind=kind))[0]
    itemKey = f&#34;&#34;&#34;{table}/{eid}&#34;&#34;&#34;
    rButton = H.iconr(itemKey, &#34;#workflow&#34;, msg=N.status)

    return H.div(
        [
            rButton,
            self.statusOverview(table, kind=kind),
            self.tasks(table, kind=kind),
        ],
        cls=f&#34;workflow&#34;,
    )</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.statusOverview"><code class="name flex">
<span>def <span class="ident">statusOverview</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Present the current status of a record on the interface.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the kind of record for which we want to present the stage:
contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code>(<code>html</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statusOverview(self, table, kind=None):
    &#34;&#34;&#34;Present the current status of a record on the interface.

    Parameters
    ----------
    table: string
        We must specify the kind of record for which we want to present the stage:
        contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    (stage, stageDate, locked, done, frozen, score, eid) = self.info(
        table,
        N.stage,
        N.stageDate,
        N.locked,
        N.done,
        N.frozen,
        N.score,
        N._id,
        kind=kind,
    )
    stageInfo = G(STAGE_ATTS, stage)
    statusCls = G(stageInfo, N.cls)
    stageOn = (
        H.span(f&#34;&#34;&#34; on {datetime.toDisplay(stageDate)}&#34;&#34;&#34;, cls=&#34;date&#34;)
        if stageDate
        else E
    )
    statusMsg = H.span(
        [G(stageInfo, N.msg) or E, stageOn], cls=f&#34;large status {statusCls}&#34;
    )
    lockedCls = N.locked if locked else E
    lockedMsg = (
        H.span(G(STATUS_REP, N.locked), cls=f&#34;large status {lockedCls}&#34;)
        if locked
        else E
    )
    doneCls = N.done if done else E
    doneMsg = (
        H.span(G(STATUS_REP, N.done), cls=f&#34;large status {doneCls}&#34;) if done else E
    )
    frozenCls = N.frozen if frozen else E
    frozenMsg = (
        H.span(G(STATUS_REP, N.frozen), cls=f&#34;large status info&#34;) if frozen else E
    )

    statusRep = f&#34;&lt;!-- stage:{stage} --&gt;&#34; + H.div(
        [statusMsg, lockedMsg, doneMsg, frozenMsg], cls=frozenCls
    )

    scorePart = E
    if table == N.assessment:
        scoreParts = presentScore(score, eid)
        scorePart = (
            H.span(scoreParts)
            if table == N.assessment
            else (scoreParts[0] if scoreParts else E)
            if table == N.contrib
            else E
        )

    return H.div([statusRep, scorePart], cls=&#34;workflow-line&#34;)</code></pre>
</details>
</dd>
<dt id="control.workflow.apply.WorkflowItem.tasks"><code class="name flex">
<span>def <span class="ident">tasks</span></span>(<span>self, table, kind=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Present the currently available tasks as buttons on the interface.</p>
<div class="admonition hint">
<p class="admonition-title">easy comments</p>
<p>We also include a comment `<!-- task~!taskName:eid -->
for the ease of testing.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>We must specify the table for which we want to present the
tasks: contrib, assessment, or review.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code> {<code>expert</code>, <code>final</code>}, optional <code>None</code></dt>
<dd>Only if we want review attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code>(<code>html</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tasks(self, table, kind=None):
    &#34;&#34;&#34;Present the currently available tasks as buttons on the interface.

    !!! hint &#34;easy comments&#34;
        We also include a comment `&lt;!-- task~!taskName:eid --&gt;
        for the ease of testing.

    Parameters
    ----------
    table: string
        We must specify the table for which we want to present the
        tasks: contrib, assessment, or review.
    kind: string {`expert`, `final`}, optional `None`
        Only if we want review attributes

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    uid = self.uid

    if not uid or table not in USER_TABLES:
        return E

    eid = list(self.info(table, N._id, kind=kind))[0]
    taskParts = []

    allowedTasks = sorted(
        (task, taskInfo)
        for (task, taskInfo) in TASKS.items()
        if G(taskInfo, N.table) == table
    )
    justNow = now()

    for (task, taskInfo) in allowedTasks:
        permitted = self.permission(task, kind=kind)
        if not permitted:
            continue

        remaining = type(permitted) is timedelta and permitted
        taskUntil = E
        if remaining:
            remainingRep = datetime.toDisplay(justNow + remaining)
            taskUntil = H.span(f&#34;&#34;&#34; before {remainingRep}&#34;&#34;&#34;, cls=&#34;datex&#34;)
        taskMsg = G(taskInfo, N.msg)
        taskCls = G(taskInfo, N.cls)

        taskPart = H.a(
            [taskMsg, taskUntil],
            f&#34;&#34;&#34;/api/task/{task}/{eid}&#34;&#34;&#34;,
            cls=f&#34;large task {taskCls}&#34;,
        ) + f&#34;&#34;&#34;&lt;!-- task!{task}:{eid} --&gt;&#34;&#34;&#34;
        taskParts.append(taskPart)

    return H.join(taskParts)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#workflow-tasks">Workflow tasks</a><ul>
<li><a href="#properties-of-workflow-tasks">Properties of workflow tasks</a></li>
</ul>
</li>
<li><a href="#workflow-stages">Workflow stages</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control.workflow" href="index.html">control.workflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="control.workflow.apply.execute" href="#control.workflow.apply.execute">execute</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.workflow.apply.WorkflowItem" href="#control.workflow.apply.WorkflowItem">WorkflowItem</a></code></h4>
<ul class="two-column">
<li><code><a title="control.workflow.apply.WorkflowItem.auth" href="#control.workflow.apply.WorkflowItem.auth">auth</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.checkFixed" href="#control.workflow.apply.WorkflowItem.checkFixed">checkFixed</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.checkReadable" href="#control.workflow.apply.WorkflowItem.checkReadable">checkReadable</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.creators" href="#control.workflow.apply.WorkflowItem.creators">creators</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.data" href="#control.workflow.apply.WorkflowItem.data">data</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.db" href="#control.workflow.apply.WorkflowItem.db">db</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.doTask" href="#control.workflow.apply.WorkflowItem.doTask">doTask</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.eppn" href="#control.workflow.apply.WorkflowItem.eppn">eppn</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.getKind" href="#control.workflow.apply.WorkflowItem.getKind">getKind</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.getWf" href="#control.workflow.apply.WorkflowItem.getWf">getWf</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.info" href="#control.workflow.apply.WorkflowItem.info">info</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.isSuperuser" href="#control.workflow.apply.WorkflowItem.isSuperuser">isSuperuser</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.isTask" href="#control.workflow.apply.WorkflowItem.isTask">isTask</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.isValid" href="#control.workflow.apply.WorkflowItem.isValid">isValid</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.myKind" href="#control.workflow.apply.WorkflowItem.myKind">myKind</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.myReviewerKind" href="#control.workflow.apply.WorkflowItem.myReviewerKind">myReviewerKind</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.permission" href="#control.workflow.apply.WorkflowItem.permission">permission</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.stage" href="#control.workflow.apply.WorkflowItem.stage">stage</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.status" href="#control.workflow.apply.WorkflowItem.status">status</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.statusOverview" href="#control.workflow.apply.WorkflowItem.statusOverview">statusOverview</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.tasks" href="#control.workflow.apply.WorkflowItem.tasks">tasks</a></code></li>
<li><code><a title="control.workflow.apply.WorkflowItem.uid" href="#control.workflow.apply.WorkflowItem.uid">uid</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>