<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>control.auth API documentation</title>
<meta name="description" content="Authentication â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.auth</code></h1>
</header>
<section id="section-intro">
<p>Authentication</p>
<ul>
<li>User management</li>
<li>Identity provider attribute handling</li>
<li>Authorization</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Authentication

*   User management
*   Identity provider attribute handling
*   Authorization
&#34;&#34;&#34;

from flask import request, session, abort
from control.utils import (
    pick as G,
    utf8FromLatin1,
    shiftRegional,
    E,
    AT,
    BLANK,
    WHYPHEN,
)
from config import Config as C, Names as N
from control.html import HtmlElements as H
from control.perm import (
    sysadmin,
    superuser,
    officeuser,
    coordinator,
    authenticated,
    AUTH,
    UNAUTH,
    COORD,
)

CB = C.base
CW = C.web


SHIB_KEY = CB.shibKey
ATTRIBUTES = CB.attributes

LIMITS = CW.limits
LIMIT_JSON = G(LIMITS, N.json, default=1000000)

Qc = H.icon(CW.unknown[N.country], asChar=True)
Qu = H.icon(CW.unknown[N.user], asChar=True)
Qg = H.icon(CW.unknown[N.group], asChar=True)


class Auth:
    &#34;&#34;&#34;Deal with user Authentication.

    Facilitates the login/logout process of users.
    Maintains the attributes that the DARIAH Identity Provider supplies about users.
    &#34;&#34;&#34;

    def __init__(self, db, regime):
        &#34;&#34;&#34;## Initialization

        Include a handle to `control.db.Db` into the
        attributes.

        Parameters
        ----------
        db: object
            See below.
        &#34;&#34;&#34;

        self.db = db
        &#34;&#34;&#34;*object* The `control.db.Db` singleton

        Provides methods to retrieve user
        info from the database and store user info there.
        &#34;&#34;&#34;

        permissionGroupInv = db.permissionGroupInv

        # determine production or devel
        self.isDevel = regime == N.development
        &#34;&#34;&#34;*boolean* Whether the server runs in production or in development.

        In production we use the DARIAH Identity provider,
        while in development we use a simple, console-based way of
        logging a few test users in.
        &#34;&#34;&#34;

        self.authority = N.local if self.isDevel else N.DARIAH
        &#34;&#34;&#34;*string* The name of the authority that identifies users.

        In production it is &#34;DARIAH&#34;, which stands for the DARIAH Identity Provider.
        In development it is &#34;local&#34;.
        &#34;&#34;&#34;

        self.authId = G(permissionGroupInv, AUTH)
        &#34;&#34;&#34;*string* The groupId of the `auth` permission group.
        &#34;&#34;&#34;

        self.authUser = {N.group: self.authId, N.groupRep: AUTH}
        &#34;&#34;&#34;*string* Info of the `auth` permission group.
        &#34;&#34;&#34;

        self.unauthId = G(permissionGroupInv, UNAUTH)
        &#34;&#34;&#34;*string* The groupId of the `public` permission group.
        &#34;&#34;&#34;

        self.unauthUser = {N.group: self.unauthId, N.groupRep: UNAUTH}
        &#34;&#34;&#34;*string* Info of the `public` permission group.
        &#34;&#34;&#34;

        self.user = {}
        &#34;&#34;&#34;*dict* The attributes of the currently logged in user.&#34;&#34;&#34;

    def clearUser(self):
        &#34;&#34;&#34;Forgets the currently logged in user.

        The attributes in the `user` attribute will be cleared and attributes
        for an unauthenticated user will take their place.
        &#34;&#34;&#34;

        user = self.user
        user.clear()
        user.update(self.unauthUser)

    def getUser(self, eppn, email=None):
        &#34;&#34;&#34;Find a user in the database.

        This is called to get extra information for an authenticated user
        from the database.
        The resulting data will be stored in the `user` attribute of Auth.

        !!! caution
            Even if the user can be found, the attribute `mayLogin`
            might be false, in which case it will be prevented to log in that user.

        !!! tip
            When assigning reviewers, office users may select people who are not yet
            known to the contrib tool by specifying their email address.
            When such users log in for the first time, their `eppn` and other
            attributes become known, and are merged into a record in the user table.

        Parameters
        ----------
        eppn: string
            The unique identifier of a user as assigned by the DARIAH identity provider.
        email: string, optional `None`
            New users may not have an eppn, but might already be present in the
            user table by their email.
            If so, the email address can be used to look up the user.

        Returns
        -------
        boolean
            Whether a user was authenticated and logged in.
            The attributes retrieved from the database will be merged into
            the `user` attribute.
            If no user was logged in, the `user` attribute will be filled with
            info that says that the current user is the public and nothing more.
        &#34;&#34;&#34;

        user = self.user
        db = self.db
        authority = self.authority
        authId = self.authId

        userFound = [
            record
            for record in db.user.values()
            if (
                G(record, N.authority) == authority
                and (
                    (eppn is not None and G(record, N.eppn) == eppn)
                    or (
                        eppn is None
                        and email is not None
                        and G(record, N.eppn) is None
                        and G(record, N.email) == email
                    )
                )
            )
        ]
        user.clear()
        if len(userFound) != 1:
            self.clearUser()
            return False

        user.update({N.eppn: eppn, N.authority: authority})
        if email:
            user[N.email] = email
        user.update(userFound[0])
        if not G(user, N.mayLogin, default=True):
            # this checks whether mayLogin is explicitly set to False
            self.clearUser()
            return False

        if N.group in user:
            if N.groupRep not in user:
                groupRep = G(G(db.permissionGroup, user[N.group]), N.rep)
                user[N.groupRep] = groupRep
        else:
            user[N.group] = authId
            user[N.groupRep] = AUTH
        return user[N.groupRep] != UNAUTH

    def wrapTestUsers(self):
        &#34;&#34;&#34;Present a widget to select a test user for login.

        !!! caution
            In production this will do nothing.
            Only in development mode one can select a test user.
        &#34;&#34;&#34;
        if not self.isDevel:
            return E

        db = self.db

        testUsers = {
            record[N.eppn]: record
            for record in db.user.values()
            if N.eppn in record and G(record, N.authority) == N.local
        }
        return H.join(
            [
                H.div(H.a(u, href=f&#34;/login?eppn={u}&#34;, cls=&#34;button small&#34;))
                for u in testUsers
            ]
            + [
                H.div(
                    H.input(
                        E,
                        placeholder=&#34;email&#34;,
                        onchange=&#34;window.location.href=`/login?email=${this.value}`&#34;,
                    )
                )
            ]
        )

    def checkLogin(self):
        &#34;&#34;&#34;Checks for a currently logged in user and sets `user` accordingly.

        This happens after a login action and is meant to adapt the `user` attribute
        to a newly logged-in user.

        Returns
        -------
        Whether an authenticated user has just logged in.
        &#34;&#34;&#34;

        db = self.db
        user = self.user
        isDevel = self.isDevel
        authUser = self.authUser
        unauthUser = self.unauthUser

        contentLength = request.content_length
        if contentLength is not None and contentLength &gt; LIMIT_JSON:
            abort(400)
        env = request.environ
        self.clearUser()
        if isDevel:
            eppn = G(request.args, N.eppn)
            email = None
            if eppn is None:
                email = G(request.args, N.email) or E
                if AT in email:
                    eppn = email.split(AT, maxsplit=1)[0]
                    if eppn:
                        return self.getUser(eppn, email=email)
                user.update(unauthUser)
                return False
            return self.getUser(eppn)
        else:
            authenticated = SHIB_KEY in env and env[SHIB_KEY]
            if authenticated:
                eppn = utf8FromLatin1(env[N.eppn])
                email = utf8FromLatin1(env[N.mail])
                isUser = self.getUser(eppn, email=email)
                if not isUser:
                    # the user is refused because the database says (s)he may not login
                    self.clearUser()
                    return False

                if N.group not in user:
                    # new users do not have yet group information
                    user.update(authUser)

                # process the attributes provided by the identity server
                # they may have been changed after the last login
                attributes = {
                    toolKey: utf8FromLatin1(G(env, envKey, default=E))
                    for (envKey, toolKey) in ATTRIBUTES.items()
                    if envKey in env
                }
                dirty = False
                for (att, val) in attributes.items():
                    currentVal = G(user, att)
                    if currentVal != val:
                        user[att] = val
                        dirty = True
                if N._id in user:
                    if dirty:
                        db.updateUser(user)
                else:
                    _id = db.insertUser(user)
                    user[N._id] = _id
                return True

            user.update(unauthUser)
            return False

    def countryRep(self, user=None):
        &#34;&#34;&#34;Provide a short representation of the country of a user.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose country must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
            The representation consists of the 2-letter country code plus
            a derived two letter unicode character combination that will
            be turned into a flag of that country.
        &#34;&#34;&#34;

        db = self.db
        country = db.country

        if user is None:
            user = self.user

        countryId = G(user, N.country)
        countryInfo = G(country, countryId)
        iso = G(countryInfo, N.iso, default=E)
        flag = shiftRegional(iso) if iso else Qc
        countryShort = iso + flag
        return countryShort

    def groupRep(self, user=None):
        &#34;&#34;&#34;Provide a string representation of the permission group of a user.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose group must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
        &#34;&#34;&#34;

        if user is None:
            user = self.user

        return G(user, N.groupRep) or UNAUTH

    def identity(self, user=None):
        &#34;&#34;&#34;Provide a string representation of the identity of a user.

        !!! note
            Care will be taken that to unauthenticated users only
            limited information about users will be shown.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose identity must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
        &#34;&#34;&#34;

        if user is None:
            user = self.user

        if self.isDevel:
            return G(user, N.eppn, default=G(user, N.email, default=Qu))

        name = G(user, N.name) or E
        if not name:
            firstName = G(user, N.firstName) or E
            lastName = G(user, N.lastName) or E
            name = firstName + (BLANK if firstName and lastName else E) + lastName
        group = self.groupRep(user=user)
        isAuth = group != UNAUTH
        org = G(user, N.org) or E
        orgRep = f&#34;&#34;&#34; ({org})&#34;&#34;&#34; if org else E
        email = (G(user, N.email) or E) if isAuth else E
        authority = (G(user, N.authority) or E) if isAuth else E
        authorityRep = f&#34;&#34;&#34;{WHYPHEN}{authority}&#34;&#34;&#34; if authority else E
        eppn = (G(user, N.eppn) or E) if isAuth else E

        countryShort = self.countryRep(user=user)

        identityRep = (
            (
                f&#34;&#34;&#34;{name}{orgRep}&#34;&#34;&#34;
                if name
                else f&#34;&#34;&#34;{email}{orgRep}&#34;&#34;&#34;
                if email
                else f&#34;&#34;&#34;{eppn}{authorityRep}&#34;&#34;&#34;
                if eppn
                else Qu
            )
            + &#34;&#34;&#34; from &#34;&#34;&#34;
            + (countryShort)
        )
        return identityRep

    def credentials(self):
        &#34;&#34;&#34;Provide a string representation of the identity and permissions of a user.

        This is used to present the currently logged in user on the interface.

        !!! note
            Care will be taken that to unauthenticated users only
            limited information about users will be shown.

        Returns
        -------
        string
            identity
        string
            group description
        &#34;&#34;&#34;

        db = self.db
        user = self.user

        group = self.groupRep()
        permissionGroupDesc = db.permissionGroupDesc
        groupDesc = G(permissionGroupDesc, group) or Qg
        if group == COORD:
            country = self.countryRep()
            groupDesc += f&#34;-{country}&#34;

        if group == UNAUTH:
            return (N.Guest, groupDesc)

        identityRep = self.identity(user)

        return (identityRep, groupDesc)

    def nameEmail(self, user=None):
        &#34;&#34;&#34;Provide a string representation of the name and email of the user.

        !!! note
            Care will be taken that to unauthenticated users only
            limited information about users will be shown.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose identity must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
        &#34;&#34;&#34;

        if user is None:
            user = self.user

        name = G(user, N.name) or E
        if not name:
            firstName = G(user, N.firstName) or E
            lastName = G(user, N.lastName) or E
            name = firstName + (BLANK if firstName and lastName else E) + lastName
        group = self.groupRep(user=user)
        isAuth = group != UNAUTH
        email = (G(user, N.email) or E) if isAuth else E
        return (name, email)

    def authenticate(self, login=False):
        &#34;&#34;&#34;Verify the authenticated status of the current user.

        This function is called for every request that requires authentication.
        Whether a user is authenticated or not depends on whether a session for
        that user is present. And that depends on whether the identity provider
        has sent attributes (eppn and others) to the server.

        The data in the `user` attribute will be cleared if there is
        an authenticated user. Subsequent methods that ask for the uid of
        the currennt user will get nothing if there is no authenticated user.
        If there is an authenticated user, and `login=False`, his/her data
        are not loaded into the `user` attribute.

        Parameters
        ----------
        login: boolean, optional `False`
            Pass `True` in order to verify/update a user that has just logged in.
            The data in the `user` attribute will be updated with his/her
            data. The user table in the database will be updated if the
            identity provider has given updated attributed for that user.

        Returns
        -------
        boolean
            Whether the current user is authenticated.
        &#34;&#34;&#34;

        user = self.user

        # if login=True we want to log the user in
        # if login=False we only want the current user information

        if login:
            session.pop(N.eppn, None)
            if self.checkLogin():
                # in this case there is an eppn
                session[N.eppn] = G(user, N.eppn)
                return True
            return False

        eppn = G(session, N.eppn)
        if eppn:
            if not self.getUser(eppn):
                self.clearUser()
                return False
            return True

        self.clearUser()
        return False

    def deauthenticate(self):
        &#34;&#34;&#34;Log out the current user.

        Returns
        -------
        void
            If there is a logged in authenticated user, his/her data will be
            cleared and the session will be deleted.
        &#34;&#34;&#34;

        self.clearUser()
        session.pop(N.eppn, None)

    def authenticated(self):
        &#34;&#34;&#34;Is the current user authenticated?

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return authenticated(user)

    def coordinator(self, countryId=None):
        &#34;&#34;&#34;Is the current user a national coordinator?

        !!! note
            On the overview page, we display contributions of many countries.
            If a National Coordinator is logged in, (s)he will see the coutributions
            of his/her country in greater detail, but not those of other countries.

        Parameters
        ----------
        countryId: dict, optional `None`
            If passed, it is the country of which the currently logged in
            user is supposed to be National Coordinator.
            Otherwise, the country of the logged in user will be used.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return coordinator(user, countryId)

    def officeuser(self):
        &#34;&#34;&#34;Is the current user a backoffice user?

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return officeuser(user)

    def superuser(self):
        &#34;&#34;&#34;Is the current user a super user?

        Superusers are backoffice users, sysadmins and root.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return superuser(user)

    def sysadmin(self):
        &#34;&#34;&#34;Is the current user a system administrator?

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return sysadmin(user)

    def country(self):
        &#34;&#34;&#34;The full country record of the currently logged in user.

        !!! hint
            This function is used to get the country on the Sidebar.

        Returns
        -------
        dict
        &#34;&#34;&#34;

        db = self.db
        user = self.user
        country = db.country

        countryId = G(user, N.country)
        return G(country, countryId, default={})</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.auth.Auth"><code class="flex name class">
<span>class <span class="ident">Auth</span></span>
<span>(</span><span>db, regime)</span>
</code></dt>
<dd>
<section class="desc"><p>Deal with user Authentication.</p>
<p>Facilitates the login/logout process of users.
Maintains the attributes that the DARIAH Identity Provider supplies about users.</p>
<h2 id="initialization">Initialization</h2>
<p>Include a handle to <a title="control.db.Db" href="db.html#control.db.Db"><code>Db</code></a> into the
attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>object</code></dt>
<dd>See below.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Auth:
    &#34;&#34;&#34;Deal with user Authentication.

    Facilitates the login/logout process of users.
    Maintains the attributes that the DARIAH Identity Provider supplies about users.
    &#34;&#34;&#34;

    def __init__(self, db, regime):
        &#34;&#34;&#34;## Initialization

        Include a handle to `control.db.Db` into the
        attributes.

        Parameters
        ----------
        db: object
            See below.
        &#34;&#34;&#34;

        self.db = db
        &#34;&#34;&#34;*object* The `control.db.Db` singleton

        Provides methods to retrieve user
        info from the database and store user info there.
        &#34;&#34;&#34;

        permissionGroupInv = db.permissionGroupInv

        # determine production or devel
        self.isDevel = regime == N.development
        &#34;&#34;&#34;*boolean* Whether the server runs in production or in development.

        In production we use the DARIAH Identity provider,
        while in development we use a simple, console-based way of
        logging a few test users in.
        &#34;&#34;&#34;

        self.authority = N.local if self.isDevel else N.DARIAH
        &#34;&#34;&#34;*string* The name of the authority that identifies users.

        In production it is &#34;DARIAH&#34;, which stands for the DARIAH Identity Provider.
        In development it is &#34;local&#34;.
        &#34;&#34;&#34;

        self.authId = G(permissionGroupInv, AUTH)
        &#34;&#34;&#34;*string* The groupId of the `auth` permission group.
        &#34;&#34;&#34;

        self.authUser = {N.group: self.authId, N.groupRep: AUTH}
        &#34;&#34;&#34;*string* Info of the `auth` permission group.
        &#34;&#34;&#34;

        self.unauthId = G(permissionGroupInv, UNAUTH)
        &#34;&#34;&#34;*string* The groupId of the `public` permission group.
        &#34;&#34;&#34;

        self.unauthUser = {N.group: self.unauthId, N.groupRep: UNAUTH}
        &#34;&#34;&#34;*string* Info of the `public` permission group.
        &#34;&#34;&#34;

        self.user = {}
        &#34;&#34;&#34;*dict* The attributes of the currently logged in user.&#34;&#34;&#34;

    def clearUser(self):
        &#34;&#34;&#34;Forgets the currently logged in user.

        The attributes in the `user` attribute will be cleared and attributes
        for an unauthenticated user will take their place.
        &#34;&#34;&#34;

        user = self.user
        user.clear()
        user.update(self.unauthUser)

    def getUser(self, eppn, email=None):
        &#34;&#34;&#34;Find a user in the database.

        This is called to get extra information for an authenticated user
        from the database.
        The resulting data will be stored in the `user` attribute of Auth.

        !!! caution
            Even if the user can be found, the attribute `mayLogin`
            might be false, in which case it will be prevented to log in that user.

        !!! tip
            When assigning reviewers, office users may select people who are not yet
            known to the contrib tool by specifying their email address.
            When such users log in for the first time, their `eppn` and other
            attributes become known, and are merged into a record in the user table.

        Parameters
        ----------
        eppn: string
            The unique identifier of a user as assigned by the DARIAH identity provider.
        email: string, optional `None`
            New users may not have an eppn, but might already be present in the
            user table by their email.
            If so, the email address can be used to look up the user.

        Returns
        -------
        boolean
            Whether a user was authenticated and logged in.
            The attributes retrieved from the database will be merged into
            the `user` attribute.
            If no user was logged in, the `user` attribute will be filled with
            info that says that the current user is the public and nothing more.
        &#34;&#34;&#34;

        user = self.user
        db = self.db
        authority = self.authority
        authId = self.authId

        userFound = [
            record
            for record in db.user.values()
            if (
                G(record, N.authority) == authority
                and (
                    (eppn is not None and G(record, N.eppn) == eppn)
                    or (
                        eppn is None
                        and email is not None
                        and G(record, N.eppn) is None
                        and G(record, N.email) == email
                    )
                )
            )
        ]
        user.clear()
        if len(userFound) != 1:
            self.clearUser()
            return False

        user.update({N.eppn: eppn, N.authority: authority})
        if email:
            user[N.email] = email
        user.update(userFound[0])
        if not G(user, N.mayLogin, default=True):
            # this checks whether mayLogin is explicitly set to False
            self.clearUser()
            return False

        if N.group in user:
            if N.groupRep not in user:
                groupRep = G(G(db.permissionGroup, user[N.group]), N.rep)
                user[N.groupRep] = groupRep
        else:
            user[N.group] = authId
            user[N.groupRep] = AUTH
        return user[N.groupRep] != UNAUTH

    def wrapTestUsers(self):
        &#34;&#34;&#34;Present a widget to select a test user for login.

        !!! caution
            In production this will do nothing.
            Only in development mode one can select a test user.
        &#34;&#34;&#34;
        if not self.isDevel:
            return E

        db = self.db

        testUsers = {
            record[N.eppn]: record
            for record in db.user.values()
            if N.eppn in record and G(record, N.authority) == N.local
        }
        return H.join(
            [
                H.div(H.a(u, href=f&#34;/login?eppn={u}&#34;, cls=&#34;button small&#34;))
                for u in testUsers
            ]
            + [
                H.div(
                    H.input(
                        E,
                        placeholder=&#34;email&#34;,
                        onchange=&#34;window.location.href=`/login?email=${this.value}`&#34;,
                    )
                )
            ]
        )

    def checkLogin(self):
        &#34;&#34;&#34;Checks for a currently logged in user and sets `user` accordingly.

        This happens after a login action and is meant to adapt the `user` attribute
        to a newly logged-in user.

        Returns
        -------
        Whether an authenticated user has just logged in.
        &#34;&#34;&#34;

        db = self.db
        user = self.user
        isDevel = self.isDevel
        authUser = self.authUser
        unauthUser = self.unauthUser

        contentLength = request.content_length
        if contentLength is not None and contentLength &gt; LIMIT_JSON:
            abort(400)
        env = request.environ
        self.clearUser()
        if isDevel:
            eppn = G(request.args, N.eppn)
            email = None
            if eppn is None:
                email = G(request.args, N.email) or E
                if AT in email:
                    eppn = email.split(AT, maxsplit=1)[0]
                    if eppn:
                        return self.getUser(eppn, email=email)
                user.update(unauthUser)
                return False
            return self.getUser(eppn)
        else:
            authenticated = SHIB_KEY in env and env[SHIB_KEY]
            if authenticated:
                eppn = utf8FromLatin1(env[N.eppn])
                email = utf8FromLatin1(env[N.mail])
                isUser = self.getUser(eppn, email=email)
                if not isUser:
                    # the user is refused because the database says (s)he may not login
                    self.clearUser()
                    return False

                if N.group not in user:
                    # new users do not have yet group information
                    user.update(authUser)

                # process the attributes provided by the identity server
                # they may have been changed after the last login
                attributes = {
                    toolKey: utf8FromLatin1(G(env, envKey, default=E))
                    for (envKey, toolKey) in ATTRIBUTES.items()
                    if envKey in env
                }
                dirty = False
                for (att, val) in attributes.items():
                    currentVal = G(user, att)
                    if currentVal != val:
                        user[att] = val
                        dirty = True
                if N._id in user:
                    if dirty:
                        db.updateUser(user)
                else:
                    _id = db.insertUser(user)
                    user[N._id] = _id
                return True

            user.update(unauthUser)
            return False

    def countryRep(self, user=None):
        &#34;&#34;&#34;Provide a short representation of the country of a user.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose country must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
            The representation consists of the 2-letter country code plus
            a derived two letter unicode character combination that will
            be turned into a flag of that country.
        &#34;&#34;&#34;

        db = self.db
        country = db.country

        if user is None:
            user = self.user

        countryId = G(user, N.country)
        countryInfo = G(country, countryId)
        iso = G(countryInfo, N.iso, default=E)
        flag = shiftRegional(iso) if iso else Qc
        countryShort = iso + flag
        return countryShort

    def groupRep(self, user=None):
        &#34;&#34;&#34;Provide a string representation of the permission group of a user.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose group must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
        &#34;&#34;&#34;

        if user is None:
            user = self.user

        return G(user, N.groupRep) or UNAUTH

    def identity(self, user=None):
        &#34;&#34;&#34;Provide a string representation of the identity of a user.

        !!! note
            Care will be taken that to unauthenticated users only
            limited information about users will be shown.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose identity must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
        &#34;&#34;&#34;

        if user is None:
            user = self.user

        if self.isDevel:
            return G(user, N.eppn, default=G(user, N.email, default=Qu))

        name = G(user, N.name) or E
        if not name:
            firstName = G(user, N.firstName) or E
            lastName = G(user, N.lastName) or E
            name = firstName + (BLANK if firstName and lastName else E) + lastName
        group = self.groupRep(user=user)
        isAuth = group != UNAUTH
        org = G(user, N.org) or E
        orgRep = f&#34;&#34;&#34; ({org})&#34;&#34;&#34; if org else E
        email = (G(user, N.email) or E) if isAuth else E
        authority = (G(user, N.authority) or E) if isAuth else E
        authorityRep = f&#34;&#34;&#34;{WHYPHEN}{authority}&#34;&#34;&#34; if authority else E
        eppn = (G(user, N.eppn) or E) if isAuth else E

        countryShort = self.countryRep(user=user)

        identityRep = (
            (
                f&#34;&#34;&#34;{name}{orgRep}&#34;&#34;&#34;
                if name
                else f&#34;&#34;&#34;{email}{orgRep}&#34;&#34;&#34;
                if email
                else f&#34;&#34;&#34;{eppn}{authorityRep}&#34;&#34;&#34;
                if eppn
                else Qu
            )
            + &#34;&#34;&#34; from &#34;&#34;&#34;
            + (countryShort)
        )
        return identityRep

    def credentials(self):
        &#34;&#34;&#34;Provide a string representation of the identity and permissions of a user.

        This is used to present the currently logged in user on the interface.

        !!! note
            Care will be taken that to unauthenticated users only
            limited information about users will be shown.

        Returns
        -------
        string
            identity
        string
            group description
        &#34;&#34;&#34;

        db = self.db
        user = self.user

        group = self.groupRep()
        permissionGroupDesc = db.permissionGroupDesc
        groupDesc = G(permissionGroupDesc, group) or Qg
        if group == COORD:
            country = self.countryRep()
            groupDesc += f&#34;-{country}&#34;

        if group == UNAUTH:
            return (N.Guest, groupDesc)

        identityRep = self.identity(user)

        return (identityRep, groupDesc)

    def nameEmail(self, user=None):
        &#34;&#34;&#34;Provide a string representation of the name and email of the user.

        !!! note
            Care will be taken that to unauthenticated users only
            limited information about users will be shown.

        Parameters
        ----------
        user: dict, optional `None`
            The user whose identity must be represented.
            If absent, the currently logged in user will be taken.

        Returns
        -------
        string
        &#34;&#34;&#34;

        if user is None:
            user = self.user

        name = G(user, N.name) or E
        if not name:
            firstName = G(user, N.firstName) or E
            lastName = G(user, N.lastName) or E
            name = firstName + (BLANK if firstName and lastName else E) + lastName
        group = self.groupRep(user=user)
        isAuth = group != UNAUTH
        email = (G(user, N.email) or E) if isAuth else E
        return (name, email)

    def authenticate(self, login=False):
        &#34;&#34;&#34;Verify the authenticated status of the current user.

        This function is called for every request that requires authentication.
        Whether a user is authenticated or not depends on whether a session for
        that user is present. And that depends on whether the identity provider
        has sent attributes (eppn and others) to the server.

        The data in the `user` attribute will be cleared if there is
        an authenticated user. Subsequent methods that ask for the uid of
        the currennt user will get nothing if there is no authenticated user.
        If there is an authenticated user, and `login=False`, his/her data
        are not loaded into the `user` attribute.

        Parameters
        ----------
        login: boolean, optional `False`
            Pass `True` in order to verify/update a user that has just logged in.
            The data in the `user` attribute will be updated with his/her
            data. The user table in the database will be updated if the
            identity provider has given updated attributed for that user.

        Returns
        -------
        boolean
            Whether the current user is authenticated.
        &#34;&#34;&#34;

        user = self.user

        # if login=True we want to log the user in
        # if login=False we only want the current user information

        if login:
            session.pop(N.eppn, None)
            if self.checkLogin():
                # in this case there is an eppn
                session[N.eppn] = G(user, N.eppn)
                return True
            return False

        eppn = G(session, N.eppn)
        if eppn:
            if not self.getUser(eppn):
                self.clearUser()
                return False
            return True

        self.clearUser()
        return False

    def deauthenticate(self):
        &#34;&#34;&#34;Log out the current user.

        Returns
        -------
        void
            If there is a logged in authenticated user, his/her data will be
            cleared and the session will be deleted.
        &#34;&#34;&#34;

        self.clearUser()
        session.pop(N.eppn, None)

    def authenticated(self):
        &#34;&#34;&#34;Is the current user authenticated?

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return authenticated(user)

    def coordinator(self, countryId=None):
        &#34;&#34;&#34;Is the current user a national coordinator?

        !!! note
            On the overview page, we display contributions of many countries.
            If a National Coordinator is logged in, (s)he will see the coutributions
            of his/her country in greater detail, but not those of other countries.

        Parameters
        ----------
        countryId: dict, optional `None`
            If passed, it is the country of which the currently logged in
            user is supposed to be National Coordinator.
            Otherwise, the country of the logged in user will be used.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return coordinator(user, countryId)

    def officeuser(self):
        &#34;&#34;&#34;Is the current user a backoffice user?

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return officeuser(user)

    def superuser(self):
        &#34;&#34;&#34;Is the current user a super user?

        Superusers are backoffice users, sysadmins and root.

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return superuser(user)

    def sysadmin(self):
        &#34;&#34;&#34;Is the current user a system administrator?

        Returns
        -------
        boolean
        &#34;&#34;&#34;

        user = self.user
        return sysadmin(user)

    def country(self):
        &#34;&#34;&#34;The full country record of the currently logged in user.

        !!! hint
            This function is used to get the country on the Sidebar.

        Returns
        -------
        dict
        &#34;&#34;&#34;

        db = self.db
        user = self.user
        country = db.country

        countryId = G(user, N.country)
        return G(country, countryId, default={})</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="control.auth.Auth.authId"><code class="name">var <span class="ident">authId</span></code></dt>
<dd>
<section class="desc"><p><em>string</em> The groupId of the <code>auth</code> permission group.</p></section>
</dd>
<dt id="control.auth.Auth.authUser"><code class="name">var <span class="ident">authUser</span></code></dt>
<dd>
<section class="desc"><p><em>string</em> Info of the <code>auth</code> permission group.</p></section>
</dd>
<dt id="control.auth.Auth.authority"><code class="name">var <span class="ident">authority</span></code></dt>
<dd>
<section class="desc"><p><em>string</em> The name of the authority that identifies users.</p>
<p>In production it is "DARIAH", which stands for the DARIAH Identity Provider.
In development it is "local".</p></section>
</dd>
<dt id="control.auth.Auth.db"><code class="name">var <span class="ident">db</span></code></dt>
<dd>
<section class="desc"><p><em>object</em> The <a title="control.db.Db" href="db.html#control.db.Db"><code>Db</code></a> singleton</p>
<p>Provides methods to retrieve user
info from the database and store user info there.</p></section>
</dd>
<dt id="control.auth.Auth.isDevel"><code class="name">var <span class="ident">isDevel</span></code></dt>
<dd>
<section class="desc"><p><em>boolean</em> Whether the server runs in production or in development.</p>
<p>In production we use the DARIAH Identity provider,
while in development we use a simple, console-based way of
logging a few test users in.</p></section>
</dd>
<dt id="control.auth.Auth.unauthId"><code class="name">var <span class="ident">unauthId</span></code></dt>
<dd>
<section class="desc"><p><em>string</em> The groupId of the <code>public</code> permission group.</p></section>
</dd>
<dt id="control.auth.Auth.unauthUser"><code class="name">var <span class="ident">unauthUser</span></code></dt>
<dd>
<section class="desc"><p><em>string</em> Info of the <code>public</code> permission group.</p></section>
</dd>
<dt id="control.auth.Auth.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<section class="desc"><p><em>dict</em> The attributes of the currently logged in user.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.auth.Auth.authenticate"><code class="name flex">
<span>def <span class="ident">authenticate</span></span>(<span>self, login=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Verify the authenticated status of the current user.</p>
<p>This function is called for every request that requires authentication.
Whether a user is authenticated or not depends on whether a session for
that user is present. And that depends on whether the identity provider
has sent attributes (eppn and others) to the server.</p>
<p>The data in the <code>user</code> attribute will be cleared if there is
an authenticated user. Subsequent methods that ask for the uid of
the currennt user will get nothing if there is no authenticated user.
If there is an authenticated user, and <code>login=False</code>, his/her data
are not loaded into the <code>user</code> attribute.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>login</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Pass <code>True</code> in order to verify/update a user that has just logged in.
The data in the <code>user</code> attribute will be updated with his/her
data. The user table in the database will be updated if the
identity provider has given updated attributed for that user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the current user is authenticated.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate(self, login=False):
    &#34;&#34;&#34;Verify the authenticated status of the current user.

    This function is called for every request that requires authentication.
    Whether a user is authenticated or not depends on whether a session for
    that user is present. And that depends on whether the identity provider
    has sent attributes (eppn and others) to the server.

    The data in the `user` attribute will be cleared if there is
    an authenticated user. Subsequent methods that ask for the uid of
    the currennt user will get nothing if there is no authenticated user.
    If there is an authenticated user, and `login=False`, his/her data
    are not loaded into the `user` attribute.

    Parameters
    ----------
    login: boolean, optional `False`
        Pass `True` in order to verify/update a user that has just logged in.
        The data in the `user` attribute will be updated with his/her
        data. The user table in the database will be updated if the
        identity provider has given updated attributed for that user.

    Returns
    -------
    boolean
        Whether the current user is authenticated.
    &#34;&#34;&#34;

    user = self.user

    # if login=True we want to log the user in
    # if login=False we only want the current user information

    if login:
        session.pop(N.eppn, None)
        if self.checkLogin():
            # in this case there is an eppn
            session[N.eppn] = G(user, N.eppn)
            return True
        return False

    eppn = G(session, N.eppn)
    if eppn:
        if not self.getUser(eppn):
            self.clearUser()
            return False
        return True

    self.clearUser()
    return False</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.authenticated"><code class="name flex">
<span>def <span class="ident">authenticated</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Is the current user authenticated?</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticated(self):
    &#34;&#34;&#34;Is the current user authenticated?

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    user = self.user
    return authenticated(user)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.checkLogin"><code class="name flex">
<span>def <span class="ident">checkLogin</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks for a currently logged in user and sets <code>user</code> accordingly.</p>
<p>This happens after a login action and is meant to adapt the <code>user</code> attribute
to a newly logged-in user.</p>
<h2 id="returns">Returns</h2>
<p>Whether an authenticated user has just logged in.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkLogin(self):
    &#34;&#34;&#34;Checks for a currently logged in user and sets `user` accordingly.

    This happens after a login action and is meant to adapt the `user` attribute
    to a newly logged-in user.

    Returns
    -------
    Whether an authenticated user has just logged in.
    &#34;&#34;&#34;

    db = self.db
    user = self.user
    isDevel = self.isDevel
    authUser = self.authUser
    unauthUser = self.unauthUser

    contentLength = request.content_length
    if contentLength is not None and contentLength &gt; LIMIT_JSON:
        abort(400)
    env = request.environ
    self.clearUser()
    if isDevel:
        eppn = G(request.args, N.eppn)
        email = None
        if eppn is None:
            email = G(request.args, N.email) or E
            if AT in email:
                eppn = email.split(AT, maxsplit=1)[0]
                if eppn:
                    return self.getUser(eppn, email=email)
            user.update(unauthUser)
            return False
        return self.getUser(eppn)
    else:
        authenticated = SHIB_KEY in env and env[SHIB_KEY]
        if authenticated:
            eppn = utf8FromLatin1(env[N.eppn])
            email = utf8FromLatin1(env[N.mail])
            isUser = self.getUser(eppn, email=email)
            if not isUser:
                # the user is refused because the database says (s)he may not login
                self.clearUser()
                return False

            if N.group not in user:
                # new users do not have yet group information
                user.update(authUser)

            # process the attributes provided by the identity server
            # they may have been changed after the last login
            attributes = {
                toolKey: utf8FromLatin1(G(env, envKey, default=E))
                for (envKey, toolKey) in ATTRIBUTES.items()
                if envKey in env
            }
            dirty = False
            for (att, val) in attributes.items():
                currentVal = G(user, att)
                if currentVal != val:
                    user[att] = val
                    dirty = True
            if N._id in user:
                if dirty:
                    db.updateUser(user)
            else:
                _id = db.insertUser(user)
                user[N._id] = _id
            return True

        user.update(unauthUser)
        return False</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.clearUser"><code class="name flex">
<span>def <span class="ident">clearUser</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Forgets the currently logged in user.</p>
<p>The attributes in the <code>user</code> attribute will be cleared and attributes
for an unauthenticated user will take their place.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearUser(self):
    &#34;&#34;&#34;Forgets the currently logged in user.

    The attributes in the `user` attribute will be cleared and attributes
    for an unauthenticated user will take their place.
    &#34;&#34;&#34;

    user = self.user
    user.clear()
    user.update(self.unauthUser)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.coordinator"><code class="name flex">
<span>def <span class="ident">coordinator</span></span>(<span>self, countryId=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Is the current user a national coordinator?</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On the overview page, we display contributions of many countries.
If a National Coordinator is logged in, (s)he will see the coutributions
of his/her country in greater detail, but not those of other countries.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>countryId</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>If passed, it is the country of which the currently logged in
user is supposed to be National Coordinator.
Otherwise, the country of the logged in user will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinator(self, countryId=None):
    &#34;&#34;&#34;Is the current user a national coordinator?

    !!! note
        On the overview page, we display contributions of many countries.
        If a National Coordinator is logged in, (s)he will see the coutributions
        of his/her country in greater detail, but not those of other countries.

    Parameters
    ----------
    countryId: dict, optional `None`
        If passed, it is the country of which the currently logged in
        user is supposed to be National Coordinator.
        Otherwise, the country of the logged in user will be used.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    user = self.user
    return coordinator(user, countryId)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.country"><code class="name flex">
<span>def <span class="ident">country</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The full country record of the currently logged in user.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>This function is used to get the country on the Sidebar.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def country(self):
    &#34;&#34;&#34;The full country record of the currently logged in user.

    !!! hint
        This function is used to get the country on the Sidebar.

    Returns
    -------
    dict
    &#34;&#34;&#34;

    db = self.db
    user = self.user
    country = db.country

    countryId = G(user, N.country)
    return G(country, countryId, default={})</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.countryRep"><code class="name flex">
<span>def <span class="ident">countryRep</span></span>(<span>self, user=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Provide a short representation of the country of a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>The user whose country must be represented.
If absent, the currently logged in user will be taken.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The representation consists of the 2-letter country code plus
a derived two letter unicode character combination that will
be turned into a flag of that country.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def countryRep(self, user=None):
    &#34;&#34;&#34;Provide a short representation of the country of a user.

    Parameters
    ----------
    user: dict, optional `None`
        The user whose country must be represented.
        If absent, the currently logged in user will be taken.

    Returns
    -------
    string
        The representation consists of the 2-letter country code plus
        a derived two letter unicode character combination that will
        be turned into a flag of that country.
    &#34;&#34;&#34;

    db = self.db
    country = db.country

    if user is None:
        user = self.user

    countryId = G(user, N.country)
    countryInfo = G(country, countryId)
    iso = G(countryInfo, N.iso, default=E)
    flag = shiftRegional(iso) if iso else Qc
    countryShort = iso + flag
    return countryShort</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.credentials"><code class="name flex">
<span>def <span class="ident">credentials</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Provide a string representation of the identity and permissions of a user.</p>
<p>This is used to present the currently logged in user on the interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Care will be taken that to unauthenticated users only
limited information about users will be shown.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>identity</dd>
<dt><code>string</code></dt>
<dd>group description</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def credentials(self):
    &#34;&#34;&#34;Provide a string representation of the identity and permissions of a user.

    This is used to present the currently logged in user on the interface.

    !!! note
        Care will be taken that to unauthenticated users only
        limited information about users will be shown.

    Returns
    -------
    string
        identity
    string
        group description
    &#34;&#34;&#34;

    db = self.db
    user = self.user

    group = self.groupRep()
    permissionGroupDesc = db.permissionGroupDesc
    groupDesc = G(permissionGroupDesc, group) or Qg
    if group == COORD:
        country = self.countryRep()
        groupDesc += f&#34;-{country}&#34;

    if group == UNAUTH:
        return (N.Guest, groupDesc)

    identityRep = self.identity(user)

    return (identityRep, groupDesc)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.deauthenticate"><code class="name flex">
<span>def <span class="ident">deauthenticate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Log out the current user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>If there is a logged in authenticated user, his/her data will be
cleared and the session will be deleted.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deauthenticate(self):
    &#34;&#34;&#34;Log out the current user.

    Returns
    -------
    void
        If there is a logged in authenticated user, his/her data will be
        cleared and the session will be deleted.
    &#34;&#34;&#34;

    self.clearUser()
    session.pop(N.eppn, None)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.getUser"><code class="name flex">
<span>def <span class="ident">getUser</span></span>(<span>self, eppn, email=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Find a user in the database.</p>
<p>This is called to get extra information for an authenticated user
from the database.
The resulting data will be stored in the <code>user</code> attribute of Auth.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Even if the user can be found, the attribute <code>mayLogin</code>
might be false, in which case it will be prevented to log in that user.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When assigning reviewers, office users may select people who are not yet
known to the contrib tool by specifying their email address.
When such users log in for the first time, their <code>eppn</code> and other
attributes become known, and are merged into a record in the user table.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eppn</code></strong> :&ensp;<code>string</code></dt>
<dd>The unique identifier of a user as assigned by the DARIAH identity provider.</dd>
<dt><strong><code>email</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>New users may not have an eppn, but might already be present in the
user table by their email.
If so, the email address can be used to look up the user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether a user was authenticated and logged in.
The attributes retrieved from the database will be merged into
the <code>user</code> attribute.
If no user was logged in, the <code>user</code> attribute will be filled with
info that says that the current user is the public and nothing more.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUser(self, eppn, email=None):
    &#34;&#34;&#34;Find a user in the database.

    This is called to get extra information for an authenticated user
    from the database.
    The resulting data will be stored in the `user` attribute of Auth.

    !!! caution
        Even if the user can be found, the attribute `mayLogin`
        might be false, in which case it will be prevented to log in that user.

    !!! tip
        When assigning reviewers, office users may select people who are not yet
        known to the contrib tool by specifying their email address.
        When such users log in for the first time, their `eppn` and other
        attributes become known, and are merged into a record in the user table.

    Parameters
    ----------
    eppn: string
        The unique identifier of a user as assigned by the DARIAH identity provider.
    email: string, optional `None`
        New users may not have an eppn, but might already be present in the
        user table by their email.
        If so, the email address can be used to look up the user.

    Returns
    -------
    boolean
        Whether a user was authenticated and logged in.
        The attributes retrieved from the database will be merged into
        the `user` attribute.
        If no user was logged in, the `user` attribute will be filled with
        info that says that the current user is the public and nothing more.
    &#34;&#34;&#34;

    user = self.user
    db = self.db
    authority = self.authority
    authId = self.authId

    userFound = [
        record
        for record in db.user.values()
        if (
            G(record, N.authority) == authority
            and (
                (eppn is not None and G(record, N.eppn) == eppn)
                or (
                    eppn is None
                    and email is not None
                    and G(record, N.eppn) is None
                    and G(record, N.email) == email
                )
            )
        )
    ]
    user.clear()
    if len(userFound) != 1:
        self.clearUser()
        return False

    user.update({N.eppn: eppn, N.authority: authority})
    if email:
        user[N.email] = email
    user.update(userFound[0])
    if not G(user, N.mayLogin, default=True):
        # this checks whether mayLogin is explicitly set to False
        self.clearUser()
        return False

    if N.group in user:
        if N.groupRep not in user:
            groupRep = G(G(db.permissionGroup, user[N.group]), N.rep)
            user[N.groupRep] = groupRep
    else:
        user[N.group] = authId
        user[N.groupRep] = AUTH
    return user[N.groupRep] != UNAUTH</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.groupRep"><code class="name flex">
<span>def <span class="ident">groupRep</span></span>(<span>self, user=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Provide a string representation of the permission group of a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>The user whose group must be represented.
If absent, the currently logged in user will be taken.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groupRep(self, user=None):
    &#34;&#34;&#34;Provide a string representation of the permission group of a user.

    Parameters
    ----------
    user: dict, optional `None`
        The user whose group must be represented.
        If absent, the currently logged in user will be taken.

    Returns
    -------
    string
    &#34;&#34;&#34;

    if user is None:
        user = self.user

    return G(user, N.groupRep) or UNAUTH</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.identity"><code class="name flex">
<span>def <span class="ident">identity</span></span>(<span>self, user=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Provide a string representation of the identity of a user.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Care will be taken that to unauthenticated users only
limited information about users will be shown.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>The user whose identity must be represented.
If absent, the currently logged in user will be taken.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identity(self, user=None):
    &#34;&#34;&#34;Provide a string representation of the identity of a user.

    !!! note
        Care will be taken that to unauthenticated users only
        limited information about users will be shown.

    Parameters
    ----------
    user: dict, optional `None`
        The user whose identity must be represented.
        If absent, the currently logged in user will be taken.

    Returns
    -------
    string
    &#34;&#34;&#34;

    if user is None:
        user = self.user

    if self.isDevel:
        return G(user, N.eppn, default=G(user, N.email, default=Qu))

    name = G(user, N.name) or E
    if not name:
        firstName = G(user, N.firstName) or E
        lastName = G(user, N.lastName) or E
        name = firstName + (BLANK if firstName and lastName else E) + lastName
    group = self.groupRep(user=user)
    isAuth = group != UNAUTH
    org = G(user, N.org) or E
    orgRep = f&#34;&#34;&#34; ({org})&#34;&#34;&#34; if org else E
    email = (G(user, N.email) or E) if isAuth else E
    authority = (G(user, N.authority) or E) if isAuth else E
    authorityRep = f&#34;&#34;&#34;{WHYPHEN}{authority}&#34;&#34;&#34; if authority else E
    eppn = (G(user, N.eppn) or E) if isAuth else E

    countryShort = self.countryRep(user=user)

    identityRep = (
        (
            f&#34;&#34;&#34;{name}{orgRep}&#34;&#34;&#34;
            if name
            else f&#34;&#34;&#34;{email}{orgRep}&#34;&#34;&#34;
            if email
            else f&#34;&#34;&#34;{eppn}{authorityRep}&#34;&#34;&#34;
            if eppn
            else Qu
        )
        + &#34;&#34;&#34; from &#34;&#34;&#34;
        + (countryShort)
    )
    return identityRep</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.nameEmail"><code class="name flex">
<span>def <span class="ident">nameEmail</span></span>(<span>self, user=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Provide a string representation of the name and email of the user.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Care will be taken that to unauthenticated users only
limited information about users will be shown.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>The user whose identity must be represented.
If absent, the currently logged in user will be taken.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nameEmail(self, user=None):
    &#34;&#34;&#34;Provide a string representation of the name and email of the user.

    !!! note
        Care will be taken that to unauthenticated users only
        limited information about users will be shown.

    Parameters
    ----------
    user: dict, optional `None`
        The user whose identity must be represented.
        If absent, the currently logged in user will be taken.

    Returns
    -------
    string
    &#34;&#34;&#34;

    if user is None:
        user = self.user

    name = G(user, N.name) or E
    if not name:
        firstName = G(user, N.firstName) or E
        lastName = G(user, N.lastName) or E
        name = firstName + (BLANK if firstName and lastName else E) + lastName
    group = self.groupRep(user=user)
    isAuth = group != UNAUTH
    email = (G(user, N.email) or E) if isAuth else E
    return (name, email)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.officeuser"><code class="name flex">
<span>def <span class="ident">officeuser</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Is the current user a backoffice user?</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def officeuser(self):
    &#34;&#34;&#34;Is the current user a backoffice user?

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    user = self.user
    return officeuser(user)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.superuser"><code class="name flex">
<span>def <span class="ident">superuser</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Is the current user a super user?</p>
<p>Superusers are backoffice users, sysadmins and root.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def superuser(self):
    &#34;&#34;&#34;Is the current user a super user?

    Superusers are backoffice users, sysadmins and root.

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    user = self.user
    return superuser(user)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.sysadmin"><code class="name flex">
<span>def <span class="ident">sysadmin</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Is the current user a system administrator?</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sysadmin(self):
    &#34;&#34;&#34;Is the current user a system administrator?

    Returns
    -------
    boolean
    &#34;&#34;&#34;

    user = self.user
    return sysadmin(user)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.wrapTestUsers"><code class="name flex">
<span>def <span class="ident">wrapTestUsers</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Present a widget to select a test user for login.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>In production this will do nothing.
Only in development mode one can select a test user.</p>
</div></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapTestUsers(self):
    &#34;&#34;&#34;Present a widget to select a test user for login.

    !!! caution
        In production this will do nothing.
        Only in development mode one can select a test user.
    &#34;&#34;&#34;
    if not self.isDevel:
        return E

    db = self.db

    testUsers = {
        record[N.eppn]: record
        for record in db.user.values()
        if N.eppn in record and G(record, N.authority) == N.local
    }
    return H.join(
        [
            H.div(H.a(u, href=f&#34;/login?eppn={u}&#34;, cls=&#34;button small&#34;))
            for u in testUsers
        ]
        + [
            H.div(
                H.input(
                    E,
                    placeholder=&#34;email&#34;,
                    onchange=&#34;window.location.href=`/login?email=${this.value}`&#34;,
                )
            )
        ]
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.auth.Auth" href="#control.auth.Auth">Auth</a></code></h4>
<ul class="two-column">
<li><code><a title="control.auth.Auth.authId" href="#control.auth.Auth.authId">authId</a></code></li>
<li><code><a title="control.auth.Auth.authUser" href="#control.auth.Auth.authUser">authUser</a></code></li>
<li><code><a title="control.auth.Auth.authenticate" href="#control.auth.Auth.authenticate">authenticate</a></code></li>
<li><code><a title="control.auth.Auth.authenticated" href="#control.auth.Auth.authenticated">authenticated</a></code></li>
<li><code><a title="control.auth.Auth.authority" href="#control.auth.Auth.authority">authority</a></code></li>
<li><code><a title="control.auth.Auth.checkLogin" href="#control.auth.Auth.checkLogin">checkLogin</a></code></li>
<li><code><a title="control.auth.Auth.clearUser" href="#control.auth.Auth.clearUser">clearUser</a></code></li>
<li><code><a title="control.auth.Auth.coordinator" href="#control.auth.Auth.coordinator">coordinator</a></code></li>
<li><code><a title="control.auth.Auth.country" href="#control.auth.Auth.country">country</a></code></li>
<li><code><a title="control.auth.Auth.countryRep" href="#control.auth.Auth.countryRep">countryRep</a></code></li>
<li><code><a title="control.auth.Auth.credentials" href="#control.auth.Auth.credentials">credentials</a></code></li>
<li><code><a title="control.auth.Auth.db" href="#control.auth.Auth.db">db</a></code></li>
<li><code><a title="control.auth.Auth.deauthenticate" href="#control.auth.Auth.deauthenticate">deauthenticate</a></code></li>
<li><code><a title="control.auth.Auth.getUser" href="#control.auth.Auth.getUser">getUser</a></code></li>
<li><code><a title="control.auth.Auth.groupRep" href="#control.auth.Auth.groupRep">groupRep</a></code></li>
<li><code><a title="control.auth.Auth.identity" href="#control.auth.Auth.identity">identity</a></code></li>
<li><code><a title="control.auth.Auth.isDevel" href="#control.auth.Auth.isDevel">isDevel</a></code></li>
<li><code><a title="control.auth.Auth.nameEmail" href="#control.auth.Auth.nameEmail">nameEmail</a></code></li>
<li><code><a title="control.auth.Auth.officeuser" href="#control.auth.Auth.officeuser">officeuser</a></code></li>
<li><code><a title="control.auth.Auth.superuser" href="#control.auth.Auth.superuser">superuser</a></code></li>
<li><code><a title="control.auth.Auth.sysadmin" href="#control.auth.Auth.sysadmin">sysadmin</a></code></li>
<li><code><a title="control.auth.Auth.unauthId" href="#control.auth.Auth.unauthId">unauthId</a></code></li>
<li><code><a title="control.auth.Auth.unauthUser" href="#control.auth.Auth.unauthUser">unauthUser</a></code></li>
<li><code><a title="control.auth.Auth.user" href="#control.auth.Auth.user">user</a></code></li>
<li><code><a title="control.auth.Auth.wrapTestUsers" href="#control.auth.Auth.wrapTestUsers">wrapTestUsers</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>