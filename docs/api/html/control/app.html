<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>control.app API documentation</title>
<meta name="description" content="Sets up the Flask app with all its routes." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.app</code></h1>
</header>
<section id="section-intro">
<p>Sets up the Flask app with all its routes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Sets up the Flask app with all its routes.
&#34;&#34;&#34;

import os
from itertools import chain

from flask import (
    Flask,
    request,
    render_template,
    send_file,
    redirect,
    abort,
    flash,
)

from config import Config as C, Names as N
from control.utils import pick as G, E, serverprint
from control.db import Db
from control.workflow.compute import Workflow
from control.workflow.apply import execute
from control.perm import checkTable
from control.auth import Auth
from control.context import Context
from control.sidebar import Sidebar
from control.topbar import Topbar
from control.overview import Overview
from control.cust.factory_table import make as mkTable


CB = C.base
CT = C.tables
CW = C.web

SECRET_FILE = CB.secretFile

STATIC_ROOT = os.path.abspath(CW.staticRoot)
&#34;&#34;&#34;The url to the directory from which static files are served.&#34;&#34;&#34;

ALL_TABLES = CT.all
USER_TABLES_LIST = CT.userTables
USER_TABLES = set(USER_TABLES_LIST)
MASTERS = CT.masters
DETAILS = CT.details

LIMITS = CW.limits

URLS = CW.urls
&#34;&#34;&#34;A dictionary of fixed fall-back urls.&#34;&#34;&#34;

MESSAGES = CW.messages
&#34;&#34;&#34;A dictionary of fixed messages for display on the web interface.&#34;&#34;&#34;

INDEX = CW.indexPage
LANDING = CW.landing
BODY_METHODS = set(CW.bodyMethods)
LIST_ACTIONS = set(CW.listActions)
FIELD_ACTIONS = set(CW.fieldActions)

START = URLS[N.home][N.url]
OVERVIEW = URLS[N.info][N.url]
DUMMY = URLS[N.dummy][N.url]
LOGIN = URLS[N.login][N.url]
LOGOUT = URLS[N.logout][N.url]
SLOGOUT = URLS[N.slogout][N.url]
WORKFLOW = URLS[N.workflow][N.url]
SHIB_LOGOUT = URLS[N.shibLogout][N.url]
NO_PAGE = MESSAGES[N.noPage]
NO_TASK = MESSAGES[N.noTask]
NO_TABLE = MESSAGES[N.noTable]
NO_RECORD = MESSAGES[N.noRecord]
NO_FIELD = MESSAGES[N.noField]
NO_ACTION = MESSAGES[N.noAction]


def redirectResult(url, good):
    &#34;&#34;&#34;Redirect.

    Parameters
    ----------
    url: string
        The url to redirect to
    good:
        Whether the redirection corresponds to a normal scenario or is the result of
        an error

    Returns
    -------
    response
        A redirect response with either code 302 (good) or 303 (bad)
    &#34;&#34;&#34;

    code = 302 if good else 303
    return redirect(url, code=code)


def checkBounds(**kwargs):
    &#34;&#34;&#34;Aggressive check on the arguments passed in an url and/or request.

    First the total length of the request is counted.
    If it is too much, the request will be aborted.

    Each argument in request.args and `kwargs` must have a name that is allowed
    and its value should have a length under an appropriate limit,
    configured in `web.yaml`. There is always a fallback limit.

    !!! caution &#34;Security&#34;
        Before processing any request arg, whether from a form or from the url,
        use this function to check whether the length is within limits.

        If the length is exceeded, fail with a bad request,
        without giving any useful feedback.
        Because in this case we are dealing with a hacker.

    Parameters
    ----------
    kwargs: dict
        The key-values that need to be checked.

    Raises
    ------
    HTTPException
        If the length of any argument is out of bounds,
        processing is aborted and a bad request response
        is delivered
    &#34;&#34;&#34;

    default = G(LIMITS, N.default, default=100)
    maxLen = G(LIMITS, N.request, default=default)

    if request.content_length and request.content_length &gt; maxLen:
        abort(400)

    n = len(request.args)
    boundN = G(LIMITS, N.keys, default=default)
    if len(kwargs) &gt; boundN:
        serverprint(f&#34;&#34;&#34;OUT-OF-BOUNDS: {n} &gt; {boundN} KEYS IN {kwargs}&#34;&#34;&#34;)
        abort(400)
    for (k, v) in chain.from_iterable((kwargs.items(), request.args.items())):
        if k not in LIMITS:
            abort(400)
        valN = G(LIMITS, k, default=default)
        if v is not None and len(v) &gt; valN:
            serverprint(f&#34;&#34;&#34;OUT-OF-BOUNDS: LENGTH ARG &#34;{k}&#34; &gt; {valN} ({v})&#34;&#34;&#34;)
            abort(400)


def appFactory(regime, test, debug, **kwargs):
    &#34;&#34;&#34;Creates the flask app that serves the website.

    We read a secret key from the system which is stored in a file outside the app.
    This information is needed to encrypt sessions.

    !!! caution
        We read and cache substantial information from MongoDb before
        forking into workers.
        Before we fork, we close the MongoDb connection, because PyMongo is not
        [fork-safe](https://api.mongodb.com/python/current/faq.html#is-pymongo-fork-safe).

    Parameters
    ----------
    regime: {development, production}
    test: boolean
        Whether the app is in test mode.
    debug: boolean
        Whether to generate debug messages for certain actions.
    kwargs: dict
        Additional parameters to tweak the behaviour of the Flask application.
        They will be passed to the object initializer `Flask()`.

    Returns
    -------
    object
        The flask app.
    &#34;&#34;&#34;

    kwargs[&#34;static_url_path&#34;] = DUMMY

    app = Flask(__name__, **kwargs)
    if test:
        app.config.from_mapping(dict(TESTING=True))

    with open(SECRET_FILE) as fh:
        app.secret_key = fh.read()

    GP = dict(methods=[N.GET, N.POST])

    DB = Db(regime, test=test)
    &#34;&#34;&#34;*object* The `control.db.Db` singleton.&#34;&#34;&#34;

    WF = Workflow(DB)
    &#34;&#34;&#34;*object* The `control.workflow.compute.Workflow` singleton.&#34;&#34;&#34;

    WF.initWorkflow(drop=True)

    auth = Auth(DB, regime)

    DB.mongoClose()

    def getContext():
        return Context(DB, WF, auth)

    def tablePerm(table, action=None):
        return checkTable(auth, table) and (action is None or auth.authenticated())

    if debug and auth.isDevel:
        CT.showReferences()
        N.showNames()

    @app.route(f&#34;&#34;&#34;/whoami&#34;&#34;&#34;)
    def serveWhoami():
        checkBounds()
        if auth.authenticated():
            return G(auth.user, N.eppn)
        else:
            return N.public

    @app.route(f&#34;&#34;&#34;/{N.static}/&lt;path:filepath&gt;&#34;&#34;&#34;)
    def serveStatic(filepath):
        checkBounds(filepath=filepath)

        path = f&#34;&#34;&#34;{STATIC_ROOT}/{filepath}&#34;&#34;&#34;
        if os.path.isfile(path):
            return send_file(path)
        flash(f&#34;file not found: {filepath}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(f&#34;&#34;&#34;/{N.favicons}/&lt;path:filepath&gt;&#34;&#34;&#34;)
    def serveFavicons(filepath):
        checkBounds(filepath=filepath)

        path = f&#34;&#34;&#34;{STATIC_ROOT}/{N.favicons}/{filepath}&#34;&#34;&#34;
        if os.path.isfile(path):
            return send_file(path)
        flash(f&#34;icon not found: {filepath}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(START)
    @app.route(f&#34;&#34;&#34;/{N.index}&#34;&#34;&#34;)
    @app.route(f&#34;&#34;&#34;/{INDEX}&#34;&#34;&#34;)
    def serveIndex():
        checkBounds()
        path = START
        context = getContext()
        auth.authenticate()
        topbar = Topbar(context).wrap()
        sidebar = Sidebar(context, path).wrap()
        return render_template(INDEX, topbar=topbar, sidebar=sidebar, material=LANDING)

    # OVERVIEW PAGE

    @app.route(f&#34;&#34;&#34;{OVERVIEW}&#34;&#34;&#34;)
    def serveOverview():
        checkBounds()
        path = START
        context = getContext()
        auth.authenticate()
        topbar = Topbar(context).wrap()
        sidebar = Sidebar(context, path).wrap()
        overview = Overview(context).wrap()
        return render_template(INDEX, topbar=topbar, sidebar=sidebar, material=overview)

    @app.route(f&#34;&#34;&#34;{OVERVIEW}.tsv&#34;&#34;&#34;)
    def serveOverviewTsv():
        checkBounds()
        context = getContext()
        auth.authenticate()
        return Overview(context).wrap(asTsv=True)

    # LOGIN / LOGOUT

    @app.route(f&#34;&#34;&#34;{SLOGOUT}&#34;&#34;&#34;)
    def serveSlogout():
        checkBounds()
        if auth.authenticated():
            auth.deauthenticate()
            flash(&#34;logged out from DARIAH&#34;)
            return redirectResult(SHIB_LOGOUT, True)
        flash(&#34;you were not logged in&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(f&#34;&#34;&#34;{LOGIN}&#34;&#34;&#34;)
    def serveLogin():
        checkBounds()
        if auth.authenticated():
            flash(&#34;you are already logged in&#34;)
        good = True
        if auth.authenticate(login=True):
            flash(&#34;log in successful&#34;)
        else:
            good = False
            flash(&#34;log in unsuccessful&#34;, &#34;error&#34;)
        return redirectResult(START, good)

    @app.route(f&#34;&#34;&#34;{LOGOUT}&#34;&#34;&#34;)
    def serveLogout():
        checkBounds()
        if auth.authenticated():
            auth.deauthenticate()
            flash(&#34;logged out&#34;)
            return redirectResult(START, True)
        flash(&#34;you were not logged in&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    # SYSADMIN

    @app.route(f&#34;&#34;&#34;{WORKFLOW}&#34;&#34;&#34;)
    def serveWorkflow():
        checkBounds()
        context = getContext()
        auth.authenticate()
        nWf = context.resetWorkflow()
        if nWf &gt;= 0:
            flash(f&#34;{nWf} workflow records recomputed and stored&#34;)
        else:
            flash(&#34;workflow not recomputed&#34;, &#34;error&#34;)
        return redirectResult(START, nWf &gt;= 0)

    # WORKFLOW TASKS

    @app.route(f&#34;&#34;&#34;/api/task/&lt;string:task&gt;/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveTask(task, eid):
        checkBounds(task=task, eid=eid)

        context = getContext()
        auth.authenticate()
        (good, newPath) = execute(context, task, eid)
        if not good and newPath is None:
            newPath = START
        return redirectResult(newPath, good)

    # INSERT RECORD IN TABLE

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.insert}&#34;&#34;&#34;)
    def serveTableInsert(table):
        checkBounds(table=table)

        newPath = f&#34;&#34;&#34;/{table}/{N.list}&#34;&#34;&#34;
        if table in ALL_TABLES and table not in MASTERS:
            context = getContext()
            auth.authenticate()
            eid = None
            if tablePerm(table):
                eid = mkTable(context, table).insert()
            if eid:
                newPath = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
                flash(f&#34;item added&#34;)
        else:
            flash(f&#34;Cannot add items to {table}&#34;, &#34;error&#34;)
        return redirectResult(newPath, eid is not None)

    # INSERT RECORD IN DETAIL TABLE

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/&lt;string:eid&gt;/&lt;string:dtable&gt;/{N.insert}&#34;&#34;&#34;)
    def serveTableInsertDetail(table, eid, dtable):
        checkBounds(table=table, eid=eid, dtable=dtable)

        newPath = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
        dEid = None
        if (
            table in USER_TABLES_LIST[0:2]
            and table in DETAILS
            and dtable in DETAILS[table]
        ):
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                dEid = mkTable(context, dtable).insert(masterTable=table, masterId=eid)
            if dEid:
                newPath = f&#34;&#34;&#34;/{table}/{N.item}/{eid}/{N.open}/{dtable}/{dEid}&#34;&#34;&#34;
        if dEid:
            flash(f&#34;{dtable} item added&#34;)
        else:
            flash(f&#34;Cannot add a {dtable} here&#34;, &#34;error&#34;)
        return redirectResult(newPath, dEid is not None)

    # LIST VIEWS ON TABLE

    @app.route(f&#34;&#34;&#34;/&lt;string:table&gt;/{N.list}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveTableListOpen(table, eid):
        checkBounds(table=table, eid=eid)

        return serveTable(table, eid)

    @app.route(f&#34;&#34;&#34;/&lt;string:table&gt;/{N.list}&#34;&#34;&#34;)
    def serveTableList(table):
        checkBounds(table=table)

        return serveTable(table, None)

    def serveTable(table, eid):
        checkBounds()
        action = G(request.args, N.action)
        actionRep = f&#34;?action={action}&#34; if action else E
        eidRep = f&#34;&#34;&#34;/{eid}&#34;&#34;&#34; if eid else E
        path = f&#34;&#34;&#34;/{table}/{N.list}{eidRep}{actionRep}&#34;&#34;&#34;
        if not action or action in LIST_ACTIONS:
            if table in ALL_TABLES:
                context = getContext()
                auth.authenticate()
                topbar = Topbar(context).wrap()
                sidebar = Sidebar(context, path).wrap()
                tableList = None
                if tablePerm(table, action=action):
                    tableList = mkTable(context, table).wrap(eid, action=action)
                if tableList is None:
                    flash(f&#34;{action or E} view on {table} not allowed&#34;, &#34;error&#34;)
                    return redirectResult(START, False)
                return render_template(
                    INDEX, topbar=topbar, sidebar=sidebar, material=tableList,
                )
            flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        if action:
            flash(f&#34;Unknown view {action}&#34;, &#34;error&#34;)
        else:
            flash(f&#34;Missing view&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    # RECORD DELETE

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.delete}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveRecordDelete(table, eid):
        checkBounds(table=table, eid=eid)

        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            good = False
            if tablePerm(table):
                good = mkTable(context, table).record(eid=eid).delete()
                newUrlPart = f&#34;?{N.action}={N.my}&#34; if table in USER_TABLES else E
                newPath = f&#34;&#34;&#34;/{table}/{N.list}{newUrlPart}&#34;&#34;&#34;
            if good:
                flash(&#34;item deleted&#34;)
            else:
                flash(&#34;item not deleted&#34;, &#34;error&#34;)
            return redirectResult(newPath, good)
        flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    # RECORD DELETE DETAIL

    @app.route(
        f&#34;&#34;&#34;/api/&lt;string:table&gt;/&lt;string:masterId&gt;/&#34;&#34;&#34;
        f&#34;&#34;&#34;&lt;string:dtable&gt;/{N.delete}/&lt;string:eid&gt;&#34;&#34;&#34;
    )
    def serveRecordDeleteDetail(table, masterId, dtable, eid):
        checkBounds(table=table, masterId=masterId, dtable=dtable, eid=eid)

        newPath = f&#34;&#34;&#34;/{table}/{N.item}/{masterId}&#34;&#34;&#34;
        good = False
        if (
            table in USER_TABLES_LIST[0:2]
            and table in DETAILS
            and dtable in DETAILS[table]
        ):
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                recordObj = mkTable(context, dtable).record(eid=eid)

                wfitem = recordObj.wfitem
                if wfitem:
                    good = recordObj.delete()

        if good:
            flash(f&#34;{dtable} detail deleted&#34;)
        else:
            flash(f&#34;{dtable} detail not deleted&#34;, &#34;error&#34;)
        return redirectResult(newPath, good)

    # RECORD VIEW

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveRecord(table, eid):
        checkBounds(table=table, eid=eid)

        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=True, **method()
                )
                if recordObj.mayRead is not False:
                    return recordObj.wrap()
        return noRecord(table)

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;/{N.title}&#34;&#34;&#34;)
    def serveRecordTitle(table, eid):
        checkBounds(table=table, eid=eid)

        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=False, **method()
                )
                if recordObj.mayRead is not False:
                    return recordObj.wrap(expanded=-1)
        return noRecord(table)

    # with specific detail opened

    @app.route(
        f&#34;&#34;&#34;/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;/&#34;&#34;&#34;
        f&#34;&#34;&#34;{N.open}/&lt;string:dtable&gt;/&lt;string:deid&gt;&#34;&#34;&#34;
    )
    def serveRecordPageDetail(table, eid, dtable, deid):
        checkBounds(table=table, eid=eid, dtable=dtable, deid=deid)

        path = f&#34;&#34;&#34;/{table}/{N.item}/{eid}/{N.open}/{dtable}/{deid}&#34;&#34;&#34;
        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            topbar = Topbar(context).wrap()
            sidebar = Sidebar(context, path).wrap()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=True, **method()
                )
                if recordObj.mayRead is not False:
                    record = recordObj.wrap(showTable=dtable, showEid=deid)
                    return render_template(
                        INDEX, topbar=topbar, sidebar=sidebar, material=record,
                    )
                flash(f&#34;Unknown record in table {table}&#34;, &#34;error&#34;)
                return redirectResult(f&#34;&#34;&#34;/{table}/{N.list}&#34;&#34;&#34;, False)
        flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(f&#34;&#34;&#34;/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveRecordPageDet(table, eid):
        checkBounds(table=table, eid=eid)

        path = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            topbar = Topbar(context).wrap()
            sidebar = Sidebar(context, path).wrap()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=True, **method()
                )
                if recordObj.mayRead is not False:
                    record = recordObj.wrap()
                    return render_template(
                        INDEX, topbar=topbar, sidebar=sidebar, material=record,
                    )
                flash(f&#34;Unknown record in table {table}&#34;, &#34;error&#34;)
                return redirectResult(f&#34;&#34;&#34;/{table}/{N.list}&#34;&#34;&#34;, False)
        flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    def method():
        method = G(request.args, N.method)
        if method not in BODY_METHODS:
            return {}
        return dict(bodyMethod=method)

    # FIELD VIEWS AND EDITS

    @app.route(
        f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;/{N.field}/&lt;string:field&gt;&#34;&#34;&#34;, **GP
    )
    def serveField(table, eid, field):
        checkBounds(table=table, eid=eid, field=field)

        action = G(request.args, N.action)
        if action in FIELD_ACTIONS:
            context = getContext()
            auth.authenticate()
            if table in ALL_TABLES and tablePerm(table):
                recordObj = mkTable(context, table).record(eid=eid)
                if recordObj.mayRead is not False:
                    fieldObj = mkTable(context, table).record(eid=eid).field(field)
                    if fieldObj:
                        return fieldObj.wrap(action=action)
                    return noField(table, field)
                return noRecord(table)
            return noTable(table)
        return noAction(action)

    # FALL-BACK

    @app.route(f&#34;&#34;&#34;/&lt;path:anything&gt;&#34;&#34;&#34;)
    def serveNotFound(anything=None):
        checkBounds(anything=anything)

        flash(f&#34;Cannot find {anything}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    def noTable(table):
        return f&#34;&#34;&#34;{NO_TABLE} {table}&#34;&#34;&#34;

    def noRecord(table):
        return f&#34;&#34;&#34;{NO_RECORD} {table}&#34;&#34;&#34;

    def noField(table, field):
        return f&#34;&#34;&#34;{NO_FIELD} {table}:{field}&#34;&#34;&#34;

    def noAction(action):
        return f&#34;&#34;&#34;{NO_ACTION} {action}&#34;&#34;&#34;

    return app</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="control.app.MESSAGES"><code class="name">var <span class="ident">MESSAGES</span></code></dt>
<dd>
<section class="desc"><p>A dictionary of fixed messages for display on the web interface.</p></section>
</dd>
<dt id="control.app.STATIC_ROOT"><code class="name">var <span class="ident">STATIC_ROOT</span></code></dt>
<dd>
<section class="desc"><p>The url to the directory from which static files are served.</p></section>
</dd>
<dt id="control.app.URLS"><code class="name">var <span class="ident">URLS</span></code></dt>
<dd>
<section class="desc"><p>A dictionary of fixed fall-back urls.</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="control.app.appFactory"><code class="name flex">
<span>def <span class="ident">appFactory</span></span>(<span>regime, test, debug, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates the flask app that serves the website.</p>
<p>We read a secret key from the system which is stored in a file outside the app.
This information is needed to encrypt sessions.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>We read and cache substantial information from MongoDb before
forking into workers.
Before we fork, we close the MongoDb connection, because PyMongo is not
<a href="https://api.mongodb.com/python/current/faq.html#is-pymongo-fork-safe">fork-safe</a>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>regime</code></strong> :&ensp;{<code>development</code>, <code>production</code>}</dt>
<dd>&nbsp;</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the app is in test mode.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to generate debug messages for certain actions.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional parameters to tweak the behaviour of the Flask application.
They will be passed to the object initializer <code>Flask()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The flask app.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appFactory(regime, test, debug, **kwargs):
    &#34;&#34;&#34;Creates the flask app that serves the website.

    We read a secret key from the system which is stored in a file outside the app.
    This information is needed to encrypt sessions.

    !!! caution
        We read and cache substantial information from MongoDb before
        forking into workers.
        Before we fork, we close the MongoDb connection, because PyMongo is not
        [fork-safe](https://api.mongodb.com/python/current/faq.html#is-pymongo-fork-safe).

    Parameters
    ----------
    regime: {development, production}
    test: boolean
        Whether the app is in test mode.
    debug: boolean
        Whether to generate debug messages for certain actions.
    kwargs: dict
        Additional parameters to tweak the behaviour of the Flask application.
        They will be passed to the object initializer `Flask()`.

    Returns
    -------
    object
        The flask app.
    &#34;&#34;&#34;

    kwargs[&#34;static_url_path&#34;] = DUMMY

    app = Flask(__name__, **kwargs)
    if test:
        app.config.from_mapping(dict(TESTING=True))

    with open(SECRET_FILE) as fh:
        app.secret_key = fh.read()

    GP = dict(methods=[N.GET, N.POST])

    DB = Db(regime, test=test)
    &#34;&#34;&#34;*object* The `control.db.Db` singleton.&#34;&#34;&#34;

    WF = Workflow(DB)
    &#34;&#34;&#34;*object* The `control.workflow.compute.Workflow` singleton.&#34;&#34;&#34;

    WF.initWorkflow(drop=True)

    auth = Auth(DB, regime)

    DB.mongoClose()

    def getContext():
        return Context(DB, WF, auth)

    def tablePerm(table, action=None):
        return checkTable(auth, table) and (action is None or auth.authenticated())

    if debug and auth.isDevel:
        CT.showReferences()
        N.showNames()

    @app.route(f&#34;&#34;&#34;/whoami&#34;&#34;&#34;)
    def serveWhoami():
        checkBounds()
        if auth.authenticated():
            return G(auth.user, N.eppn)
        else:
            return N.public

    @app.route(f&#34;&#34;&#34;/{N.static}/&lt;path:filepath&gt;&#34;&#34;&#34;)
    def serveStatic(filepath):
        checkBounds(filepath=filepath)

        path = f&#34;&#34;&#34;{STATIC_ROOT}/{filepath}&#34;&#34;&#34;
        if os.path.isfile(path):
            return send_file(path)
        flash(f&#34;file not found: {filepath}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(f&#34;&#34;&#34;/{N.favicons}/&lt;path:filepath&gt;&#34;&#34;&#34;)
    def serveFavicons(filepath):
        checkBounds(filepath=filepath)

        path = f&#34;&#34;&#34;{STATIC_ROOT}/{N.favicons}/{filepath}&#34;&#34;&#34;
        if os.path.isfile(path):
            return send_file(path)
        flash(f&#34;icon not found: {filepath}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(START)
    @app.route(f&#34;&#34;&#34;/{N.index}&#34;&#34;&#34;)
    @app.route(f&#34;&#34;&#34;/{INDEX}&#34;&#34;&#34;)
    def serveIndex():
        checkBounds()
        path = START
        context = getContext()
        auth.authenticate()
        topbar = Topbar(context).wrap()
        sidebar = Sidebar(context, path).wrap()
        return render_template(INDEX, topbar=topbar, sidebar=sidebar, material=LANDING)

    # OVERVIEW PAGE

    @app.route(f&#34;&#34;&#34;{OVERVIEW}&#34;&#34;&#34;)
    def serveOverview():
        checkBounds()
        path = START
        context = getContext()
        auth.authenticate()
        topbar = Topbar(context).wrap()
        sidebar = Sidebar(context, path).wrap()
        overview = Overview(context).wrap()
        return render_template(INDEX, topbar=topbar, sidebar=sidebar, material=overview)

    @app.route(f&#34;&#34;&#34;{OVERVIEW}.tsv&#34;&#34;&#34;)
    def serveOverviewTsv():
        checkBounds()
        context = getContext()
        auth.authenticate()
        return Overview(context).wrap(asTsv=True)

    # LOGIN / LOGOUT

    @app.route(f&#34;&#34;&#34;{SLOGOUT}&#34;&#34;&#34;)
    def serveSlogout():
        checkBounds()
        if auth.authenticated():
            auth.deauthenticate()
            flash(&#34;logged out from DARIAH&#34;)
            return redirectResult(SHIB_LOGOUT, True)
        flash(&#34;you were not logged in&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(f&#34;&#34;&#34;{LOGIN}&#34;&#34;&#34;)
    def serveLogin():
        checkBounds()
        if auth.authenticated():
            flash(&#34;you are already logged in&#34;)
        good = True
        if auth.authenticate(login=True):
            flash(&#34;log in successful&#34;)
        else:
            good = False
            flash(&#34;log in unsuccessful&#34;, &#34;error&#34;)
        return redirectResult(START, good)

    @app.route(f&#34;&#34;&#34;{LOGOUT}&#34;&#34;&#34;)
    def serveLogout():
        checkBounds()
        if auth.authenticated():
            auth.deauthenticate()
            flash(&#34;logged out&#34;)
            return redirectResult(START, True)
        flash(&#34;you were not logged in&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    # SYSADMIN

    @app.route(f&#34;&#34;&#34;{WORKFLOW}&#34;&#34;&#34;)
    def serveWorkflow():
        checkBounds()
        context = getContext()
        auth.authenticate()
        nWf = context.resetWorkflow()
        if nWf &gt;= 0:
            flash(f&#34;{nWf} workflow records recomputed and stored&#34;)
        else:
            flash(&#34;workflow not recomputed&#34;, &#34;error&#34;)
        return redirectResult(START, nWf &gt;= 0)

    # WORKFLOW TASKS

    @app.route(f&#34;&#34;&#34;/api/task/&lt;string:task&gt;/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveTask(task, eid):
        checkBounds(task=task, eid=eid)

        context = getContext()
        auth.authenticate()
        (good, newPath) = execute(context, task, eid)
        if not good and newPath is None:
            newPath = START
        return redirectResult(newPath, good)

    # INSERT RECORD IN TABLE

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.insert}&#34;&#34;&#34;)
    def serveTableInsert(table):
        checkBounds(table=table)

        newPath = f&#34;&#34;&#34;/{table}/{N.list}&#34;&#34;&#34;
        if table in ALL_TABLES and table not in MASTERS:
            context = getContext()
            auth.authenticate()
            eid = None
            if tablePerm(table):
                eid = mkTable(context, table).insert()
            if eid:
                newPath = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
                flash(f&#34;item added&#34;)
        else:
            flash(f&#34;Cannot add items to {table}&#34;, &#34;error&#34;)
        return redirectResult(newPath, eid is not None)

    # INSERT RECORD IN DETAIL TABLE

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/&lt;string:eid&gt;/&lt;string:dtable&gt;/{N.insert}&#34;&#34;&#34;)
    def serveTableInsertDetail(table, eid, dtable):
        checkBounds(table=table, eid=eid, dtable=dtable)

        newPath = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
        dEid = None
        if (
            table in USER_TABLES_LIST[0:2]
            and table in DETAILS
            and dtable in DETAILS[table]
        ):
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                dEid = mkTable(context, dtable).insert(masterTable=table, masterId=eid)
            if dEid:
                newPath = f&#34;&#34;&#34;/{table}/{N.item}/{eid}/{N.open}/{dtable}/{dEid}&#34;&#34;&#34;
        if dEid:
            flash(f&#34;{dtable} item added&#34;)
        else:
            flash(f&#34;Cannot add a {dtable} here&#34;, &#34;error&#34;)
        return redirectResult(newPath, dEid is not None)

    # LIST VIEWS ON TABLE

    @app.route(f&#34;&#34;&#34;/&lt;string:table&gt;/{N.list}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveTableListOpen(table, eid):
        checkBounds(table=table, eid=eid)

        return serveTable(table, eid)

    @app.route(f&#34;&#34;&#34;/&lt;string:table&gt;/{N.list}&#34;&#34;&#34;)
    def serveTableList(table):
        checkBounds(table=table)

        return serveTable(table, None)

    def serveTable(table, eid):
        checkBounds()
        action = G(request.args, N.action)
        actionRep = f&#34;?action={action}&#34; if action else E
        eidRep = f&#34;&#34;&#34;/{eid}&#34;&#34;&#34; if eid else E
        path = f&#34;&#34;&#34;/{table}/{N.list}{eidRep}{actionRep}&#34;&#34;&#34;
        if not action or action in LIST_ACTIONS:
            if table in ALL_TABLES:
                context = getContext()
                auth.authenticate()
                topbar = Topbar(context).wrap()
                sidebar = Sidebar(context, path).wrap()
                tableList = None
                if tablePerm(table, action=action):
                    tableList = mkTable(context, table).wrap(eid, action=action)
                if tableList is None:
                    flash(f&#34;{action or E} view on {table} not allowed&#34;, &#34;error&#34;)
                    return redirectResult(START, False)
                return render_template(
                    INDEX, topbar=topbar, sidebar=sidebar, material=tableList,
                )
            flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        if action:
            flash(f&#34;Unknown view {action}&#34;, &#34;error&#34;)
        else:
            flash(f&#34;Missing view&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    # RECORD DELETE

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.delete}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveRecordDelete(table, eid):
        checkBounds(table=table, eid=eid)

        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            good = False
            if tablePerm(table):
                good = mkTable(context, table).record(eid=eid).delete()
                newUrlPart = f&#34;?{N.action}={N.my}&#34; if table in USER_TABLES else E
                newPath = f&#34;&#34;&#34;/{table}/{N.list}{newUrlPart}&#34;&#34;&#34;
            if good:
                flash(&#34;item deleted&#34;)
            else:
                flash(&#34;item not deleted&#34;, &#34;error&#34;)
            return redirectResult(newPath, good)
        flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    # RECORD DELETE DETAIL

    @app.route(
        f&#34;&#34;&#34;/api/&lt;string:table&gt;/&lt;string:masterId&gt;/&#34;&#34;&#34;
        f&#34;&#34;&#34;&lt;string:dtable&gt;/{N.delete}/&lt;string:eid&gt;&#34;&#34;&#34;
    )
    def serveRecordDeleteDetail(table, masterId, dtable, eid):
        checkBounds(table=table, masterId=masterId, dtable=dtable, eid=eid)

        newPath = f&#34;&#34;&#34;/{table}/{N.item}/{masterId}&#34;&#34;&#34;
        good = False
        if (
            table in USER_TABLES_LIST[0:2]
            and table in DETAILS
            and dtable in DETAILS[table]
        ):
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                recordObj = mkTable(context, dtable).record(eid=eid)

                wfitem = recordObj.wfitem
                if wfitem:
                    good = recordObj.delete()

        if good:
            flash(f&#34;{dtable} detail deleted&#34;)
        else:
            flash(f&#34;{dtable} detail not deleted&#34;, &#34;error&#34;)
        return redirectResult(newPath, good)

    # RECORD VIEW

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveRecord(table, eid):
        checkBounds(table=table, eid=eid)

        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=True, **method()
                )
                if recordObj.mayRead is not False:
                    return recordObj.wrap()
        return noRecord(table)

    @app.route(f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;/{N.title}&#34;&#34;&#34;)
    def serveRecordTitle(table, eid):
        checkBounds(table=table, eid=eid)

        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=False, **method()
                )
                if recordObj.mayRead is not False:
                    return recordObj.wrap(expanded=-1)
        return noRecord(table)

    # with specific detail opened

    @app.route(
        f&#34;&#34;&#34;/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;/&#34;&#34;&#34;
        f&#34;&#34;&#34;{N.open}/&lt;string:dtable&gt;/&lt;string:deid&gt;&#34;&#34;&#34;
    )
    def serveRecordPageDetail(table, eid, dtable, deid):
        checkBounds(table=table, eid=eid, dtable=dtable, deid=deid)

        path = f&#34;&#34;&#34;/{table}/{N.item}/{eid}/{N.open}/{dtable}/{deid}&#34;&#34;&#34;
        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            topbar = Topbar(context).wrap()
            sidebar = Sidebar(context, path).wrap()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=True, **method()
                )
                if recordObj.mayRead is not False:
                    record = recordObj.wrap(showTable=dtable, showEid=deid)
                    return render_template(
                        INDEX, topbar=topbar, sidebar=sidebar, material=record,
                    )
                flash(f&#34;Unknown record in table {table}&#34;, &#34;error&#34;)
                return redirectResult(f&#34;&#34;&#34;/{table}/{N.list}&#34;&#34;&#34;, False)
        flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    @app.route(f&#34;&#34;&#34;/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;&#34;&#34;&#34;)
    def serveRecordPageDet(table, eid):
        checkBounds(table=table, eid=eid)

        path = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
        if table in ALL_TABLES:
            context = getContext()
            auth.authenticate()
            topbar = Topbar(context).wrap()
            sidebar = Sidebar(context, path).wrap()
            if tablePerm(table):
                recordObj = mkTable(context, table).record(
                    eid=eid, withDetails=True, **method()
                )
                if recordObj.mayRead is not False:
                    record = recordObj.wrap()
                    return render_template(
                        INDEX, topbar=topbar, sidebar=sidebar, material=record,
                    )
                flash(f&#34;Unknown record in table {table}&#34;, &#34;error&#34;)
                return redirectResult(f&#34;&#34;&#34;/{table}/{N.list}&#34;&#34;&#34;, False)
        flash(f&#34;Unknown table {table}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    def method():
        method = G(request.args, N.method)
        if method not in BODY_METHODS:
            return {}
        return dict(bodyMethod=method)

    # FIELD VIEWS AND EDITS

    @app.route(
        f&#34;&#34;&#34;/api/&lt;string:table&gt;/{N.item}/&lt;string:eid&gt;/{N.field}/&lt;string:field&gt;&#34;&#34;&#34;, **GP
    )
    def serveField(table, eid, field):
        checkBounds(table=table, eid=eid, field=field)

        action = G(request.args, N.action)
        if action in FIELD_ACTIONS:
            context = getContext()
            auth.authenticate()
            if table in ALL_TABLES and tablePerm(table):
                recordObj = mkTable(context, table).record(eid=eid)
                if recordObj.mayRead is not False:
                    fieldObj = mkTable(context, table).record(eid=eid).field(field)
                    if fieldObj:
                        return fieldObj.wrap(action=action)
                    return noField(table, field)
                return noRecord(table)
            return noTable(table)
        return noAction(action)

    # FALL-BACK

    @app.route(f&#34;&#34;&#34;/&lt;path:anything&gt;&#34;&#34;&#34;)
    def serveNotFound(anything=None):
        checkBounds(anything=anything)

        flash(f&#34;Cannot find {anything}&#34;, &#34;error&#34;)
        return redirectResult(START, False)

    def noTable(table):
        return f&#34;&#34;&#34;{NO_TABLE} {table}&#34;&#34;&#34;

    def noRecord(table):
        return f&#34;&#34;&#34;{NO_RECORD} {table}&#34;&#34;&#34;

    def noField(table, field):
        return f&#34;&#34;&#34;{NO_FIELD} {table}:{field}&#34;&#34;&#34;

    def noAction(action):
        return f&#34;&#34;&#34;{NO_ACTION} {action}&#34;&#34;&#34;

    return app</code></pre>
</details>
</dd>
<dt id="control.app.checkBounds"><code class="name flex">
<span>def <span class="ident">checkBounds</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Aggressive check on the arguments passed in an url and/or request.</p>
<p>First the total length of the request is counted.
If it is too much, the request will be aborted.</p>
<p>Each argument in request.args and <code>kwargs</code> must have a name that is allowed
and its value should have a length under an appropriate limit,
configured in <code>web.yaml</code>. There is always a fallback limit.</p>
<div class="admonition caution">
<p class="admonition-title">Security</p>
<p>Before processing any request arg, whether from a form or from the url,
use this function to check whether the length is within limits.</p>
<p>If the length is exceeded, fail with a bad request,
without giving any useful feedback.
Because in this case we are dealing with a hacker.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The key-values that need to be checked.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>HTTPException</code></dt>
<dd>If the length of any argument is out of bounds,
processing is aborted and a bad request response
is delivered</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkBounds(**kwargs):
    &#34;&#34;&#34;Aggressive check on the arguments passed in an url and/or request.

    First the total length of the request is counted.
    If it is too much, the request will be aborted.

    Each argument in request.args and `kwargs` must have a name that is allowed
    and its value should have a length under an appropriate limit,
    configured in `web.yaml`. There is always a fallback limit.

    !!! caution &#34;Security&#34;
        Before processing any request arg, whether from a form or from the url,
        use this function to check whether the length is within limits.

        If the length is exceeded, fail with a bad request,
        without giving any useful feedback.
        Because in this case we are dealing with a hacker.

    Parameters
    ----------
    kwargs: dict
        The key-values that need to be checked.

    Raises
    ------
    HTTPException
        If the length of any argument is out of bounds,
        processing is aborted and a bad request response
        is delivered
    &#34;&#34;&#34;

    default = G(LIMITS, N.default, default=100)
    maxLen = G(LIMITS, N.request, default=default)

    if request.content_length and request.content_length &gt; maxLen:
        abort(400)

    n = len(request.args)
    boundN = G(LIMITS, N.keys, default=default)
    if len(kwargs) &gt; boundN:
        serverprint(f&#34;&#34;&#34;OUT-OF-BOUNDS: {n} &gt; {boundN} KEYS IN {kwargs}&#34;&#34;&#34;)
        abort(400)
    for (k, v) in chain.from_iterable((kwargs.items(), request.args.items())):
        if k not in LIMITS:
            abort(400)
        valN = G(LIMITS, k, default=default)
        if v is not None and len(v) &gt; valN:
            serverprint(f&#34;&#34;&#34;OUT-OF-BOUNDS: LENGTH ARG &#34;{k}&#34; &gt; {valN} ({v})&#34;&#34;&#34;)
            abort(400)</code></pre>
</details>
</dd>
<dt id="control.app.redirectResult"><code class="name flex">
<span>def <span class="ident">redirectResult</span></span>(<span>url, good)</span>
</code></dt>
<dd>
<section class="desc"><p>Redirect.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>string</code></dt>
<dd>The url to redirect to</dd>
</dl>
<p>good:
Whether the redirection corresponds to a normal scenario or is the result of
an error</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>A redirect response with either code 302 (good) or 303 (bad)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redirectResult(url, good):
    &#34;&#34;&#34;Redirect.

    Parameters
    ----------
    url: string
        The url to redirect to
    good:
        Whether the redirection corresponds to a normal scenario or is the result of
        an error

    Returns
    -------
    response
        A redirect response with either code 302 (good) or 303 (bad)
    &#34;&#34;&#34;

    code = 302 if good else 303
    return redirect(url, code=code)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="control.app.MESSAGES" href="#control.app.MESSAGES">MESSAGES</a></code></li>
<li><code><a title="control.app.STATIC_ROOT" href="#control.app.STATIC_ROOT">STATIC_ROOT</a></code></li>
<li><code><a title="control.app.URLS" href="#control.app.URLS">URLS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="control.app.appFactory" href="#control.app.appFactory">appFactory</a></code></li>
<li><code><a title="control.app.checkBounds" href="#control.app.checkBounds">checkBounds</a></code></li>
<li><code><a title="control.app.redirectResult" href="#control.app.redirectResult">redirectResult</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>