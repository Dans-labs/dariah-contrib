<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>control.record API documentation</title>
<meta name="description" content="Records in tables â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.record</code></h1>
</header>
<section id="section-intro">
<p>Records in tables.</p>
<ul>
<li>Rendering</li>
<li>Modification</li>
<li>Deletion</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Records in tables.

*   Rendering
*   Modification
*   Deletion
&#34;&#34;&#34;

from config import Config as C, Names as N
from control.perm import permRecord
from control.utils import pick as G, cap1, E, ELLIPS, ONE, S
from control.html import HtmlElements as H
from control.field import Field

from control.cust.factory_details import factory as detailsFactory


CT = C.tables
CW = C.web


MASTERS = CT.masters
MAIN_TABLE = CT.userTables[0]
ACTUAL_TABLES = set(CT.actualTables)
REFRESH_TABLES = set(CT.refreshTables)
USER_TABLES_LIST = CT.userTables
USER_TABLES = set(USER_TABLES_LIST)
WORKFLOW_TABLES = USER_TABLES | set(CT.userEntryTables)
CASCADE_SPECS = CT.cascade

# an easy way to go from assessment to contrib and from contrib to assessment
# used in deleteButton

TO_MASTER = {
    USER_TABLES_LIST[i + 1]: USER_TABLES_LIST[i]
    for i in range(len(USER_TABLES_LIST) - 1)
}


class Record:
    &#34;&#34;&#34;Deals with records.&#34;&#34;&#34;

    inheritProps = (
        N.context,
        N.uid,
        N.eppn,
        N.mkTable,
        N.table,
        N.fields,
        N.prov,
        N.isUserTable,
        N.isUserEntryTable,
        N.itemLabels,
    )

    def __init__(
        self,
        tableObj,
        eid=None,
        record=None,
        withDetails=False,
        readonly=False,
        bodyMethod=None,
    ):
        &#34;&#34;&#34;## Initialization

        Store the incoming information.

        A number of properties will be inherited from the table object
        that spawns a record object.

        Parameters
        ----------
        tableObj: object
            See below.
        eid, record, withDetails, readonly, bodyMethod
            See `control.table.Table.record`
        &#34;&#34;&#34;

        for prop in Record.inheritProps:
            setattr(self, prop, getattr(tableObj, prop, None))

        self.tableObj = tableObj
        &#34;&#34;&#34;*object* A `control.table.Table` object (or one of a derived class)
        &#34;&#34;&#34;

        self.withDetails = withDetails
        &#34;&#34;&#34;*boolean* Whether to present a list of detail records below the record.
        &#34;&#34;&#34;

        self.readonly = readonly
        &#34;&#34;&#34;*boolean* Whether to present the complete record in readonly mode.
        &#34;&#34;&#34;

        self.bodyMethod = bodyMethod
        &#34;&#34;&#34;*function* How to compose the HTML for the body of the record.
        &#34;&#34;&#34;

        context = self.context
        table = self.table

        self.DetailsClass = detailsFactory(table)
        &#34;&#34;&#34;*class* The class used for presenting details of this record.

        It might be the base class `control.details.Details`  or one of its
        derived classes.
        &#34;&#34;&#34;

        if record is None:
            record = context.getItem(table, eid)
        self.record = record
        &#34;&#34;&#34;*dict* The data of the record, keyed by field names.
        &#34;&#34;&#34;

        self.eid = G(record, N._id)
        &#34;&#34;&#34;*ObjectId* The id of the record.
        &#34;&#34;&#34;

        self.setPerm()

        self.setWorkflow()
        self.mayDelete = self.getDelPerm()
        &#34;&#34;&#34;*boolean* Whether the user may delete the record.
        &#34;&#34;&#34;

    def getDelPerm(self):
        &#34;&#34;&#34;Compute the delete permission for this record.

            The unbreakable rule is:
            *   Records with dependencies cannot be deleted if the dependencies
                are not configured as `cascade-delete` in tables.yaml.

            The next rules are workflow rules:

            *   if a record is fixed due to workflow constraints, no one can delete it;
            *   if a record is unfixed due to workflow, a user may delete it,
                irrespective of normal permissions; workflow will determine
                which records will appear unfixed to which users;

            If these rules do not clinch it, the normal permission rules will
            be applied:

            *   authenticated users may delete their own records in the
                `contrib`, `assessment` and `review` tables
            *   superusers may delete records if the configured edit
                permissions allow them
        &#34;&#34;&#34;

        context = self.context
        auth = context.auth
        isUserTable = self.isUserTable
        isUserEntryTable = self.isUserEntryTable
        readonly = self.readonly
        perm = self.perm
        fixed = self.fixed

        isAuthenticated = auth.authenticated()
        isSuperuser = auth.superuser()

        normalDelPerm = (
            not isUserEntryTable
            and not readonly
            and isAuthenticated
            and (isSuperuser or isUserTable and G(perm, N.isEdit))
        )
        return False if fixed else normalDelPerm

    def reload(
        self, record,
    ):
        &#34;&#34;&#34;Re-initializes a record object if its underlying data has changed.

        This might be caused by an update in the record itself,
        or a change in workflow conditions.
        &#34;&#34;&#34;

        self.record = record
        self.setPerm()
        self.setWorkflow()
        self.mayDelete = self.getDelPerm()

    def getDependencies(self):
        &#34;&#34;&#34;Compute dependent records.

        See `control.db.Db.dependencies`.
        &#34;&#34;&#34;

        context = self.context
        db = context.db
        table = self.table
        record = self.record

        return db.dependencies(table, record)

    def setPerm(self):
        &#34;&#34;&#34;Compute permission info for this record.

        See `control.perm.permRecord`.
        &#34;&#34;&#34;

        context = self.context
        table = self.table
        record = self.record

        self.perm = permRecord(context, table, record)

    def setWorkflow(self):
        &#34;&#34;&#34;Compute a workflow item for this record.

        The workflow item corresponds to this record
        if it is in the contrib table, otherwise to the
        contrib that is the (grand)master of this record.

        See `control.context.Context.getWorkflowItem` and
        `control.workflow.apply.WorkflowItem`.

        Returns
        -------
        void
            The attribute `wfitem` will point to the workflow item.
            If the record is not a valid part of any workflow,
            or if there is no workflow item found,
            `wfitem` will be set to `None`.
        &#34;&#34;&#34;

        context = self.context
        perm = self.perm
        table = self.table
        eid = self.eid
        record = self.record

        contribId = G(perm, N.contribId)

        self.kind = None
        self.fixed = None
        valid = False

        wfitem = context.getWorkflowItem(contribId)
        if wfitem:
            self.kind = wfitem.getKind(table, record)
            valid = wfitem.isValid(table, eid, record)
            self.mayRead = wfitem.checkReadable(self)
        else:
            valid = False if table in USER_TABLES - {MAIN_TABLE} else True
            self.mayRead = None

        if valid and wfitem:
            self.fixed = wfitem.checkFixed(self)
            self.wfitem = wfitem
        else:
            self.wfitem = None

        self.valid = valid

    def adjustWorkflow(self, update=True, delete=False):
        &#34;&#34;&#34;Recompute workflow information.

        When this record or some other record has changed, it could have had
        an impact on the workflow.
        If there is reason to assume this has happened, this function can be called
        to recompute the workflow item.

        !!! warning
            Do not confuse this method with the one with the same name in Tables:
            `control.table.Table.adjustWorkflow` which does its work after the
            insertion of a record.

        Parameters
        ----------
        update: boolean, optional `True`
            If `True`, reset the attribute `wfitem` to the recomputed workflow.
            Otherwise, recomputation is done, but the attribute is not reset.
            This is done if there is no use of the workflow info for the remaining
            steps in processing the request.
        delete: boolean, optional `False`
            If `True`, delete the workflow item and set the attribute `wfitem`
            to `None`

        Returns
        -------
        void
            The attribute `wfitem` will be set again.
        &#34;&#34;&#34;

        context = self.context
        wf = context.wf
        perm = self.perm

        contribId = G(perm, N.contribId)
        if delete:
            wf.delete(contribId)
            self.wfitem = None
        else:
            wf.recompute(contribId)
            if update:
                self.wfitem = context.getWorkflowItem(contribId, requireFresh=True)

    def task(self, task):
        &#34;&#34;&#34;Perform a workflow task.

        See `control.workflow.apply.WorkflowItem.doTask`.
        &#34;&#34;&#34;

        wfitem = self.wfitem

        url = None
        good = False

        if wfitem:
            url = wfitem.doTask(task, self)

        if url is None:
            table = self.table
            eid = self.eid
            url = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
        else:
            good = True
        return (good, url)

    def field(self, fieldName, **kwargs):
        &#34;&#34;&#34;Factory function to wrap a field object around the data of a field.

        !!! note
            Workflow information will be checked whether this record is fixated.
            If so, the new field object will be initialized with parameters
            to make it uneditable.

        !!! note
            It will also be checked whether the field is a workflow field.
            Such fields are not shown and edited in the normal way,
            hence they will be set to unreadable and uneditable.
            The manipulation of such fields is under control of workflow.
            See `control.workflow.apply.WorkflowItem.isTask`.

        !!! caution
            The name of the field must be one for which field specs are defined
            in the yaml file for the table.

        Parameters
        ----------
        fieldName: string

        Returns
        -------
        object
            A `control.field.Field` object.
        &#34;&#34;&#34;

        fields = self.fields
        if fieldName not in fields:
            return None

        table = self.table
        wfitem = self.wfitem

        forceEdit = G(kwargs, N.mayEdit)

        if wfitem:
            fixed = wfitem.checkFixed(self, field=fieldName)
            if fixed:
                kwargs[N.mayEdit] = False
            if wfitem.isTask(table, fieldName):
                kwargs[N.mayRead] = False
                kwargs[N.mayEdit] = forceEdit or not fixed
        return Field(self, fieldName, **kwargs)

    def delete(self):
        &#34;&#34;&#34;Delete a record.

        Permissions and dependencies will be checked, as a result,
        the deletion may be prevented.
        See `Record.getDependencies` and `Record.getDelPerm`.

        If deletion happens, workflow information will be adapted afterwards.
        See `Record.adjustWorkflow`.
        &#34;&#34;&#34;

        mayDelete = self.mayDelete
        if not mayDelete:
            return False

        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            return False

        nCas = G(dependencies, N.cascade, default=0)
        if nCas:
            if not self.deleteDetails():
                return False

        context = self.context
        table = self.table
        eid = self.eid

        good = context.deleteItem(table, eid)

        if table == MAIN_TABLE:
            self.adjustWorkflow(delete=True)
        elif table in WORKFLOW_TABLES:
            self.adjustWorkflow(update=False)

        return good

    def deleteDetails(self):
        &#34;&#34;&#34;Delete the details of a record.

        Permissions and dependencies will be checked, as a result,
        the deletion may be prevented.
        See `Record.getDependencies` and `Record.getDelPerm`.

        Returns
        -------
        bool
            Whether there are still dependencies after deleting the details.
        &#34;&#34;&#34;

        context = self.context
        db = context.db
        table = self.table
        eid = self.eid

        for dtable in G(CASCADE_SPECS, table, default=[]):
            db.deleteMany(dtable, {table: eid})
        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)
        return nRef == 0

    def body(self, myMasters=None, hideMasters=False):
        &#34;&#34;&#34;Wrap the body of the record in HTML.

        This is the part without the provenance information and without
        the detail records.

        This method can be overridden by `body` methods in derived classes.

        Parameters
        ----------
        myMasters: iterable of string, optional `None`
            A declaration of which fields must be treated as master fields.
        hideMaster: boolean, optional `False`
            If `True`, all master fields as declared in `myMasters` will be left out.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        fieldSpecs = self.fields
        provSpecs = self.prov

        return H.join(
            self.field(field, asMaster=field in myMasters).wrap()
            for field in fieldSpecs
            if (field not in provSpecs and not (hideMasters and field in myMasters))
        )

    def wrap(
        self,
        inner=True,
        wrapMethod=None,
        expanded=1,
        withProv=True,
        hideMasters=False,
        showTable=None,
        showEid=None,
        extraCls=E,
    ):
        &#34;&#34;&#34;Wrap the record into HTML.

        A record can be displayed in several states:

        expanded | effect
        --- | ---
        `-1` | only a title with a control to get the full details
        `0` | full details, no control to collapse/expand
        `1` | full details, with a control to collapse to the title

        !!! note
            When a record in state `1` or `-1` is sent to the client,
            only the material that is displayed is sent. When the user clicks on the
            expand/collapse control, the other part is fetched from the server
            *at that very moment*.
            So collapsing/expanding can be used to refresh the view on a record
            if things have happened.

        !!! caution
            The triggering of the fetch actions for expanded/collapsed material
            is done by the Javascript in `index.js`.
            A single function does it all, and it is sensitive to the exact attributes
            of the summary and the detail.
            If you tamper with this code, you might end up with an infinite loop of
            expanding and collapsing.

        !!! hint
            Pay extra attension to the attribute `fat`!
            When it is present, it is an indication that the expanded material
            is already on the client, and that it does not have to be fetched.

        !!! note
            There are several ways to customise the effect of `wrap` for specific
            tables. Start with writing a derived class for that table with
            `Record` as base class.

            *   write an alternative for `Record.body`,
                e.g. `control.cust.review_record.ReviewR.bodyCompact`, and
                initialize the `Record` with `(bodyMethod=&#39;compact&#39;)`.
                Just specify the part of the name after `body` as string starting
                with a lower case.
            *   override `Record.body`. This app does not do this currently.
            *   use a custom `wrap` function, by defining it in your derived class,
                e.g. `control.cust.score_record.ScoreR.wrapHelp`.
                Use it by calling `Record.wrap(wrapMethod=scoreObj.wrapHelp)`.

        Parameters
        ----------
        inner: boolean, optional `True`
            Whether to add the CSS class `inner` to the outer `&lt;div&gt;` of the result.
        wrapMethod: function, optional `None`
            The method to compose the result out of all its components.
            Typically defined in a derived class.
            If passed, this function will be called to deliver the result.
            Otherwise, `wrap` does the composition itself.
        expanded: {-1, 0, 1}
            Whether to expand the record.
            See the table above.
        withProv: boolean, optional `True`
            Include a display of the provenance fields.
        hideMasters: boolean, optional `False`
            Whether to hide the master fields.
            If they are not hidden, they will be presented as hyperlinks to the
            master record.
        extraCls: string, optional `&#39;&#39;`
            An extra class to add to the outer `&lt;div&gt;`.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        table = self.table
        eid = self.eid
        record = self.record
        provSpecs = self.prov
        valid = self.valid
        withDetails = self.withDetails

        withRefresh = table in REFRESH_TABLES

        func = getattr(self, wrapMethod, None) if wrapMethod else None
        if func:
            return func()

        bodyMethod = self.bodyMethod
        urlExtra = f&#34;&#34;&#34;?method={bodyMethod}&#34;&#34;&#34; if bodyMethod else E
        fetchUrl = f&#34;&#34;&#34;/api/{table}/{N.item}/{eid}&#34;&#34;&#34;

        itemKey = f&#34;&#34;&#34;{table}/{G(record, N._id)}&#34;&#34;&#34;
        theTitle = self.title()

        if expanded == -1:
            return H.details(
                theTitle,
                H.div(ELLIPS),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=E,
            )

        bodyFunc = (
            getattr(self, f&#34;&#34;&#34;{N.body}{cap1(bodyMethod)}&#34;&#34;&#34;, self.body)
            if bodyMethod
            else self.body
        )
        myMasters = G(MASTERS, table, default=[])

        deleteButton = self.deleteButton()

        innerCls = &#34; inner&#34; if inner else E
        warningCls = E if valid else &#34; warning &#34;

        provenance = (
            H.div(
                H.detailx(
                    (N.prov, N.dismiss),
                    H.div(
                        [self.field(field).wrap() for field in provSpecs], cls=&#34;prov&#34;
                    ),
                    f&#34;&#34;&#34;{table}/{G(record, N._id)}/{N.prov}&#34;&#34;&#34;,
                    openAtts=dict(
                        cls=&#34;button small&#34;,
                        title=&#34;Provenance and editors of this record&#34;,
                    ),
                    closeAtts=dict(cls=&#34;button small&#34;, title=&#34;Hide provenance&#34;),
                    cls=&#34;prov&#34;,
                ),
                cls=&#34;provx&#34;,
            )
            if withProv
            else E
        )

        main = H.div(
            [
                deleteButton,
                H.div(
                    H.join(bodyFunc(myMasters=myMasters, hideMasters=hideMasters)),
                    cls=f&#34;{table.lower()}&#34;,
                ),
                *provenance,
            ],
            cls=f&#34;record{innerCls} {extraCls} {warningCls}&#34;,
        )

        rButton = H.iconr(itemKey, &#34;#main&#34;, msg=table) if withRefresh else E
        details = (
            self.DetailsClass(self).wrap(showTable=showTable, showEid=showEid)
            if withDetails
            else E
        )

        return (
            H.details(
                rButton + theTitle,
                H.div(main + details),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=&#34;&#34;&#34;/title&#34;&#34;&#34;,
                fat=ONE,
                forceopen=ONE,
                open=True,
            )
            if expanded == 1
            else H.div(main + details)
        )

    def deleteButton(self):
        &#34;&#34;&#34;Show the delete button and/or the number of dependencies.

        Check the permissions in order to not show a delete button if the user
        cannot delete the record.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        mayDelete = self.mayDelete

        if not mayDelete:
            return E

        record = self.record
        table = self.table
        itemSingle = self.itemLabels[0]

        dependencies = self.getDependencies()

        nCas = G(dependencies, N.cascade, default=0)
        cascadeMsg = (
            H.span(
                f&#34;&#34;&#34;{nCas} detail record{E if nCas == 1 else S}&#34;&#34;&#34;,
                title=&#34;&#34;&#34;Detail records will be deleted with the master record&#34;&#34;&#34;,
                cls=&#34;label small warning-o right&#34;,
            )
            if nCas
            else E
        )
        cascadeMsgShort = (
            f&#34;&#34;&#34; and {nCas} dependent record{E if nCas == 1 else S}&#34;&#34;&#34; if nCas else E
        )

        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            plural = E if nRef == 1 else S
            return H.span(
                [
                    H.icon(
                        N.chain,
                        cls=&#34;medium right&#34;,
                        title=f&#34;&#34;&#34;Cannot delete because of {nRef} dependent record{plural}&#34;&#34;&#34;,
                    ),
                    H.span(
                        f&#34;&#34;&#34;{nRef} dependent record{plural}&#34;&#34;&#34;,
                        cls=&#34;label small warning-o right&#34;,
                    ),
                ]
            )

        if table in TO_MASTER:
            masterTable = G(TO_MASTER, table)
            masterId = G(record, masterTable)
        else:
            masterTable = None
            masterId = None

        url = (
            f&#34;&#34;&#34;/api/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
            if masterTable is None or masterId is None
            else f&#34;&#34;&#34;/api/{masterTable}/{masterId}/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
        )
        return H.span(
            [
                cascadeMsg,
                H.iconx(
                    N.delete,
                    cls=&#34;medium right warning&#34;,
                    deleteurl=url,
                    title=f&#34;&#34;&#34;delete this {itemSingle}{cascadeMsgShort}&#34;&#34;&#34;,
                ),
            ]
        )

    def title(self):
        &#34;&#34;&#34;Generate a title for the record.&#34;&#34;&#34;
        record = self.record
        valid = self.valid

        warningCls = E if valid else &#34; warning &#34;

        return Record.titleRaw(self, record, cls=warningCls)

    def inActualCls(self, record):
        &#34;&#34;&#34;Get a CSS class name for a record based on whether it is *actual*.

        Actual records belong to the current `package`, a record that specifies
        which contribution types, and criteria are currently part of the workflow.

        Parameters
        ----------
        record: dict | `None`
            If `self` does not have a `record` attribute, the record data must
            be passed here.
        Returns
        -------
        string
            `inactual` if the record is not actual, else the empty string.
        &#34;&#34;&#34;

        table = self.table
        if record is None:
            record = self.record

        isActual = (
            table not in ACTUAL_TABLES
            or not record
            or G(record, N.actual, default=False)
        )
        return E if isActual else &#34;inactual&#34;

    @staticmethod
    def titleRaw(obj, record, cls=E):
        &#34;&#34;&#34;Generate a title for a different record.

        This is fast title generation.
        No record object will be created.

        The title will be based on the fields in the record,
        and its formatting is assisted by the appropriate
        type class in `control.typ.types`.

        !!! hint
            If the record is  not &#34;actual&#34;, its title will get a warning
            background color.
            See `control.db.Db.collect`.

        Parameters
        ----------
        obj: object
            Any object that has a table and context attribute, e.g. a table object
            or a record object
        record: dict
        cls: string, optional, `&#39;&#39;`
            A CSS class to add to the outer element of the result
        &#34;&#34;&#34;

        table = obj.table
        context = obj.context

        types = context.types
        typesObj = getattr(types, table, None)

        inActualCls = Record.inActualCls(obj, record)
        atts = dict(cls=f&#34;{cls} {inActualCls}&#34;)

        return H.span(typesObj.title(record=record), **atts)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.record.Record"><code class="flex name class">
<span>class <span class="ident">Record</span></span>
<span>(</span><span>tableObj, eid=None, record=None, withDetails=False, readonly=False, bodyMethod=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deals with records.</p>
<h2 id="initialization">Initialization</h2>
<p>Store the incoming information.</p>
<p>A number of properties will be inherited from the table object
that spawns a record object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tableObj</code></strong> :&ensp;<code>object</code></dt>
<dd>See below.</dd>
<dt><strong><code>eid</code></strong>, <strong><code>record</code></strong>, <strong><code>withDetails</code></strong>, <strong><code>readonly</code></strong>, <strong><code>bodyMethod</code></strong></dt>
<dd>See <code><a title="control.table.Table.record" href="table.html#control.table.Table.record">Table.record()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Record:
    &#34;&#34;&#34;Deals with records.&#34;&#34;&#34;

    inheritProps = (
        N.context,
        N.uid,
        N.eppn,
        N.mkTable,
        N.table,
        N.fields,
        N.prov,
        N.isUserTable,
        N.isUserEntryTable,
        N.itemLabels,
    )

    def __init__(
        self,
        tableObj,
        eid=None,
        record=None,
        withDetails=False,
        readonly=False,
        bodyMethod=None,
    ):
        &#34;&#34;&#34;## Initialization

        Store the incoming information.

        A number of properties will be inherited from the table object
        that spawns a record object.

        Parameters
        ----------
        tableObj: object
            See below.
        eid, record, withDetails, readonly, bodyMethod
            See `control.table.Table.record`
        &#34;&#34;&#34;

        for prop in Record.inheritProps:
            setattr(self, prop, getattr(tableObj, prop, None))

        self.tableObj = tableObj
        &#34;&#34;&#34;*object* A `control.table.Table` object (or one of a derived class)
        &#34;&#34;&#34;

        self.withDetails = withDetails
        &#34;&#34;&#34;*boolean* Whether to present a list of detail records below the record.
        &#34;&#34;&#34;

        self.readonly = readonly
        &#34;&#34;&#34;*boolean* Whether to present the complete record in readonly mode.
        &#34;&#34;&#34;

        self.bodyMethod = bodyMethod
        &#34;&#34;&#34;*function* How to compose the HTML for the body of the record.
        &#34;&#34;&#34;

        context = self.context
        table = self.table

        self.DetailsClass = detailsFactory(table)
        &#34;&#34;&#34;*class* The class used for presenting details of this record.

        It might be the base class `control.details.Details`  or one of its
        derived classes.
        &#34;&#34;&#34;

        if record is None:
            record = context.getItem(table, eid)
        self.record = record
        &#34;&#34;&#34;*dict* The data of the record, keyed by field names.
        &#34;&#34;&#34;

        self.eid = G(record, N._id)
        &#34;&#34;&#34;*ObjectId* The id of the record.
        &#34;&#34;&#34;

        self.setPerm()

        self.setWorkflow()
        self.mayDelete = self.getDelPerm()
        &#34;&#34;&#34;*boolean* Whether the user may delete the record.
        &#34;&#34;&#34;

    def getDelPerm(self):
        &#34;&#34;&#34;Compute the delete permission for this record.

            The unbreakable rule is:
            *   Records with dependencies cannot be deleted if the dependencies
                are not configured as `cascade-delete` in tables.yaml.

            The next rules are workflow rules:

            *   if a record is fixed due to workflow constraints, no one can delete it;
            *   if a record is unfixed due to workflow, a user may delete it,
                irrespective of normal permissions; workflow will determine
                which records will appear unfixed to which users;

            If these rules do not clinch it, the normal permission rules will
            be applied:

            *   authenticated users may delete their own records in the
                `contrib`, `assessment` and `review` tables
            *   superusers may delete records if the configured edit
                permissions allow them
        &#34;&#34;&#34;

        context = self.context
        auth = context.auth
        isUserTable = self.isUserTable
        isUserEntryTable = self.isUserEntryTable
        readonly = self.readonly
        perm = self.perm
        fixed = self.fixed

        isAuthenticated = auth.authenticated()
        isSuperuser = auth.superuser()

        normalDelPerm = (
            not isUserEntryTable
            and not readonly
            and isAuthenticated
            and (isSuperuser or isUserTable and G(perm, N.isEdit))
        )
        return False if fixed else normalDelPerm

    def reload(
        self, record,
    ):
        &#34;&#34;&#34;Re-initializes a record object if its underlying data has changed.

        This might be caused by an update in the record itself,
        or a change in workflow conditions.
        &#34;&#34;&#34;

        self.record = record
        self.setPerm()
        self.setWorkflow()
        self.mayDelete = self.getDelPerm()

    def getDependencies(self):
        &#34;&#34;&#34;Compute dependent records.

        See `control.db.Db.dependencies`.
        &#34;&#34;&#34;

        context = self.context
        db = context.db
        table = self.table
        record = self.record

        return db.dependencies(table, record)

    def setPerm(self):
        &#34;&#34;&#34;Compute permission info for this record.

        See `control.perm.permRecord`.
        &#34;&#34;&#34;

        context = self.context
        table = self.table
        record = self.record

        self.perm = permRecord(context, table, record)

    def setWorkflow(self):
        &#34;&#34;&#34;Compute a workflow item for this record.

        The workflow item corresponds to this record
        if it is in the contrib table, otherwise to the
        contrib that is the (grand)master of this record.

        See `control.context.Context.getWorkflowItem` and
        `control.workflow.apply.WorkflowItem`.

        Returns
        -------
        void
            The attribute `wfitem` will point to the workflow item.
            If the record is not a valid part of any workflow,
            or if there is no workflow item found,
            `wfitem` will be set to `None`.
        &#34;&#34;&#34;

        context = self.context
        perm = self.perm
        table = self.table
        eid = self.eid
        record = self.record

        contribId = G(perm, N.contribId)

        self.kind = None
        self.fixed = None
        valid = False

        wfitem = context.getWorkflowItem(contribId)
        if wfitem:
            self.kind = wfitem.getKind(table, record)
            valid = wfitem.isValid(table, eid, record)
            self.mayRead = wfitem.checkReadable(self)
        else:
            valid = False if table in USER_TABLES - {MAIN_TABLE} else True
            self.mayRead = None

        if valid and wfitem:
            self.fixed = wfitem.checkFixed(self)
            self.wfitem = wfitem
        else:
            self.wfitem = None

        self.valid = valid

    def adjustWorkflow(self, update=True, delete=False):
        &#34;&#34;&#34;Recompute workflow information.

        When this record or some other record has changed, it could have had
        an impact on the workflow.
        If there is reason to assume this has happened, this function can be called
        to recompute the workflow item.

        !!! warning
            Do not confuse this method with the one with the same name in Tables:
            `control.table.Table.adjustWorkflow` which does its work after the
            insertion of a record.

        Parameters
        ----------
        update: boolean, optional `True`
            If `True`, reset the attribute `wfitem` to the recomputed workflow.
            Otherwise, recomputation is done, but the attribute is not reset.
            This is done if there is no use of the workflow info for the remaining
            steps in processing the request.
        delete: boolean, optional `False`
            If `True`, delete the workflow item and set the attribute `wfitem`
            to `None`

        Returns
        -------
        void
            The attribute `wfitem` will be set again.
        &#34;&#34;&#34;

        context = self.context
        wf = context.wf
        perm = self.perm

        contribId = G(perm, N.contribId)
        if delete:
            wf.delete(contribId)
            self.wfitem = None
        else:
            wf.recompute(contribId)
            if update:
                self.wfitem = context.getWorkflowItem(contribId, requireFresh=True)

    def task(self, task):
        &#34;&#34;&#34;Perform a workflow task.

        See `control.workflow.apply.WorkflowItem.doTask`.
        &#34;&#34;&#34;

        wfitem = self.wfitem

        url = None
        good = False

        if wfitem:
            url = wfitem.doTask(task, self)

        if url is None:
            table = self.table
            eid = self.eid
            url = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
        else:
            good = True
        return (good, url)

    def field(self, fieldName, **kwargs):
        &#34;&#34;&#34;Factory function to wrap a field object around the data of a field.

        !!! note
            Workflow information will be checked whether this record is fixated.
            If so, the new field object will be initialized with parameters
            to make it uneditable.

        !!! note
            It will also be checked whether the field is a workflow field.
            Such fields are not shown and edited in the normal way,
            hence they will be set to unreadable and uneditable.
            The manipulation of such fields is under control of workflow.
            See `control.workflow.apply.WorkflowItem.isTask`.

        !!! caution
            The name of the field must be one for which field specs are defined
            in the yaml file for the table.

        Parameters
        ----------
        fieldName: string

        Returns
        -------
        object
            A `control.field.Field` object.
        &#34;&#34;&#34;

        fields = self.fields
        if fieldName not in fields:
            return None

        table = self.table
        wfitem = self.wfitem

        forceEdit = G(kwargs, N.mayEdit)

        if wfitem:
            fixed = wfitem.checkFixed(self, field=fieldName)
            if fixed:
                kwargs[N.mayEdit] = False
            if wfitem.isTask(table, fieldName):
                kwargs[N.mayRead] = False
                kwargs[N.mayEdit] = forceEdit or not fixed
        return Field(self, fieldName, **kwargs)

    def delete(self):
        &#34;&#34;&#34;Delete a record.

        Permissions and dependencies will be checked, as a result,
        the deletion may be prevented.
        See `Record.getDependencies` and `Record.getDelPerm`.

        If deletion happens, workflow information will be adapted afterwards.
        See `Record.adjustWorkflow`.
        &#34;&#34;&#34;

        mayDelete = self.mayDelete
        if not mayDelete:
            return False

        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            return False

        nCas = G(dependencies, N.cascade, default=0)
        if nCas:
            if not self.deleteDetails():
                return False

        context = self.context
        table = self.table
        eid = self.eid

        good = context.deleteItem(table, eid)

        if table == MAIN_TABLE:
            self.adjustWorkflow(delete=True)
        elif table in WORKFLOW_TABLES:
            self.adjustWorkflow(update=False)

        return good

    def deleteDetails(self):
        &#34;&#34;&#34;Delete the details of a record.

        Permissions and dependencies will be checked, as a result,
        the deletion may be prevented.
        See `Record.getDependencies` and `Record.getDelPerm`.

        Returns
        -------
        bool
            Whether there are still dependencies after deleting the details.
        &#34;&#34;&#34;

        context = self.context
        db = context.db
        table = self.table
        eid = self.eid

        for dtable in G(CASCADE_SPECS, table, default=[]):
            db.deleteMany(dtable, {table: eid})
        dependencies = self.getDependencies()
        nRef = G(dependencies, N.reference, default=0)
        return nRef == 0

    def body(self, myMasters=None, hideMasters=False):
        &#34;&#34;&#34;Wrap the body of the record in HTML.

        This is the part without the provenance information and without
        the detail records.

        This method can be overridden by `body` methods in derived classes.

        Parameters
        ----------
        myMasters: iterable of string, optional `None`
            A declaration of which fields must be treated as master fields.
        hideMaster: boolean, optional `False`
            If `True`, all master fields as declared in `myMasters` will be left out.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        fieldSpecs = self.fields
        provSpecs = self.prov

        return H.join(
            self.field(field, asMaster=field in myMasters).wrap()
            for field in fieldSpecs
            if (field not in provSpecs and not (hideMasters and field in myMasters))
        )

    def wrap(
        self,
        inner=True,
        wrapMethod=None,
        expanded=1,
        withProv=True,
        hideMasters=False,
        showTable=None,
        showEid=None,
        extraCls=E,
    ):
        &#34;&#34;&#34;Wrap the record into HTML.

        A record can be displayed in several states:

        expanded | effect
        --- | ---
        `-1` | only a title with a control to get the full details
        `0` | full details, no control to collapse/expand
        `1` | full details, with a control to collapse to the title

        !!! note
            When a record in state `1` or `-1` is sent to the client,
            only the material that is displayed is sent. When the user clicks on the
            expand/collapse control, the other part is fetched from the server
            *at that very moment*.
            So collapsing/expanding can be used to refresh the view on a record
            if things have happened.

        !!! caution
            The triggering of the fetch actions for expanded/collapsed material
            is done by the Javascript in `index.js`.
            A single function does it all, and it is sensitive to the exact attributes
            of the summary and the detail.
            If you tamper with this code, you might end up with an infinite loop of
            expanding and collapsing.

        !!! hint
            Pay extra attension to the attribute `fat`!
            When it is present, it is an indication that the expanded material
            is already on the client, and that it does not have to be fetched.

        !!! note
            There are several ways to customise the effect of `wrap` for specific
            tables. Start with writing a derived class for that table with
            `Record` as base class.

            *   write an alternative for `Record.body`,
                e.g. `control.cust.review_record.ReviewR.bodyCompact`, and
                initialize the `Record` with `(bodyMethod=&#39;compact&#39;)`.
                Just specify the part of the name after `body` as string starting
                with a lower case.
            *   override `Record.body`. This app does not do this currently.
            *   use a custom `wrap` function, by defining it in your derived class,
                e.g. `control.cust.score_record.ScoreR.wrapHelp`.
                Use it by calling `Record.wrap(wrapMethod=scoreObj.wrapHelp)`.

        Parameters
        ----------
        inner: boolean, optional `True`
            Whether to add the CSS class `inner` to the outer `&lt;div&gt;` of the result.
        wrapMethod: function, optional `None`
            The method to compose the result out of all its components.
            Typically defined in a derived class.
            If passed, this function will be called to deliver the result.
            Otherwise, `wrap` does the composition itself.
        expanded: {-1, 0, 1}
            Whether to expand the record.
            See the table above.
        withProv: boolean, optional `True`
            Include a display of the provenance fields.
        hideMasters: boolean, optional `False`
            Whether to hide the master fields.
            If they are not hidden, they will be presented as hyperlinks to the
            master record.
        extraCls: string, optional `&#39;&#39;`
            An extra class to add to the outer `&lt;div&gt;`.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        table = self.table
        eid = self.eid
        record = self.record
        provSpecs = self.prov
        valid = self.valid
        withDetails = self.withDetails

        withRefresh = table in REFRESH_TABLES

        func = getattr(self, wrapMethod, None) if wrapMethod else None
        if func:
            return func()

        bodyMethod = self.bodyMethod
        urlExtra = f&#34;&#34;&#34;?method={bodyMethod}&#34;&#34;&#34; if bodyMethod else E
        fetchUrl = f&#34;&#34;&#34;/api/{table}/{N.item}/{eid}&#34;&#34;&#34;

        itemKey = f&#34;&#34;&#34;{table}/{G(record, N._id)}&#34;&#34;&#34;
        theTitle = self.title()

        if expanded == -1:
            return H.details(
                theTitle,
                H.div(ELLIPS),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=E,
            )

        bodyFunc = (
            getattr(self, f&#34;&#34;&#34;{N.body}{cap1(bodyMethod)}&#34;&#34;&#34;, self.body)
            if bodyMethod
            else self.body
        )
        myMasters = G(MASTERS, table, default=[])

        deleteButton = self.deleteButton()

        innerCls = &#34; inner&#34; if inner else E
        warningCls = E if valid else &#34; warning &#34;

        provenance = (
            H.div(
                H.detailx(
                    (N.prov, N.dismiss),
                    H.div(
                        [self.field(field).wrap() for field in provSpecs], cls=&#34;prov&#34;
                    ),
                    f&#34;&#34;&#34;{table}/{G(record, N._id)}/{N.prov}&#34;&#34;&#34;,
                    openAtts=dict(
                        cls=&#34;button small&#34;,
                        title=&#34;Provenance and editors of this record&#34;,
                    ),
                    closeAtts=dict(cls=&#34;button small&#34;, title=&#34;Hide provenance&#34;),
                    cls=&#34;prov&#34;,
                ),
                cls=&#34;provx&#34;,
            )
            if withProv
            else E
        )

        main = H.div(
            [
                deleteButton,
                H.div(
                    H.join(bodyFunc(myMasters=myMasters, hideMasters=hideMasters)),
                    cls=f&#34;{table.lower()}&#34;,
                ),
                *provenance,
            ],
            cls=f&#34;record{innerCls} {extraCls} {warningCls}&#34;,
        )

        rButton = H.iconr(itemKey, &#34;#main&#34;, msg=table) if withRefresh else E
        details = (
            self.DetailsClass(self).wrap(showTable=showTable, showEid=showEid)
            if withDetails
            else E
        )

        return (
            H.details(
                rButton + theTitle,
                H.div(main + details),
                itemKey,
                fetchurl=fetchUrl,
                urlextra=urlExtra,
                urltitle=&#34;&#34;&#34;/title&#34;&#34;&#34;,
                fat=ONE,
                forceopen=ONE,
                open=True,
            )
            if expanded == 1
            else H.div(main + details)
        )

    def deleteButton(self):
        &#34;&#34;&#34;Show the delete button and/or the number of dependencies.

        Check the permissions in order to not show a delete button if the user
        cannot delete the record.

        Returns
        -------
        string(html)
        &#34;&#34;&#34;

        mayDelete = self.mayDelete

        if not mayDelete:
            return E

        record = self.record
        table = self.table
        itemSingle = self.itemLabels[0]

        dependencies = self.getDependencies()

        nCas = G(dependencies, N.cascade, default=0)
        cascadeMsg = (
            H.span(
                f&#34;&#34;&#34;{nCas} detail record{E if nCas == 1 else S}&#34;&#34;&#34;,
                title=&#34;&#34;&#34;Detail records will be deleted with the master record&#34;&#34;&#34;,
                cls=&#34;label small warning-o right&#34;,
            )
            if nCas
            else E
        )
        cascadeMsgShort = (
            f&#34;&#34;&#34; and {nCas} dependent record{E if nCas == 1 else S}&#34;&#34;&#34; if nCas else E
        )

        nRef = G(dependencies, N.reference, default=0)

        if nRef:
            plural = E if nRef == 1 else S
            return H.span(
                [
                    H.icon(
                        N.chain,
                        cls=&#34;medium right&#34;,
                        title=f&#34;&#34;&#34;Cannot delete because of {nRef} dependent record{plural}&#34;&#34;&#34;,
                    ),
                    H.span(
                        f&#34;&#34;&#34;{nRef} dependent record{plural}&#34;&#34;&#34;,
                        cls=&#34;label small warning-o right&#34;,
                    ),
                ]
            )

        if table in TO_MASTER:
            masterTable = G(TO_MASTER, table)
            masterId = G(record, masterTable)
        else:
            masterTable = None
            masterId = None

        url = (
            f&#34;&#34;&#34;/api/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
            if masterTable is None or masterId is None
            else f&#34;&#34;&#34;/api/{masterTable}/{masterId}/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
        )
        return H.span(
            [
                cascadeMsg,
                H.iconx(
                    N.delete,
                    cls=&#34;medium right warning&#34;,
                    deleteurl=url,
                    title=f&#34;&#34;&#34;delete this {itemSingle}{cascadeMsgShort}&#34;&#34;&#34;,
                ),
            ]
        )

    def title(self):
        &#34;&#34;&#34;Generate a title for the record.&#34;&#34;&#34;
        record = self.record
        valid = self.valid

        warningCls = E if valid else &#34; warning &#34;

        return Record.titleRaw(self, record, cls=warningCls)

    def inActualCls(self, record):
        &#34;&#34;&#34;Get a CSS class name for a record based on whether it is *actual*.

        Actual records belong to the current `package`, a record that specifies
        which contribution types, and criteria are currently part of the workflow.

        Parameters
        ----------
        record: dict | `None`
            If `self` does not have a `record` attribute, the record data must
            be passed here.
        Returns
        -------
        string
            `inactual` if the record is not actual, else the empty string.
        &#34;&#34;&#34;

        table = self.table
        if record is None:
            record = self.record

        isActual = (
            table not in ACTUAL_TABLES
            or not record
            or G(record, N.actual, default=False)
        )
        return E if isActual else &#34;inactual&#34;

    @staticmethod
    def titleRaw(obj, record, cls=E):
        &#34;&#34;&#34;Generate a title for a different record.

        This is fast title generation.
        No record object will be created.

        The title will be based on the fields in the record,
        and its formatting is assisted by the appropriate
        type class in `control.typ.types`.

        !!! hint
            If the record is  not &#34;actual&#34;, its title will get a warning
            background color.
            See `control.db.Db.collect`.

        Parameters
        ----------
        obj: object
            Any object that has a table and context attribute, e.g. a table object
            or a record object
        record: dict
        cls: string, optional, `&#39;&#39;`
            A CSS class to add to the outer element of the result
        &#34;&#34;&#34;

        table = obj.table
        context = obj.context

        types = context.types
        typesObj = getattr(types, table, None)

        inActualCls = Record.inActualCls(obj, record)
        atts = dict(cls=f&#34;{cls} {inActualCls}&#34;)

        return H.span(typesObj.title(record=record), **atts)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="control.cust.assessment_record.AssessmentR" href="cust/assessment_record.html#control.cust.assessment_record.AssessmentR">AssessmentR</a></li>
<li><a title="control.cust.criteria_record.CriteriaR" href="cust/criteria_record.html#control.cust.criteria_record.CriteriaR">CriteriaR</a></li>
<li><a title="control.cust.criteriaentry_record.CriteriaEntryR" href="cust/criteriaentry_record.html#control.cust.criteriaentry_record.CriteriaEntryR">CriteriaEntryR</a></li>
<li><a title="control.cust.review_record.ReviewR" href="cust/review_record.html#control.cust.review_record.ReviewR">ReviewR</a></li>
<li><a title="control.cust.reviewentry_record.ReviewEntryR" href="cust/reviewentry_record.html#control.cust.reviewentry_record.ReviewEntryR">ReviewEntryR</a></li>
<li><a title="control.cust.score_record.ScoreR" href="cust/score_record.html#control.cust.score_record.ScoreR">ScoreR</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="control.record.Record.inheritProps"><code class="name">var <span class="ident">inheritProps</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="control.record.Record.titleRaw"><code class="name flex">
<span>def <span class="ident">titleRaw</span></span>(<span>obj, record, cls='')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a title for a different record.</p>
<p>This is fast title generation.
No record object will be created.</p>
<p>The title will be based on the fields in the record,
and its formatting is assisted by the appropriate
type class in <code><a title="control.typ.types" href="typ/types.html">control.typ.types</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If the record is
not "actual", its title will get a warning
background color.
See <code><a title="control.db.Db.collect" href="db.html#control.db.Db.collect">Db.collect()</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>object</code></dt>
<dd>Any object that has a table and context attribute, e.g. a table object
or a record object</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cls</code></strong> :&ensp;<code>string</code>, optional<code>, </code>''``</dt>
<dd>A CSS class to add to the outer element of the result</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def titleRaw(obj, record, cls=E):
    &#34;&#34;&#34;Generate a title for a different record.

    This is fast title generation.
    No record object will be created.

    The title will be based on the fields in the record,
    and its formatting is assisted by the appropriate
    type class in `control.typ.types`.

    !!! hint
        If the record is  not &#34;actual&#34;, its title will get a warning
        background color.
        See `control.db.Db.collect`.

    Parameters
    ----------
    obj: object
        Any object that has a table and context attribute, e.g. a table object
        or a record object
    record: dict
    cls: string, optional, `&#39;&#39;`
        A CSS class to add to the outer element of the result
    &#34;&#34;&#34;

    table = obj.table
    context = obj.context

    types = context.types
    typesObj = getattr(types, table, None)

    inActualCls = Record.inActualCls(obj, record)
    atts = dict(cls=f&#34;{cls} {inActualCls}&#34;)

    return H.span(typesObj.title(record=record), **atts)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="control.record.Record.DetailsClass"><code class="name">var <span class="ident">DetailsClass</span></code></dt>
<dd>
<div class="desc"><p><em>class</em> The class used for presenting details of this record.</p>
<p>It might be the base class <code><a title="control.details.Details" href="details.html#control.details.Details">Details</a></code>
or one of its
derived classes.</p></div>
</dd>
<dt id="control.record.Record.bodyMethod"><code class="name">var <span class="ident">bodyMethod</span></code></dt>
<dd>
<div class="desc"><p><em>function</em> How to compose the HTML for the body of the record.</p></div>
</dd>
<dt id="control.record.Record.eid"><code class="name">var <span class="ident">eid</span></code></dt>
<dd>
<div class="desc"><p><em>ObjectId</em> The id of the record.</p></div>
</dd>
<dt id="control.record.Record.mayDelete"><code class="name">var <span class="ident">mayDelete</span></code></dt>
<dd>
<div class="desc"><p><em>boolean</em> Whether the user may delete the record.</p></div>
</dd>
<dt id="control.record.Record.readonly"><code class="name">var <span class="ident">readonly</span></code></dt>
<dd>
<div class="desc"><p><em>boolean</em> Whether to present the complete record in readonly mode.</p></div>
</dd>
<dt id="control.record.Record.record"><code class="name">var <span class="ident">record</span></code></dt>
<dd>
<div class="desc"><p><em>dict</em> The data of the record, keyed by field names.</p></div>
</dd>
<dt id="control.record.Record.tableObj"><code class="name">var <span class="ident">tableObj</span></code></dt>
<dd>
<div class="desc"><p><em>object</em> A <code><a title="control.table.Table" href="table.html#control.table.Table">Table</a></code> object (or one of a derived class)</p></div>
</dd>
<dt id="control.record.Record.withDetails"><code class="name">var <span class="ident">withDetails</span></code></dt>
<dd>
<div class="desc"><p><em>boolean</em> Whether to present a list of detail records below the record.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.record.Record.adjustWorkflow"><code class="name flex">
<span>def <span class="ident">adjustWorkflow</span></span>(<span>self, update=True, delete=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Recompute workflow information.</p>
<p>When this record or some other record has changed, it could have had
an impact on the workflow.
If there is reason to assume this has happened, this function can be called
to recompute the workflow item.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not confuse this method with the one with the same name in Tables:
<code><a title="control.table.Table.adjustWorkflow" href="table.html#control.table.Table.adjustWorkflow">Table.adjustWorkflow()</a></code> which does its work after the
insertion of a record.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>update</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If <code>True</code>, reset the attribute <code>wfitem</code> to the recomputed workflow.
Otherwise, recomputation is done, but the attribute is not reset.
This is done if there is no use of the workflow info for the remaining
steps in processing the request.</dd>
<dt><strong><code>delete</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, delete the workflow item and set the attribute <code>wfitem</code>
to <code>None</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>The attribute <code>wfitem</code> will be set again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjustWorkflow(self, update=True, delete=False):
    &#34;&#34;&#34;Recompute workflow information.

    When this record or some other record has changed, it could have had
    an impact on the workflow.
    If there is reason to assume this has happened, this function can be called
    to recompute the workflow item.

    !!! warning
        Do not confuse this method with the one with the same name in Tables:
        `control.table.Table.adjustWorkflow` which does its work after the
        insertion of a record.

    Parameters
    ----------
    update: boolean, optional `True`
        If `True`, reset the attribute `wfitem` to the recomputed workflow.
        Otherwise, recomputation is done, but the attribute is not reset.
        This is done if there is no use of the workflow info for the remaining
        steps in processing the request.
    delete: boolean, optional `False`
        If `True`, delete the workflow item and set the attribute `wfitem`
        to `None`

    Returns
    -------
    void
        The attribute `wfitem` will be set again.
    &#34;&#34;&#34;

    context = self.context
    wf = context.wf
    perm = self.perm

    contribId = G(perm, N.contribId)
    if delete:
        wf.delete(contribId)
        self.wfitem = None
    else:
        wf.recompute(contribId)
        if update:
            self.wfitem = context.getWorkflowItem(contribId, requireFresh=True)</code></pre>
</details>
</dd>
<dt id="control.record.Record.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, myMasters=None, hideMasters=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap the body of the record in HTML.</p>
<p>This is the part without the provenance information and without
the detail records.</p>
<p>This method can be overridden by <code>body</code> methods in derived classes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>myMasters</code></strong> :&ensp;<code>iterable</code> of <code>string</code>, optional <code>None</code></dt>
<dd>A declaration of which fields must be treated as master fields.</dd>
<dt><strong><code>hideMaster</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, all master fields as declared in <code>myMasters</code> will be left out.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string(html)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, myMasters=None, hideMasters=False):
    &#34;&#34;&#34;Wrap the body of the record in HTML.

    This is the part without the provenance information and without
    the detail records.

    This method can be overridden by `body` methods in derived classes.

    Parameters
    ----------
    myMasters: iterable of string, optional `None`
        A declaration of which fields must be treated as master fields.
    hideMaster: boolean, optional `False`
        If `True`, all master fields as declared in `myMasters` will be left out.

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    fieldSpecs = self.fields
    provSpecs = self.prov

    return H.join(
        self.field(field, asMaster=field in myMasters).wrap()
        for field in fieldSpecs
        if (field not in provSpecs and not (hideMasters and field in myMasters))
    )</code></pre>
</details>
</dd>
<dt id="control.record.Record.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a record.</p>
<p>Permissions and dependencies will be checked, as a result,
the deletion may be prevented.
See <code><a title="control.record.Record.getDependencies" href="#control.record.Record.getDependencies">Record.getDependencies()</a></code> and <code><a title="control.record.Record.getDelPerm" href="#control.record.Record.getDelPerm">Record.getDelPerm()</a></code>.</p>
<p>If deletion happens, workflow information will be adapted afterwards.
See <code><a title="control.record.Record.adjustWorkflow" href="#control.record.Record.adjustWorkflow">Record.adjustWorkflow()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    &#34;&#34;&#34;Delete a record.

    Permissions and dependencies will be checked, as a result,
    the deletion may be prevented.
    See `Record.getDependencies` and `Record.getDelPerm`.

    If deletion happens, workflow information will be adapted afterwards.
    See `Record.adjustWorkflow`.
    &#34;&#34;&#34;

    mayDelete = self.mayDelete
    if not mayDelete:
        return False

    dependencies = self.getDependencies()
    nRef = G(dependencies, N.reference, default=0)

    if nRef:
        return False

    nCas = G(dependencies, N.cascade, default=0)
    if nCas:
        if not self.deleteDetails():
            return False

    context = self.context
    table = self.table
    eid = self.eid

    good = context.deleteItem(table, eid)

    if table == MAIN_TABLE:
        self.adjustWorkflow(delete=True)
    elif table in WORKFLOW_TABLES:
        self.adjustWorkflow(update=False)

    return good</code></pre>
</details>
</dd>
<dt id="control.record.Record.deleteButton"><code class="name flex">
<span>def <span class="ident">deleteButton</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the delete button and/or the number of dependencies.</p>
<p>Check the permissions in order to not show a delete button if the user
cannot delete the record.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string(html)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteButton(self):
    &#34;&#34;&#34;Show the delete button and/or the number of dependencies.

    Check the permissions in order to not show a delete button if the user
    cannot delete the record.

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    mayDelete = self.mayDelete

    if not mayDelete:
        return E

    record = self.record
    table = self.table
    itemSingle = self.itemLabels[0]

    dependencies = self.getDependencies()

    nCas = G(dependencies, N.cascade, default=0)
    cascadeMsg = (
        H.span(
            f&#34;&#34;&#34;{nCas} detail record{E if nCas == 1 else S}&#34;&#34;&#34;,
            title=&#34;&#34;&#34;Detail records will be deleted with the master record&#34;&#34;&#34;,
            cls=&#34;label small warning-o right&#34;,
        )
        if nCas
        else E
    )
    cascadeMsgShort = (
        f&#34;&#34;&#34; and {nCas} dependent record{E if nCas == 1 else S}&#34;&#34;&#34; if nCas else E
    )

    nRef = G(dependencies, N.reference, default=0)

    if nRef:
        plural = E if nRef == 1 else S
        return H.span(
            [
                H.icon(
                    N.chain,
                    cls=&#34;medium right&#34;,
                    title=f&#34;&#34;&#34;Cannot delete because of {nRef} dependent record{plural}&#34;&#34;&#34;,
                ),
                H.span(
                    f&#34;&#34;&#34;{nRef} dependent record{plural}&#34;&#34;&#34;,
                    cls=&#34;label small warning-o right&#34;,
                ),
            ]
        )

    if table in TO_MASTER:
        masterTable = G(TO_MASTER, table)
        masterId = G(record, masterTable)
    else:
        masterTable = None
        masterId = None

    url = (
        f&#34;&#34;&#34;/api/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
        if masterTable is None or masterId is None
        else f&#34;&#34;&#34;/api/{masterTable}/{masterId}/{table}/{N.delete}/{G(record, N._id)}&#34;&#34;&#34;
    )
    return H.span(
        [
            cascadeMsg,
            H.iconx(
                N.delete,
                cls=&#34;medium right warning&#34;,
                deleteurl=url,
                title=f&#34;&#34;&#34;delete this {itemSingle}{cascadeMsgShort}&#34;&#34;&#34;,
            ),
        ]
    )</code></pre>
</details>
</dd>
<dt id="control.record.Record.deleteDetails"><code class="name flex">
<span>def <span class="ident">deleteDetails</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the details of a record.</p>
<p>Permissions and dependencies will be checked, as a result,
the deletion may be prevented.
See <code><a title="control.record.Record.getDependencies" href="#control.record.Record.getDependencies">Record.getDependencies()</a></code> and <code><a title="control.record.Record.getDelPerm" href="#control.record.Record.getDelPerm">Record.getDelPerm()</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether there are still dependencies after deleting the details.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteDetails(self):
    &#34;&#34;&#34;Delete the details of a record.

    Permissions and dependencies will be checked, as a result,
    the deletion may be prevented.
    See `Record.getDependencies` and `Record.getDelPerm`.

    Returns
    -------
    bool
        Whether there are still dependencies after deleting the details.
    &#34;&#34;&#34;

    context = self.context
    db = context.db
    table = self.table
    eid = self.eid

    for dtable in G(CASCADE_SPECS, table, default=[]):
        db.deleteMany(dtable, {table: eid})
    dependencies = self.getDependencies()
    nRef = G(dependencies, N.reference, default=0)
    return nRef == 0</code></pre>
</details>
</dd>
<dt id="control.record.Record.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>self, fieldName, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Factory function to wrap a field object around the data of a field.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Workflow information will be checked whether this record is fixated.
If so, the new field object will be initialized with parameters
to make it uneditable.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It will also be checked whether the field is a workflow field.
Such fields are not shown and edited in the normal way,
hence they will be set to unreadable and uneditable.
The manipulation of such fields is under control of workflow.
See <code><a title="control.workflow.apply.WorkflowItem.isTask" href="workflow/apply.html#control.workflow.apply.WorkflowItem.isTask">WorkflowItem.isTask()</a></code>.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The name of the field must be one for which field specs are defined
in the yaml file for the table.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fieldName</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>A <code><a title="control.field.Field" href="field.html#control.field.Field">Field</a></code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field(self, fieldName, **kwargs):
    &#34;&#34;&#34;Factory function to wrap a field object around the data of a field.

    !!! note
        Workflow information will be checked whether this record is fixated.
        If so, the new field object will be initialized with parameters
        to make it uneditable.

    !!! note
        It will also be checked whether the field is a workflow field.
        Such fields are not shown and edited in the normal way,
        hence they will be set to unreadable and uneditable.
        The manipulation of such fields is under control of workflow.
        See `control.workflow.apply.WorkflowItem.isTask`.

    !!! caution
        The name of the field must be one for which field specs are defined
        in the yaml file for the table.

    Parameters
    ----------
    fieldName: string

    Returns
    -------
    object
        A `control.field.Field` object.
    &#34;&#34;&#34;

    fields = self.fields
    if fieldName not in fields:
        return None

    table = self.table
    wfitem = self.wfitem

    forceEdit = G(kwargs, N.mayEdit)

    if wfitem:
        fixed = wfitem.checkFixed(self, field=fieldName)
        if fixed:
            kwargs[N.mayEdit] = False
        if wfitem.isTask(table, fieldName):
            kwargs[N.mayRead] = False
            kwargs[N.mayEdit] = forceEdit or not fixed
    return Field(self, fieldName, **kwargs)</code></pre>
</details>
</dd>
<dt id="control.record.Record.getDelPerm"><code class="name flex">
<span>def <span class="ident">getDelPerm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the delete permission for this record.</p>
<p>The unbreakable rule is:
*
Records with dependencies cannot be deleted if the dependencies
are not configured as <code>cascade-delete</code> in tables.yaml.</p>
<p>The next rules are workflow rules:</p>
<ul>
<li>if a record is fixed due to workflow constraints, no one can delete it;</li>
<li>if a record is unfixed due to workflow, a user may delete it,
irrespective of normal permissions; workflow will determine
which records will appear unfixed to which users;</li>
</ul>
<p>If these rules do not clinch it, the normal permission rules will
be applied:</p>
<ul>
<li>authenticated users may delete their own records in the
<code>contrib</code>, <code>assessment</code> and <code>review</code> tables</li>
<li>superusers may delete records if the configured edit
permissions allow them</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDelPerm(self):
    &#34;&#34;&#34;Compute the delete permission for this record.

        The unbreakable rule is:
        *   Records with dependencies cannot be deleted if the dependencies
            are not configured as `cascade-delete` in tables.yaml.

        The next rules are workflow rules:

        *   if a record is fixed due to workflow constraints, no one can delete it;
        *   if a record is unfixed due to workflow, a user may delete it,
            irrespective of normal permissions; workflow will determine
            which records will appear unfixed to which users;

        If these rules do not clinch it, the normal permission rules will
        be applied:

        *   authenticated users may delete their own records in the
            `contrib`, `assessment` and `review` tables
        *   superusers may delete records if the configured edit
            permissions allow them
    &#34;&#34;&#34;

    context = self.context
    auth = context.auth
    isUserTable = self.isUserTable
    isUserEntryTable = self.isUserEntryTable
    readonly = self.readonly
    perm = self.perm
    fixed = self.fixed

    isAuthenticated = auth.authenticated()
    isSuperuser = auth.superuser()

    normalDelPerm = (
        not isUserEntryTable
        and not readonly
        and isAuthenticated
        and (isSuperuser or isUserTable and G(perm, N.isEdit))
    )
    return False if fixed else normalDelPerm</code></pre>
</details>
</dd>
<dt id="control.record.Record.getDependencies"><code class="name flex">
<span>def <span class="ident">getDependencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute dependent records.</p>
<p>See <code><a title="control.db.Db.dependencies" href="db.html#control.db.Db.dependencies">Db.dependencies()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDependencies(self):
    &#34;&#34;&#34;Compute dependent records.

    See `control.db.Db.dependencies`.
    &#34;&#34;&#34;

    context = self.context
    db = context.db
    table = self.table
    record = self.record

    return db.dependencies(table, record)</code></pre>
</details>
</dd>
<dt id="control.record.Record.inActualCls"><code class="name flex">
<span>def <span class="ident">inActualCls</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a CSS class name for a record based on whether it is <em>actual</em>.</p>
<p>Actual records belong to the current <code>package</code>, a record that specifies
which contribution types, and criteria are currently part of the workflow.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>dict |</code>None``</dt>
<dd>If <code>self</code> does not have a <code>record</code> attribute, the record data must
be passed here.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd><code>inactual</code> if the record is not actual, else the empty string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inActualCls(self, record):
    &#34;&#34;&#34;Get a CSS class name for a record based on whether it is *actual*.

    Actual records belong to the current `package`, a record that specifies
    which contribution types, and criteria are currently part of the workflow.

    Parameters
    ----------
    record: dict | `None`
        If `self` does not have a `record` attribute, the record data must
        be passed here.
    Returns
    -------
    string
        `inactual` if the record is not actual, else the empty string.
    &#34;&#34;&#34;

    table = self.table
    if record is None:
        record = self.record

    isActual = (
        table not in ACTUAL_TABLES
        or not record
        or G(record, N.actual, default=False)
    )
    return E if isActual else &#34;inactual&#34;</code></pre>
</details>
</dd>
<dt id="control.record.Record.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-initializes a record object if its underlying data has changed.</p>
<p>This might be caused by an update in the record itself,
or a change in workflow conditions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(
    self, record,
):
    &#34;&#34;&#34;Re-initializes a record object if its underlying data has changed.

    This might be caused by an update in the record itself,
    or a change in workflow conditions.
    &#34;&#34;&#34;

    self.record = record
    self.setPerm()
    self.setWorkflow()
    self.mayDelete = self.getDelPerm()</code></pre>
</details>
</dd>
<dt id="control.record.Record.setPerm"><code class="name flex">
<span>def <span class="ident">setPerm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute permission info for this record.</p>
<p>See <code><a title="control.perm.permRecord" href="perm.html#control.perm.permRecord">permRecord()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPerm(self):
    &#34;&#34;&#34;Compute permission info for this record.

    See `control.perm.permRecord`.
    &#34;&#34;&#34;

    context = self.context
    table = self.table
    record = self.record

    self.perm = permRecord(context, table, record)</code></pre>
</details>
</dd>
<dt id="control.record.Record.setWorkflow"><code class="name flex">
<span>def <span class="ident">setWorkflow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a workflow item for this record.</p>
<p>The workflow item corresponds to this record
if it is in the contrib table, otherwise to the
contrib that is the (grand)master of this record.</p>
<p>See <code><a title="control.context.Context.getWorkflowItem" href="context.html#control.context.Context.getWorkflowItem">Context.getWorkflowItem()</a></code> and
<code><a title="control.workflow.apply.WorkflowItem" href="workflow/apply.html#control.workflow.apply.WorkflowItem">WorkflowItem</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>The attribute <code>wfitem</code> will point to the workflow item.
If the record is not a valid part of any workflow,
or if there is no workflow item found,
<code>wfitem</code> will be set to <code>None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setWorkflow(self):
    &#34;&#34;&#34;Compute a workflow item for this record.

    The workflow item corresponds to this record
    if it is in the contrib table, otherwise to the
    contrib that is the (grand)master of this record.

    See `control.context.Context.getWorkflowItem` and
    `control.workflow.apply.WorkflowItem`.

    Returns
    -------
    void
        The attribute `wfitem` will point to the workflow item.
        If the record is not a valid part of any workflow,
        or if there is no workflow item found,
        `wfitem` will be set to `None`.
    &#34;&#34;&#34;

    context = self.context
    perm = self.perm
    table = self.table
    eid = self.eid
    record = self.record

    contribId = G(perm, N.contribId)

    self.kind = None
    self.fixed = None
    valid = False

    wfitem = context.getWorkflowItem(contribId)
    if wfitem:
        self.kind = wfitem.getKind(table, record)
        valid = wfitem.isValid(table, eid, record)
        self.mayRead = wfitem.checkReadable(self)
    else:
        valid = False if table in USER_TABLES - {MAIN_TABLE} else True
        self.mayRead = None

    if valid and wfitem:
        self.fixed = wfitem.checkFixed(self)
        self.wfitem = wfitem
    else:
        self.wfitem = None

    self.valid = valid</code></pre>
</details>
</dd>
<dt id="control.record.Record.task"><code class="name flex">
<span>def <span class="ident">task</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a workflow task.</p>
<p>See <code><a title="control.workflow.apply.WorkflowItem.doTask" href="workflow/apply.html#control.workflow.apply.WorkflowItem.doTask">WorkflowItem.doTask()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def task(self, task):
    &#34;&#34;&#34;Perform a workflow task.

    See `control.workflow.apply.WorkflowItem.doTask`.
    &#34;&#34;&#34;

    wfitem = self.wfitem

    url = None
    good = False

    if wfitem:
        url = wfitem.doTask(task, self)

    if url is None:
        table = self.table
        eid = self.eid
        url = f&#34;&#34;&#34;/{table}/{N.item}/{eid}&#34;&#34;&#34;
    else:
        good = True
    return (good, url)</code></pre>
</details>
</dd>
<dt id="control.record.Record.title"><code class="name flex">
<span>def <span class="ident">title</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a title for the record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title(self):
    &#34;&#34;&#34;Generate a title for the record.&#34;&#34;&#34;
    record = self.record
    valid = self.valid

    warningCls = E if valid else &#34; warning &#34;

    return Record.titleRaw(self, record, cls=warningCls)</code></pre>
</details>
</dd>
<dt id="control.record.Record.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>self, inner=True, wrapMethod=None, expanded=1, withProv=True, hideMasters=False, showTable=None, showEid=None, extraCls='')</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap the record into HTML.</p>
<p>A record can be displayed in several states:</p>
<table>
<thead>
<tr>
<th>expanded</th>
<th>effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-1</code></td>
<td>only a title with a control to get the full details</td>
</tr>
<tr>
<td><code>0</code></td>
<td>full details, no control to collapse/expand</td>
</tr>
<tr>
<td><code>1</code></td>
<td>full details, with a control to collapse to the title</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a record in state <code>1</code> or <code>-1</code> is sent to the client,
only the material that is displayed is sent. When the user clicks on the
expand/collapse control, the other part is fetched from the server
<em>at that very moment</em>.
So collapsing/expanding can be used to refresh the view on a record
if things have happened.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The triggering of the fetch actions for expanded/collapsed material
is done by the Javascript in <code>index.js</code>.
A single function does it all, and it is sensitive to the exact attributes
of the summary and the detail.
If you tamper with this code, you might end up with an infinite loop of
expanding and collapsing.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Pay extra attension to the attribute <code>fat</code>!
When it is present, it is an indication that the expanded material
is already on the client, and that it does not have to be fetched.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are several ways to customise the effect of <code>wrap</code> for specific
tables. Start with writing a derived class for that table with
<code><a title="control.record.Record" href="#control.record.Record">Record</a></code> as base class.</p>
<ul>
<li>write an alternative for <code><a title="control.record.Record.body" href="#control.record.Record.body">Record.body()</a></code>,
e.g. <code><a title="control.cust.review_record.ReviewR.bodyCompact" href="cust/review_record.html#control.cust.review_record.ReviewR.bodyCompact">ReviewR.bodyCompact()</a></code>, and
initialize the <code><a title="control.record.Record" href="#control.record.Record">Record</a></code> with <code>(bodyMethod='compact')</code>.
Just specify the part of the name after <code>body</code> as string starting
with a lower case.</li>
<li>override <code><a title="control.record.Record.body" href="#control.record.Record.body">Record.body()</a></code>. This app does not do this currently.</li>
<li>use a custom <code>wrap</code> function, by defining it in your derived class,
e.g. <code><a title="control.cust.score_record.ScoreR.wrapHelp" href="cust/score_record.html#control.cust.score_record.ScoreR.wrapHelp">ScoreR.wrapHelp()</a></code>.
Use it by calling <code>Record.wrap(wrapMethod=scoreObj.wrapHelp)</code>.</li>
</ul>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inner</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to add the CSS class <code>inner</code> to the outer <code>&lt;div&gt;</code> of the result.</dd>
<dt><strong><code>wrapMethod</code></strong> :&ensp;<code>function</code>, optional <code>None</code></dt>
<dd>The method to compose the result out of all its components.
Typically defined in a derived class.
If passed, this function will be called to deliver the result.
Otherwise, <code>wrap</code> does the composition itself.</dd>
<dt><strong><code>expanded</code></strong> :&ensp;<code>{-1, 0, 1}</code></dt>
<dd>Whether to expand the record.
See the table above.</dd>
<dt><strong><code>withProv</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Include a display of the provenance fields.</dd>
<dt><strong><code>hideMasters</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to hide the master fields.
If they are not hidden, they will be presented as hyperlinks to the
master record.</dd>
<dt><strong><code>extraCls</code></strong> :&ensp;<code>string</code>, optional <code>''</code></dt>
<dd>An extra class to add to the outer <code>&lt;div&gt;</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string(html)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(
    self,
    inner=True,
    wrapMethod=None,
    expanded=1,
    withProv=True,
    hideMasters=False,
    showTable=None,
    showEid=None,
    extraCls=E,
):
    &#34;&#34;&#34;Wrap the record into HTML.

    A record can be displayed in several states:

    expanded | effect
    --- | ---
    `-1` | only a title with a control to get the full details
    `0` | full details, no control to collapse/expand
    `1` | full details, with a control to collapse to the title

    !!! note
        When a record in state `1` or `-1` is sent to the client,
        only the material that is displayed is sent. When the user clicks on the
        expand/collapse control, the other part is fetched from the server
        *at that very moment*.
        So collapsing/expanding can be used to refresh the view on a record
        if things have happened.

    !!! caution
        The triggering of the fetch actions for expanded/collapsed material
        is done by the Javascript in `index.js`.
        A single function does it all, and it is sensitive to the exact attributes
        of the summary and the detail.
        If you tamper with this code, you might end up with an infinite loop of
        expanding and collapsing.

    !!! hint
        Pay extra attension to the attribute `fat`!
        When it is present, it is an indication that the expanded material
        is already on the client, and that it does not have to be fetched.

    !!! note
        There are several ways to customise the effect of `wrap` for specific
        tables. Start with writing a derived class for that table with
        `Record` as base class.

        *   write an alternative for `Record.body`,
            e.g. `control.cust.review_record.ReviewR.bodyCompact`, and
            initialize the `Record` with `(bodyMethod=&#39;compact&#39;)`.
            Just specify the part of the name after `body` as string starting
            with a lower case.
        *   override `Record.body`. This app does not do this currently.
        *   use a custom `wrap` function, by defining it in your derived class,
            e.g. `control.cust.score_record.ScoreR.wrapHelp`.
            Use it by calling `Record.wrap(wrapMethod=scoreObj.wrapHelp)`.

    Parameters
    ----------
    inner: boolean, optional `True`
        Whether to add the CSS class `inner` to the outer `&lt;div&gt;` of the result.
    wrapMethod: function, optional `None`
        The method to compose the result out of all its components.
        Typically defined in a derived class.
        If passed, this function will be called to deliver the result.
        Otherwise, `wrap` does the composition itself.
    expanded: {-1, 0, 1}
        Whether to expand the record.
        See the table above.
    withProv: boolean, optional `True`
        Include a display of the provenance fields.
    hideMasters: boolean, optional `False`
        Whether to hide the master fields.
        If they are not hidden, they will be presented as hyperlinks to the
        master record.
    extraCls: string, optional `&#39;&#39;`
        An extra class to add to the outer `&lt;div&gt;`.

    Returns
    -------
    string(html)
    &#34;&#34;&#34;

    table = self.table
    eid = self.eid
    record = self.record
    provSpecs = self.prov
    valid = self.valid
    withDetails = self.withDetails

    withRefresh = table in REFRESH_TABLES

    func = getattr(self, wrapMethod, None) if wrapMethod else None
    if func:
        return func()

    bodyMethod = self.bodyMethod
    urlExtra = f&#34;&#34;&#34;?method={bodyMethod}&#34;&#34;&#34; if bodyMethod else E
    fetchUrl = f&#34;&#34;&#34;/api/{table}/{N.item}/{eid}&#34;&#34;&#34;

    itemKey = f&#34;&#34;&#34;{table}/{G(record, N._id)}&#34;&#34;&#34;
    theTitle = self.title()

    if expanded == -1:
        return H.details(
            theTitle,
            H.div(ELLIPS),
            itemKey,
            fetchurl=fetchUrl,
            urlextra=urlExtra,
            urltitle=E,
        )

    bodyFunc = (
        getattr(self, f&#34;&#34;&#34;{N.body}{cap1(bodyMethod)}&#34;&#34;&#34;, self.body)
        if bodyMethod
        else self.body
    )
    myMasters = G(MASTERS, table, default=[])

    deleteButton = self.deleteButton()

    innerCls = &#34; inner&#34; if inner else E
    warningCls = E if valid else &#34; warning &#34;

    provenance = (
        H.div(
            H.detailx(
                (N.prov, N.dismiss),
                H.div(
                    [self.field(field).wrap() for field in provSpecs], cls=&#34;prov&#34;
                ),
                f&#34;&#34;&#34;{table}/{G(record, N._id)}/{N.prov}&#34;&#34;&#34;,
                openAtts=dict(
                    cls=&#34;button small&#34;,
                    title=&#34;Provenance and editors of this record&#34;,
                ),
                closeAtts=dict(cls=&#34;button small&#34;, title=&#34;Hide provenance&#34;),
                cls=&#34;prov&#34;,
            ),
            cls=&#34;provx&#34;,
        )
        if withProv
        else E
    )

    main = H.div(
        [
            deleteButton,
            H.div(
                H.join(bodyFunc(myMasters=myMasters, hideMasters=hideMasters)),
                cls=f&#34;{table.lower()}&#34;,
            ),
            *provenance,
        ],
        cls=f&#34;record{innerCls} {extraCls} {warningCls}&#34;,
    )

    rButton = H.iconr(itemKey, &#34;#main&#34;, msg=table) if withRefresh else E
    details = (
        self.DetailsClass(self).wrap(showTable=showTable, showEid=showEid)
        if withDetails
        else E
    )

    return (
        H.details(
            rButton + theTitle,
            H.div(main + details),
            itemKey,
            fetchurl=fetchUrl,
            urlextra=urlExtra,
            urltitle=&#34;&#34;&#34;/title&#34;&#34;&#34;,
            fat=ONE,
            forceopen=ONE,
            open=True,
        )
        if expanded == 1
        else H.div(main + details)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.record.Record" href="#control.record.Record">Record</a></code></h4>
<ul class="two-column">
<li><code><a title="control.record.Record.DetailsClass" href="#control.record.Record.DetailsClass">DetailsClass</a></code></li>
<li><code><a title="control.record.Record.adjustWorkflow" href="#control.record.Record.adjustWorkflow">adjustWorkflow</a></code></li>
<li><code><a title="control.record.Record.body" href="#control.record.Record.body">body</a></code></li>
<li><code><a title="control.record.Record.bodyMethod" href="#control.record.Record.bodyMethod">bodyMethod</a></code></li>
<li><code><a title="control.record.Record.delete" href="#control.record.Record.delete">delete</a></code></li>
<li><code><a title="control.record.Record.deleteButton" href="#control.record.Record.deleteButton">deleteButton</a></code></li>
<li><code><a title="control.record.Record.deleteDetails" href="#control.record.Record.deleteDetails">deleteDetails</a></code></li>
<li><code><a title="control.record.Record.eid" href="#control.record.Record.eid">eid</a></code></li>
<li><code><a title="control.record.Record.field" href="#control.record.Record.field">field</a></code></li>
<li><code><a title="control.record.Record.getDelPerm" href="#control.record.Record.getDelPerm">getDelPerm</a></code></li>
<li><code><a title="control.record.Record.getDependencies" href="#control.record.Record.getDependencies">getDependencies</a></code></li>
<li><code><a title="control.record.Record.inActualCls" href="#control.record.Record.inActualCls">inActualCls</a></code></li>
<li><code><a title="control.record.Record.inheritProps" href="#control.record.Record.inheritProps">inheritProps</a></code></li>
<li><code><a title="control.record.Record.mayDelete" href="#control.record.Record.mayDelete">mayDelete</a></code></li>
<li><code><a title="control.record.Record.readonly" href="#control.record.Record.readonly">readonly</a></code></li>
<li><code><a title="control.record.Record.record" href="#control.record.Record.record">record</a></code></li>
<li><code><a title="control.record.Record.reload" href="#control.record.Record.reload">reload</a></code></li>
<li><code><a title="control.record.Record.setPerm" href="#control.record.Record.setPerm">setPerm</a></code></li>
<li><code><a title="control.record.Record.setWorkflow" href="#control.record.Record.setWorkflow">setWorkflow</a></code></li>
<li><code><a title="control.record.Record.tableObj" href="#control.record.Record.tableObj">tableObj</a></code></li>
<li><code><a title="control.record.Record.task" href="#control.record.Record.task">task</a></code></li>
<li><code><a title="control.record.Record.title" href="#control.record.Record.title">title</a></code></li>
<li><code><a title="control.record.Record.titleRaw" href="#control.record.Record.titleRaw">titleRaw</a></code></li>
<li><code><a title="control.record.Record.withDetails" href="#control.record.Record.withDetails">withDetails</a></code></li>
<li><code><a title="control.record.Record.wrap" href="#control.record.Record.wrap">wrap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>