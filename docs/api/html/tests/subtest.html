<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>subtest API documentation</title>
<meta name="description" content="Higher level assert functions test helpers â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>subtest</code></h1>
</header>
<section id="section-intro">
<p>Higher level assert functions test helpers.</p>
<p>This module contains a bunch of <code>assertXXX</code> functions,
which all have a client as first argument and an expected outcome as last.
They perform higher level tasks for a single client and can be conveniently be
used in iterations using <code><a title="helpers.forall" href="helpers.html#helpers.forall">forall()</a></code>.</p>
<p>There are also some functions that are even higher level, and have been
factored out from concrete test functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Higher level assert functions test helpers.

This module contains a bunch of `assertXXX` functions,
which all have a client as first argument and an expected outcome as last.
They perform higher level tasks for a single client and can be conveniently be
used in iterations using `helpers.forall`.

There are also some functions that are even higher level, and have been
factored out from concrete test functions.
&#34;&#34;&#34;

from control.utils import pick as G, serverprint, E
from conftest import USERS
from example import (
    ASSESS,
    CAPTIONS,
    EDITOR,
    EDITORS,
    REVIEW,
    REVIEW_DECISION,
    START_ASSESSMENT,
    START_REVIEW,
    TITLE,
    TITLE1,
    TITLE2,
    UNDEF_VALUE,
    USER,
    USER_COUNTRY,
)
from helpers import (
    accessUrl,
    findCaptions,
    findMsg,
    findEid,
    findMainN,
    findStages,
    forall,
    getEid,
    getItem,
    modifyField,
    shiftDate,
)


def assertAddItem(client, table, expect):
    &#34;&#34;&#34;Adds an item to a table.

    The response texts will be analysed into messages and fields, the eid
    of the new item will be read off.

    Parameters
    ----------
    client: fixture
    table: string
    expect: boolean

    Returns
    -------
    eid: str(ObjectId)
        The id of the inserted item.
    &#34;&#34;&#34;

    response = client.get(f&#34;/api/{table}/insert&#34;, follow_redirects=True)
    text = response.get_data(as_text=True)
    msgs = findMsg(text)
    eid = findEid(text)
    if expect:
        assert &#34;item added&#34; in msgs
    else:
        assert &#34;item added&#34; not in msgs
    return eid


def assertCaptions(client, expect):
    &#34;&#34;&#34;Check whether a response text shows a certain set of captions.

    Parameters
    ----------
    client: fixture
    expect: set of string
    &#34;&#34;&#34;

    url = &#34;/&#34;
    (text, status, msgs) = accessUrl(client, url)
    captionsFound = {caption: url for (caption, url) in findCaptions(text)}
    for caption in captionsFound:
        assert caption in expect
    for caption in expect:
        assert caption in captionsFound
    for (caption, url) in captionsFound.items():
        (expNumber, expItem) = expect[caption]
        serverprint(f&#34;CAPTION {caption}: {client.user} CLICKS {url}&#34;)
        (text, status, msgs) = accessUrl(client, url)
        if expNumber is None:
            expItem in text
        else:
            (n, item) = findMainN(text)[0]
            nX = f&#34;=/={expNumber}&#34; if n != str(expNumber) else E
            iX = f&#34;=/={expItem}&#34; if item != expItem else E
            if iX or nX:
                serverprint(f&#34;CAPTION {caption}: {n}{nX} {item}{iX}&#34;)
            assert n == str(expNumber)
            assert item == expItem


def assertDelItem(client, table, eid, expect):
    &#34;&#34;&#34;Deletes an item from a table.

    Parameters
    ----------
    client: fixture
    table: string
    eid: string(ObjectId)
    expect: boolean
    &#34;&#34;&#34;

    assertStatus(client, f&#34;/api/{table}/delete/{eid}&#34;, expect)


def assertEditor(client, table, eid, valueTables, expect, clear=False):
    &#34;&#34;&#34;Sets the `editors` of an item to **editor**, or clears the `editors` field.

    Parameters
    ----------
    table: string
    eid: string(ObjectId)
    valueTables: the store for the value tables
    expect: boolean
    clear: boolean, optional `False`
        If True, clears the editors field.
    &#34;&#34;&#34;

    if clear:
        value = ([], &#34;&#34;)
    else:
        users = valueTables[USER]
        editorId = users[EDITOR]
        value = ([editorId], EDITOR)
    assertModifyField(client, table, eid, EDITORS, value, expect)


def assertFieldValue(source, field, expect):
    &#34;&#34;&#34;Verify whether a field has a certain expected value.

    If we pass expect `None` we want to assert that the field is not present at all.

    Parameters
    ----------
    source: dict | (client: fixture, table: string, eid: string)
        The dictionary of fields and values of a retrieved response.
        If it is a tuple, the dictionary will be retrieved by looking up
        the item specified by `table` and `eid`.
    field: string
        The name of the specific field.
    expect:
        The expected value for this field.
    &#34;&#34;&#34;

    if type(source) is tuple:
        (client, table, eid) = source
        info = getItem(client, table, eid)
        fields = info[&#34;fields&#34;]
    else:
        fields = source

    if expect is None:
        assert field not in fields
    else:
        assert field in fields
        value = fields[field]
        if value != expect:
            serverprint(f&#34;FIELDVALUE {field}={value} (=/={expect})&#34;)
        assert expect == fields[field]


def assertModifyField(client, table, eid, field, newValue, expect):
    &#34;&#34;&#34;Try to modify a field and check the outcome.

    !!! note &#34;Read access&#34;
        The test has to reckon with the fact that the client may not even have
        read access to the field.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    field: string
    newValue: string | tuple
        If a tuple, the first component is the modification value,
        and the second component is the value we read back from the modified record
    expect: boolean
        Whether we expect the modification to succeed
    &#34;&#34;&#34;

    if not expect:
        info = getItem(client, table, eid)
        fields = info[&#34;fields&#34;]
        oldValue = fields[field] if field in fields else None

    if type(newValue) is tuple:
        (newValue, newValueRep) = newValue
    else:
        newValueRep = newValue

    (text, fields) = modifyField(client, table, eid, field, newValue)

    if not expect:
        assert field not in fields

    info = getItem(client, table, eid)
    fields = info[&#34;fields&#34;]

    if expect:
        assertFieldValue(fields, field, newValueRep)
    else:
        if field in fields:
            assertFieldValue(fields, field, oldValue)


def assertReviewDecisions(clients, reviewId, kinds, decisions, expect):
    &#34;&#34;&#34;Check whether the reviewers can take certain decisions.

    You specify which reviewers take which decisions, and they will
    all be carried out in that order.

    You specifiy the expected outcomes in a dict or a boolean, telling
    whether the taking of the decision is expected to succeed or not.


    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures.
    reviewId: dict
        The review ids for the expert and final review
    kinds: list of {expert, final}
        At most one of each, the order is important.
    decisions: list of {Reject, Revise, Accept, Revoke}
        At most one of each, the order is important.
    expect: bool | dict
        Expected outcomes.
        If it is a boolean, that is the expected outcome of all actions by all
        reviewers.
        Otherwise the dict is keyed by kind of reviewer.
        The values are booleans or dicts.
        A boolean indicates the expected outcome of all actions for that reviewer.
        A dict specifies per action of that reviewer what the outcome is.
    &#34;&#34;&#34;

    for kind in kinds:
        rId = G(reviewId, kind)
        expectKind = (
            True if expect is True else False if expect is False else G(expect, kind)
        )
        for decision in decisions:
            decisionStr = G(G(REVIEW_DECISION, decision), kind)
            url = f&#34;/api/task/{decisionStr}/{rId}&#34;
            exp = (
                True
                if expectKind is True
                else False
                if expectKind is False
                else G(expectKind, decision)
            )
            serverprint(f&#34;REVIEW DECISION {decision} by {kind} expects {exp}&#34;)
            assertStatus(G(clients, kind), url, exp)


def assertShiftDate(clientSys, table, eid, field, amount):
    &#34;&#34;&#34;Shifts the date in a field annd recomputes workflow.

    See `helpers.shiftDate`.
    &#34;&#34;&#34;
    shiftDate(table, eid, field, amount)
    assertStatus(clientSys, &#34;/workflow&#34;, True)


def assertStage(client, table, eid, expect):
    &#34;&#34;&#34;Check whether a record has a certain workflow stage.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    expect: string | set of string
        If a set, we expect one of the values in the set

    Returns
    -------
    dict
        The text, fields, msgs and stage of the record
    &#34;&#34;&#34;

    info = getItem(client, table, eid)
    text = info[&#34;text&#34;]
    stageFound = findStages(text)[0]
    info[&#34;stage&#34;] = stageFound
    if type(expect) is set:
        assert stageFound in expect
    else:
        assert stageFound == expect
    return info


def assertStartTask(client, task, eid, expect):
    &#34;&#34;&#34;Issues a start workflow command.

    There are `startAssessment` and `startReview` tasks that create a record,
    and there are task that set a field in an existing recordd.

    Tasks take as arguments the eid of a record in a table.

    The response texts will be analysed into messages and fields.
    For start tasks, the new eid will be read off and returned, otherwise None is returned.

    Parameters
    ----------
    client: fixture
    eid: string(ObjectId)
        The id that is the argumenent for the workflow task.
    expect: boolean

    Returns
    -------
    eid: str(ObjectId) | `None`
    &#34;&#34;&#34;

    table = (
        ASSESS if task == START_ASSESSMENT else REVIEW if task == START_REVIEW else None
    )
    assert table is not None
    assertStatus(client, f&#34;/api/task/{task}/{eid}&#34;, expect)
    newEid = None
    if expect:
        newEid = getEid(client, table)

    return newEid if task in {START_ASSESSMENT, START_REVIEW} else None


def assertStatus(client, url, expect):
    &#34;&#34;&#34;Get data and see whether that went right or wrong.

    Parameters
    ----------
    client: function
    url: string(url)
        The url to retrieve from the server
    expect: boolean | int | set of int
        If boolean: Whether it is expected to be successful
        If int: status code should be exactly this
        If set of int: status code should be contained in this
    &#34;&#34;&#34;

    try:
        response = client.get(url)
        code = response.status_code
    except Exception as e:
        serverprint(f&#34;APPLICATION ERROR: {e}&#34;)
        code = 4000

    if type(expect) is set:
        good = code in expect
        if not good:
            serverprint(f&#34;STATUS {url} =&gt; {code} (not in {expect})&#34;)
        assert good
    elif type(expect) is int:
        good = code == expect
        if not good:
            serverprint(f&#34;STATUS {url} =&gt; {code} (=/= {expect})&#34;)
        assert good
    else:
        codes = {200, 302} if expect else {400, 303}
        good = code in codes
        if not good:
            serverprint(f&#34;STATUS {url} =&gt; {code} (not in {codes})&#34;)
        assert good


def assignReviewers(clients, users, aId, field, user, keep, expect):
    &#34;&#34;&#34;Verify assigning reviewers to an assessment.

    A reviewer will be assigned to an assessment and immediately be unassigned.
    But the undo can be suppressed.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    users: dict
        Mapping of users to ids
    aId: string(ObjectId)
        Assessment id
    field: string
        Reviewer field (`reviewerE` or `reviewerF`)
    user: string
        The reviewer user
    keep: boolean
        If True, the assignment will not be undone
    expect: dict
        For each user a boolean saying whether that user can assign the reviewer
    &#34;&#34;&#34;

    value = G(users, user)

    def assertIt(cl, exp):
        assertModifyField(cl, ASSESS, aId, field, (value, user), exp)
        if exp and not keep:
            assertModifyField(cl, ASSESS, aId, field, (None, UNDEF_VALUE), True)

    forall(clients, expect, assertIt)


def illegalize(clients, url, **kwargs):
    &#34;&#34;&#34;Append illegal/long arguments to an url and trigger a 400 response.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    kwargs: dict
        Additional parameters to illegalize.
        The url will be expanded by formatting it with the `kwargs` values.
    &#34;&#34;&#34;

    kwargsx = {k: v + &#34;a&#34; * 200 for (k, v) in kwargs.items()}
    base = url.format(**kwargs)
    basex = url.format(**kwargsx)

    uxs = [
        base,
        basex,
        f&#34;{base}?action=xxx&#34;,
        f&#34;{base}?xxx=xxx&#34;,
        f&#34;{base}?action=&#34; + &#34;a&#34; * 200,
        f&#34;{base}?&#34; + &#34;a&#34; * 2000,
    ]

    passable = {200, 301, 302, 303}
    for (i, ux) in enumerate(uxs):
        expectx = {
            user: 400 if i &gt; 2 or i == 1 and len(kwargsx) else passable
            for user in USERS
            if user in clients
        }
        serverprint(f&#34;LEGAL URL ? ({ux})&#34;)
        forall(clients, expectx, assertStatus, ux)


def inspectTitleAll(clients, table, eid, expect):
    &#34;&#34;&#34;Verify the title of an item, as seen by each user.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    table: the table of the item
    eid: the id of the item
    expect: dict
        The expected values, keyed per user
    &#34;&#34;&#34;

    def assertIt(cl, exp):
        assertFieldValue((cl, table, eid), TITLE, exp)

    forall(clients, expect, assertIt)


def modifyTitleAll(clients, table, eid, expect):
    &#34;&#34;&#34;Modify the title of an item, performed by each user.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    table: the table of the item
    eid: the id of the item
    expect: dict
        The expected values, keyed per user
    &#34;&#34;&#34;

    def assertIt(cl, exp):
        assertModifyField(cl, table, eid, TITLE, TITLE2, exp)
        if exp:
            assertModifyField(cl, table, eid, TITLE, TITLE1, exp)

    forall(clients, expect, assertIt)


def sidebar(clients, amounts):
    &#34;&#34;&#34;Verify the sidebar.

    It will be verified whether each user sees the right entries,
    and that following an entry leads to the expected results.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    amounts: dict
        Keyed by entry, it is a list of instructions to change the expected amount.
        Each instruction is a pair `(set of users, amount)`, leading
        to setting the indicated amount for the indicated users.
        The set of users can be left out, then all users are implied.
    &#34;&#34;&#34;

    expectedCaptions = {}
    for (caption, expectedUsers, expectedN, expectedItemSg, expectedItemPl) in CAPTIONS:
        for user in expectedUsers:
            thisCaption = (
                caption.format(country=USER_COUNTRY[user])
                if &#34;{country}&#34; in caption
                else caption
            )
            n = expectedN
            for instruction in G(amounts, thisCaption, default=[]):
                if type(instruction) is tuple or type(instruction) is list:
                    (theseUsers, thisAmount) = instruction
                else:
                    (theseUsers, thisAmount) = (USERS, instruction)
                if user in theseUsers:
                    n = thisAmount
            if n is None:
                expectedItem = expectedItemSg or thisCaption
            else:
                pl = expectedItemPl or thisCaption
                sg = expectedItemSg or thisCaption[0:-1]
                expectedItem = sg if n == 1 else pl
            expectedCaptions.setdefault(user, {})[thisCaption] = (n, expectedItem)

    expect = {user: G(expectedCaptions, user) for user in USERS}
    forall(clients, expect, assertCaptions)


def startAssessment(clients, eid, expect):
    &#34;&#34;&#34;Starts an assessment and deletes it immediately afterwards.

    All users in `clients` for which there is an entry in `expect` do this.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    eid: string(ObjectId)
        The id of the contribution for an assessment is started
    expect: dict
        Per user whether the starting of an assessment succeeds or not
    &#34;&#34;&#34;

    def assertIt(cl, exp):
        aId = assertStartTask(cl, START_ASSESSMENT, eid, exp)
        if exp:
            assert aId is not None
            assertDelItem(cl, ASSESS, aId, True)
        else:
            assert aId is None

    forall(clients, expect, assertIt)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="subtest.assertAddItem"><code class="name flex">
<span>def <span class="ident">assertAddItem</span></span>(<span>client, table, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an item to a table.</p>
<p>The response texts will be analysed into messages and fields, the eid
of the new item will be read off.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eid</code></strong> :&ensp;<code>str(ObjectId)</code></dt>
<dd>The id of the inserted item.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertAddItem(client, table, expect):
    &#34;&#34;&#34;Adds an item to a table.

    The response texts will be analysed into messages and fields, the eid
    of the new item will be read off.

    Parameters
    ----------
    client: fixture
    table: string
    expect: boolean

    Returns
    -------
    eid: str(ObjectId)
        The id of the inserted item.
    &#34;&#34;&#34;

    response = client.get(f&#34;/api/{table}/insert&#34;, follow_redirects=True)
    text = response.get_data(as_text=True)
    msgs = findMsg(text)
    eid = findEid(text)
    if expect:
        assert &#34;item added&#34; in msgs
    else:
        assert &#34;item added&#34; not in msgs
    return eid</code></pre>
</details>
</dd>
<dt id="subtest.assertCaptions"><code class="name flex">
<span>def <span class="ident">assertCaptions</span></span>(<span>client, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a response text shows a certain set of captions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>set</code> of <code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertCaptions(client, expect):
    &#34;&#34;&#34;Check whether a response text shows a certain set of captions.

    Parameters
    ----------
    client: fixture
    expect: set of string
    &#34;&#34;&#34;

    url = &#34;/&#34;
    (text, status, msgs) = accessUrl(client, url)
    captionsFound = {caption: url for (caption, url) in findCaptions(text)}
    for caption in captionsFound:
        assert caption in expect
    for caption in expect:
        assert caption in captionsFound
    for (caption, url) in captionsFound.items():
        (expNumber, expItem) = expect[caption]
        serverprint(f&#34;CAPTION {caption}: {client.user} CLICKS {url}&#34;)
        (text, status, msgs) = accessUrl(client, url)
        if expNumber is None:
            expItem in text
        else:
            (n, item) = findMainN(text)[0]
            nX = f&#34;=/={expNumber}&#34; if n != str(expNumber) else E
            iX = f&#34;=/={expItem}&#34; if item != expItem else E
            if iX or nX:
                serverprint(f&#34;CAPTION {caption}: {n}{nX} {item}{iX}&#34;)
            assert n == str(expNumber)
            assert item == expItem</code></pre>
</details>
</dd>
<dt id="subtest.assertDelItem"><code class="name flex">
<span>def <span class="ident">assertDelItem</span></span>(<span>client, table, eid, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes an item from a table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string(ObjectId)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertDelItem(client, table, eid, expect):
    &#34;&#34;&#34;Deletes an item from a table.

    Parameters
    ----------
    client: fixture
    table: string
    eid: string(ObjectId)
    expect: boolean
    &#34;&#34;&#34;

    assertStatus(client, f&#34;/api/{table}/delete/{eid}&#34;, expect)</code></pre>
</details>
</dd>
<dt id="subtest.assertEditor"><code class="name flex">
<span>def <span class="ident">assertEditor</span></span>(<span>client, table, eid, valueTables, expect, clear=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the <code>editors</code> of an item to <strong>editor</strong>, or clears the <code>editors</code> field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string(ObjectId)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>valueTables</code></strong> :&ensp;<code>the store for the value tables</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>clear</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, clears the editors field.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertEditor(client, table, eid, valueTables, expect, clear=False):
    &#34;&#34;&#34;Sets the `editors` of an item to **editor**, or clears the `editors` field.

    Parameters
    ----------
    table: string
    eid: string(ObjectId)
    valueTables: the store for the value tables
    expect: boolean
    clear: boolean, optional `False`
        If True, clears the editors field.
    &#34;&#34;&#34;

    if clear:
        value = ([], &#34;&#34;)
    else:
        users = valueTables[USER]
        editorId = users[EDITOR]
        value = ([editorId], EDITOR)
    assertModifyField(client, table, eid, EDITORS, value, expect)</code></pre>
</details>
</dd>
<dt id="subtest.assertFieldValue"><code class="name flex">
<span>def <span class="ident">assertFieldValue</span></span>(<span>source, field, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify whether a field has a certain expected value.</p>
<p>If we pass expect <code>None</code> we want to assert that the field is not present at all.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>dict | (client: fixture, table: string, eid: string)</code></dt>
<dd>The dictionary of fields and values of a retrieved response.
If it is a tuple, the dictionary will be retrieved by looking up
the item specified by <code>table</code> and <code>eid</code>.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the specific field.</dd>
</dl>
<p>expect:
The expected value for this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertFieldValue(source, field, expect):
    &#34;&#34;&#34;Verify whether a field has a certain expected value.

    If we pass expect `None` we want to assert that the field is not present at all.

    Parameters
    ----------
    source: dict | (client: fixture, table: string, eid: string)
        The dictionary of fields and values of a retrieved response.
        If it is a tuple, the dictionary will be retrieved by looking up
        the item specified by `table` and `eid`.
    field: string
        The name of the specific field.
    expect:
        The expected value for this field.
    &#34;&#34;&#34;

    if type(source) is tuple:
        (client, table, eid) = source
        info = getItem(client, table, eid)
        fields = info[&#34;fields&#34;]
    else:
        fields = source

    if expect is None:
        assert field not in fields
    else:
        assert field in fields
        value = fields[field]
        if value != expect:
            serverprint(f&#34;FIELDVALUE {field}={value} (=/={expect})&#34;)
        assert expect == fields[field]</code></pre>
</details>
</dd>
<dt id="subtest.assertModifyField"><code class="name flex">
<span>def <span class="ident">assertModifyField</span></span>(<span>client, table, eid, field, newValue, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to modify a field and check the outcome.</p>
<div class="admonition note">
<p class="admonition-title">Read access</p>
<p>The test has to reckon with the fact that the client may not even have
read access to the field.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>ObjectId | string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>newValue</code></strong> :&ensp;<code>string | tuple</code></dt>
<dd>If a tuple, the first component is the modification value,
and the second component is the value we read back from the modified record</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether we expect the modification to succeed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertModifyField(client, table, eid, field, newValue, expect):
    &#34;&#34;&#34;Try to modify a field and check the outcome.

    !!! note &#34;Read access&#34;
        The test has to reckon with the fact that the client may not even have
        read access to the field.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    field: string
    newValue: string | tuple
        If a tuple, the first component is the modification value,
        and the second component is the value we read back from the modified record
    expect: boolean
        Whether we expect the modification to succeed
    &#34;&#34;&#34;

    if not expect:
        info = getItem(client, table, eid)
        fields = info[&#34;fields&#34;]
        oldValue = fields[field] if field in fields else None

    if type(newValue) is tuple:
        (newValue, newValueRep) = newValue
    else:
        newValueRep = newValue

    (text, fields) = modifyField(client, table, eid, field, newValue)

    if not expect:
        assert field not in fields

    info = getItem(client, table, eid)
    fields = info[&#34;fields&#34;]

    if expect:
        assertFieldValue(fields, field, newValueRep)
    else:
        if field in fields:
            assertFieldValue(fields, field, oldValue)</code></pre>
</details>
</dd>
<dt id="subtest.assertReviewDecisions"><code class="name flex">
<span>def <span class="ident">assertReviewDecisions</span></span>(<span>clients, reviewId, kinds, decisions, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the reviewers can take certain decisions.</p>
<p>You specify which reviewers take which decisions, and they will
all be carried out in that order.</p>
<p>You specifiy the expected outcomes in a dict or a boolean, telling
whether the taking of the decision is expected to succeed or not.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clients</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping from users to client fixtures.</dd>
<dt><strong><code>reviewId</code></strong> :&ensp;<code>dict</code></dt>
<dd>The review ids for the expert and final review</dd>
<dt><strong><code>kinds</code></strong> :&ensp;<code>list</code> of <code>{expert, final}</code></dt>
<dd>At most one of each, the order is important.</dd>
<dt><strong><code>decisions</code></strong> :&ensp;<code>list</code> of <code>{Reject, Revise, Accept, Revoke}</code></dt>
<dd>At most one of each, the order is important.</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>bool | dict</code></dt>
<dd>Expected outcomes.
If it is a boolean, that is the expected outcome of all actions by all
reviewers.
Otherwise the dict is keyed by kind of reviewer.
The values are booleans or dicts.
A boolean indicates the expected outcome of all actions for that reviewer.
A dict specifies per action of that reviewer what the outcome is.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertReviewDecisions(clients, reviewId, kinds, decisions, expect):
    &#34;&#34;&#34;Check whether the reviewers can take certain decisions.

    You specify which reviewers take which decisions, and they will
    all be carried out in that order.

    You specifiy the expected outcomes in a dict or a boolean, telling
    whether the taking of the decision is expected to succeed or not.


    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures.
    reviewId: dict
        The review ids for the expert and final review
    kinds: list of {expert, final}
        At most one of each, the order is important.
    decisions: list of {Reject, Revise, Accept, Revoke}
        At most one of each, the order is important.
    expect: bool | dict
        Expected outcomes.
        If it is a boolean, that is the expected outcome of all actions by all
        reviewers.
        Otherwise the dict is keyed by kind of reviewer.
        The values are booleans or dicts.
        A boolean indicates the expected outcome of all actions for that reviewer.
        A dict specifies per action of that reviewer what the outcome is.
    &#34;&#34;&#34;

    for kind in kinds:
        rId = G(reviewId, kind)
        expectKind = (
            True if expect is True else False if expect is False else G(expect, kind)
        )
        for decision in decisions:
            decisionStr = G(G(REVIEW_DECISION, decision), kind)
            url = f&#34;/api/task/{decisionStr}/{rId}&#34;
            exp = (
                True
                if expectKind is True
                else False
                if expectKind is False
                else G(expectKind, decision)
            )
            serverprint(f&#34;REVIEW DECISION {decision} by {kind} expects {exp}&#34;)
            assertStatus(G(clients, kind), url, exp)</code></pre>
</details>
</dd>
<dt id="subtest.assertShiftDate"><code class="name flex">
<span>def <span class="ident">assertShiftDate</span></span>(<span>clientSys, table, eid, field, amount)</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts the date in a field annd recomputes workflow.</p>
<p>See <code><a title="helpers.shiftDate" href="helpers.html#helpers.shiftDate">shiftDate()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertShiftDate(clientSys, table, eid, field, amount):
    &#34;&#34;&#34;Shifts the date in a field annd recomputes workflow.

    See `helpers.shiftDate`.
    &#34;&#34;&#34;
    shiftDate(table, eid, field, amount)
    assertStatus(clientSys, &#34;/workflow&#34;, True)</code></pre>
</details>
</dd>
<dt id="subtest.assertStage"><code class="name flex">
<span>def <span class="ident">assertStage</span></span>(<span>client, table, eid, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a record has a certain workflow stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>ObjectId | string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>string | set</code> of <code>string</code></dt>
<dd>If a set, we expect one of the values in the set</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The text, fields, msgs and stage of the record</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertStage(client, table, eid, expect):
    &#34;&#34;&#34;Check whether a record has a certain workflow stage.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    expect: string | set of string
        If a set, we expect one of the values in the set

    Returns
    -------
    dict
        The text, fields, msgs and stage of the record
    &#34;&#34;&#34;

    info = getItem(client, table, eid)
    text = info[&#34;text&#34;]
    stageFound = findStages(text)[0]
    info[&#34;stage&#34;] = stageFound
    if type(expect) is set:
        assert stageFound in expect
    else:
        assert stageFound == expect
    return info</code></pre>
</details>
</dd>
<dt id="subtest.assertStartTask"><code class="name flex">
<span>def <span class="ident">assertStartTask</span></span>(<span>client, task, eid, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Issues a start workflow command.</p>
<p>There are <code><a title="subtest.startAssessment" href="#subtest.startAssessment">startAssessment()</a></code> and <code>startReview</code> tasks that create a record,
and there are task that set a field in an existing recordd.</p>
<p>Tasks take as arguments the eid of a record in a table.</p>
<p>The response texts will be analysed into messages and fields.
For start tasks, the new eid will be read off and returned, otherwise None is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string(ObjectId)</code></dt>
<dd>The id that is the argumenent for the workflow task.</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eid</code></strong> :&ensp;<code>str(ObjectId) |</code>None``</dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertStartTask(client, task, eid, expect):
    &#34;&#34;&#34;Issues a start workflow command.

    There are `startAssessment` and `startReview` tasks that create a record,
    and there are task that set a field in an existing recordd.

    Tasks take as arguments the eid of a record in a table.

    The response texts will be analysed into messages and fields.
    For start tasks, the new eid will be read off and returned, otherwise None is returned.

    Parameters
    ----------
    client: fixture
    eid: string(ObjectId)
        The id that is the argumenent for the workflow task.
    expect: boolean

    Returns
    -------
    eid: str(ObjectId) | `None`
    &#34;&#34;&#34;

    table = (
        ASSESS if task == START_ASSESSMENT else REVIEW if task == START_REVIEW else None
    )
    assert table is not None
    assertStatus(client, f&#34;/api/task/{task}/{eid}&#34;, expect)
    newEid = None
    if expect:
        newEid = getEid(client, table)

    return newEid if task in {START_ASSESSMENT, START_REVIEW} else None</code></pre>
</details>
</dd>
<dt id="subtest.assertStatus"><code class="name flex">
<span>def <span class="ident">assertStatus</span></span>(<span>client, url, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Get data and see whether that went right or wrong.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>function</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>string(url)</code></dt>
<dd>The url to retrieve from the server</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean | int | set</code> of <code>int</code></dt>
<dd>If boolean: Whether it is expected to be successful
If int: status code should be exactly this
If set of int: status code should be contained in this</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertStatus(client, url, expect):
    &#34;&#34;&#34;Get data and see whether that went right or wrong.

    Parameters
    ----------
    client: function
    url: string(url)
        The url to retrieve from the server
    expect: boolean | int | set of int
        If boolean: Whether it is expected to be successful
        If int: status code should be exactly this
        If set of int: status code should be contained in this
    &#34;&#34;&#34;

    try:
        response = client.get(url)
        code = response.status_code
    except Exception as e:
        serverprint(f&#34;APPLICATION ERROR: {e}&#34;)
        code = 4000

    if type(expect) is set:
        good = code in expect
        if not good:
            serverprint(f&#34;STATUS {url} =&gt; {code} (not in {expect})&#34;)
        assert good
    elif type(expect) is int:
        good = code == expect
        if not good:
            serverprint(f&#34;STATUS {url} =&gt; {code} (=/= {expect})&#34;)
        assert good
    else:
        codes = {200, 302} if expect else {400, 303}
        good = code in codes
        if not good:
            serverprint(f&#34;STATUS {url} =&gt; {code} (not in {codes})&#34;)
        assert good</code></pre>
</details>
</dd>
<dt id="subtest.assignReviewers"><code class="name flex">
<span>def <span class="ident">assignReviewers</span></span>(<span>clients, users, aId, field, user, keep, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify assigning reviewers to an assessment.</p>
<p>A reviewer will be assigned to an assessment and immediately be unassigned.
But the undo can be suppressed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clients</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping from users to client fixtures</dd>
<dt><strong><code>users</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping of users to ids</dd>
<dt><strong><code>aId</code></strong> :&ensp;<code>string(ObjectId)</code></dt>
<dd>Assessment id</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>Reviewer field (<code>reviewerE</code> or <code>reviewerF</code>)</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>string</code></dt>
<dd>The reviewer user</dd>
<dt><strong><code>keep</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If True, the assignment will not be undone</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>dict</code></dt>
<dd>For each user a boolean saying whether that user can assign the reviewer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assignReviewers(clients, users, aId, field, user, keep, expect):
    &#34;&#34;&#34;Verify assigning reviewers to an assessment.

    A reviewer will be assigned to an assessment and immediately be unassigned.
    But the undo can be suppressed.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    users: dict
        Mapping of users to ids
    aId: string(ObjectId)
        Assessment id
    field: string
        Reviewer field (`reviewerE` or `reviewerF`)
    user: string
        The reviewer user
    keep: boolean
        If True, the assignment will not be undone
    expect: dict
        For each user a boolean saying whether that user can assign the reviewer
    &#34;&#34;&#34;

    value = G(users, user)

    def assertIt(cl, exp):
        assertModifyField(cl, ASSESS, aId, field, (value, user), exp)
        if exp and not keep:
            assertModifyField(cl, ASSESS, aId, field, (None, UNDEF_VALUE), True)

    forall(clients, expect, assertIt)</code></pre>
</details>
</dd>
<dt id="subtest.illegalize"><code class="name flex">
<span>def <span class="ident">illegalize</span></span>(<span>clients, url, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Append illegal/long arguments to an url and trigger a 400 response.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clients</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping from users to client fixtures</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional parameters to illegalize.
The url will be expanded by formatting it with the <code>kwargs</code> values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def illegalize(clients, url, **kwargs):
    &#34;&#34;&#34;Append illegal/long arguments to an url and trigger a 400 response.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    kwargs: dict
        Additional parameters to illegalize.
        The url will be expanded by formatting it with the `kwargs` values.
    &#34;&#34;&#34;

    kwargsx = {k: v + &#34;a&#34; * 200 for (k, v) in kwargs.items()}
    base = url.format(**kwargs)
    basex = url.format(**kwargsx)

    uxs = [
        base,
        basex,
        f&#34;{base}?action=xxx&#34;,
        f&#34;{base}?xxx=xxx&#34;,
        f&#34;{base}?action=&#34; + &#34;a&#34; * 200,
        f&#34;{base}?&#34; + &#34;a&#34; * 2000,
    ]

    passable = {200, 301, 302, 303}
    for (i, ux) in enumerate(uxs):
        expectx = {
            user: 400 if i &gt; 2 or i == 1 and len(kwargsx) else passable
            for user in USERS
            if user in clients
        }
        serverprint(f&#34;LEGAL URL ? ({ux})&#34;)
        forall(clients, expectx, assertStatus, ux)</code></pre>
</details>
</dd>
<dt id="subtest.inspectTitleAll"><code class="name flex">
<span>def <span class="ident">inspectTitleAll</span></span>(<span>clients, table, eid, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify the title of an item, as seen by each user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clients</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping from users to client fixtures</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>the table</code> of <code>the item</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>the id</code> of <code>the item</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>dict</code></dt>
<dd>The expected values, keyed per user</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inspectTitleAll(clients, table, eid, expect):
    &#34;&#34;&#34;Verify the title of an item, as seen by each user.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    table: the table of the item
    eid: the id of the item
    expect: dict
        The expected values, keyed per user
    &#34;&#34;&#34;

    def assertIt(cl, exp):
        assertFieldValue((cl, table, eid), TITLE, exp)

    forall(clients, expect, assertIt)</code></pre>
</details>
</dd>
<dt id="subtest.modifyTitleAll"><code class="name flex">
<span>def <span class="ident">modifyTitleAll</span></span>(<span>clients, table, eid, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Modify the title of an item, performed by each user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clients</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping from users to client fixtures</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>the table</code> of <code>the item</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>the id</code> of <code>the item</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>dict</code></dt>
<dd>The expected values, keyed per user</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modifyTitleAll(clients, table, eid, expect):
    &#34;&#34;&#34;Modify the title of an item, performed by each user.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    table: the table of the item
    eid: the id of the item
    expect: dict
        The expected values, keyed per user
    &#34;&#34;&#34;

    def assertIt(cl, exp):
        assertModifyField(cl, table, eid, TITLE, TITLE2, exp)
        if exp:
            assertModifyField(cl, table, eid, TITLE, TITLE1, exp)

    forall(clients, expect, assertIt)</code></pre>
</details>
</dd>
<dt id="subtest.sidebar"><code class="name flex">
<span>def <span class="ident">sidebar</span></span>(<span>clients, amounts)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify the sidebar.</p>
<p>It will be verified whether each user sees the right entries,
and that following an entry leads to the expected results.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clients</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping from users to client fixtures</dd>
<dt><strong><code>amounts</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyed by entry, it is a list of instructions to change the expected amount.
Each instruction is a pair <code>(set of users, amount)</code>, leading
to setting the indicated amount for the indicated users.
The set of users can be left out, then all users are implied.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sidebar(clients, amounts):
    &#34;&#34;&#34;Verify the sidebar.

    It will be verified whether each user sees the right entries,
    and that following an entry leads to the expected results.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    amounts: dict
        Keyed by entry, it is a list of instructions to change the expected amount.
        Each instruction is a pair `(set of users, amount)`, leading
        to setting the indicated amount for the indicated users.
        The set of users can be left out, then all users are implied.
    &#34;&#34;&#34;

    expectedCaptions = {}
    for (caption, expectedUsers, expectedN, expectedItemSg, expectedItemPl) in CAPTIONS:
        for user in expectedUsers:
            thisCaption = (
                caption.format(country=USER_COUNTRY[user])
                if &#34;{country}&#34; in caption
                else caption
            )
            n = expectedN
            for instruction in G(amounts, thisCaption, default=[]):
                if type(instruction) is tuple or type(instruction) is list:
                    (theseUsers, thisAmount) = instruction
                else:
                    (theseUsers, thisAmount) = (USERS, instruction)
                if user in theseUsers:
                    n = thisAmount
            if n is None:
                expectedItem = expectedItemSg or thisCaption
            else:
                pl = expectedItemPl or thisCaption
                sg = expectedItemSg or thisCaption[0:-1]
                expectedItem = sg if n == 1 else pl
            expectedCaptions.setdefault(user, {})[thisCaption] = (n, expectedItem)

    expect = {user: G(expectedCaptions, user) for user in USERS}
    forall(clients, expect, assertCaptions)</code></pre>
</details>
</dd>
<dt id="subtest.startAssessment"><code class="name flex">
<span>def <span class="ident">startAssessment</span></span>(<span>clients, eid, expect)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts an assessment and deletes it immediately afterwards.</p>
<p>All users in <code>clients</code> for which there is an entry in <code>expect</code> do this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clients</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping from users to client fixtures</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string(ObjectId)</code></dt>
<dd>The id of the contribution for an assessment is started</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>dict</code></dt>
<dd>Per user whether the starting of an assessment succeeds or not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startAssessment(clients, eid, expect):
    &#34;&#34;&#34;Starts an assessment and deletes it immediately afterwards.

    All users in `clients` for which there is an entry in `expect` do this.

    Parameters
    ----------
    clients: dict
        Mapping from users to client fixtures
    eid: string(ObjectId)
        The id of the contribution for an assessment is started
    expect: dict
        Per user whether the starting of an assessment succeeds or not
    &#34;&#34;&#34;

    def assertIt(cl, exp):
        aId = assertStartTask(cl, START_ASSESSMENT, eid, exp)
        if exp:
            assert aId is not None
            assertDelItem(cl, ASSESS, aId, True)
        else:
            assert aId is None

    forall(clients, expect, assertIt)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="subtest.assertAddItem" href="#subtest.assertAddItem">assertAddItem</a></code></li>
<li><code><a title="subtest.assertCaptions" href="#subtest.assertCaptions">assertCaptions</a></code></li>
<li><code><a title="subtest.assertDelItem" href="#subtest.assertDelItem">assertDelItem</a></code></li>
<li><code><a title="subtest.assertEditor" href="#subtest.assertEditor">assertEditor</a></code></li>
<li><code><a title="subtest.assertFieldValue" href="#subtest.assertFieldValue">assertFieldValue</a></code></li>
<li><code><a title="subtest.assertModifyField" href="#subtest.assertModifyField">assertModifyField</a></code></li>
<li><code><a title="subtest.assertReviewDecisions" href="#subtest.assertReviewDecisions">assertReviewDecisions</a></code></li>
<li><code><a title="subtest.assertShiftDate" href="#subtest.assertShiftDate">assertShiftDate</a></code></li>
<li><code><a title="subtest.assertStage" href="#subtest.assertStage">assertStage</a></code></li>
<li><code><a title="subtest.assertStartTask" href="#subtest.assertStartTask">assertStartTask</a></code></li>
<li><code><a title="subtest.assertStatus" href="#subtest.assertStatus">assertStatus</a></code></li>
<li><code><a title="subtest.assignReviewers" href="#subtest.assignReviewers">assignReviewers</a></code></li>
<li><code><a title="subtest.illegalize" href="#subtest.illegalize">illegalize</a></code></li>
<li><code><a title="subtest.inspectTitleAll" href="#subtest.inspectTitleAll">inspectTitleAll</a></code></li>
<li><code><a title="subtest.modifyTitleAll" href="#subtest.modifyTitleAll">modifyTitleAll</a></code></li>
<li><code><a title="subtest.sidebar" href="#subtest.sidebar">sidebar</a></code></li>
<li><code><a title="subtest.startAssessment" href="#subtest.startAssessment">startAssessment</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>