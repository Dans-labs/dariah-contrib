<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>helpers API documentation</title>
<meta name="description" content="Helpers to factor our massively redundant test code." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helpers</code></h1>
</header>
<section id="section-intro">
<p>Helpers to factor our massively redundant test code.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Helpers to factor our massively redundant test code.
&#34;&#34;&#34;

import re

from flask import json
from control.utils import serverprint


materialRe = re.compile(
    r&#34;&#34;&#34;&lt;div id=[&#39;&#34;]material[&#39;&#34;]&gt;(.*?)&lt;/div&gt;\s*&lt;/div&gt;\s*&lt;script&#34;&#34;&#34;, re.S
)
fieldRe = re.compile(&#34;&#34;&#34;&lt;!-- ([^=]+)=(.*?) --&gt;&#34;&#34;&#34;, re.S)
stageRe = re.compile(&#34;&#34;&#34;&lt;!-- stage:(.*?) --&gt;&#34;&#34;&#34;, re.S)
msgRe = re.compile(&#34;&#34;&#34;&lt;div class=&#34;msgitem.*?&gt;(.*?)&lt;/div&gt;&#34;&#34;&#34;, re.S)
eidRe = re.compile(&#34;&#34;&#34;&lt;details itemkey=[&#39;&#34;][a-zA-Z0-9_]+/([^/&#39;&#34;]*)[&#39;&#34;]&#34;&#34;&#34;, re.S)
userRe = re.compile(
    &#34;&#34;&#34;&lt;details itemkey=[&#39;&#34;]user/([^&#39;&#34;]*)[&#39;&#34;].*?&lt;summary&gt;.*?&lt;span.*?&gt;([^&lt;]*)&lt;/span&gt;&#34;&#34;&#34;,
    re.S,
)
valueRe = re.compile(&#34;&#34;&#34;eid=[&#39;&#34;](.*?)[&#39;&#34;][^&gt;]*&gt;(.*?)(?:&amp;#xa;)?&lt;&#34;&#34;&#34;, re.S)

UNDEF_VALUE = &#34;â—‹&#34;

WELCOME = &#34;Welcome to the DARIAH contribution tool&#34;
DUMMY_ID = &#34;00000000ffa4bbd9fe000f15&#34;
EXAMPLE_TYPE = &#34;activity - resource creation&#34;
EXAMPLE_TYPE2 = &#34;service - processing service&#34;
ASSESS = &#34;assessment&#34;
CRITERIA_ENTRY = &#34;criteriaEntry&#34;
NEW_A_TITLE = &#34;My contribution assessed&#34;
BELGIUM = &#34;BEðŸ‡§ðŸ‡ª&#34;
LUXEMBURG = &#34;LUðŸ‡±ðŸ‡º&#34;
CONTRIB = &#34;contrib&#34;


def forall(cls, expect, assertFunc, *args):
    &#34;&#34;&#34;Executes an assert function for a subset of all clients.

    The subset is determined by `expect`, which holds expected outcomes
    for the clients.

    Parameters
    ----------
    cls: fixture
        Contains a dict of all clients: `conftest.clients`
    assertFunc: function
        The function to be applied for each client.
        It will be passed all the `args` and a relevant part of `expect`
    expect: dict
        Keyed by user (eppn), contains the expected value for that user.
    &#34;&#34;&#34;

    for (user, exp) in expect.items():
        serverprint(f&#34;USER {user} EXPECTS {exp}&#34;)
        assertFunc(cls[user], *args, exp)


def fieldEditRe(eid, field):
    return re.compile(
        r&#34;&#34;&#34;
    &lt;span\ [^&gt;]*?eid=[&#39;&#34;]{eid}[&#39;&#34;]\s+field=[&#39;&#34;]{field}[&#39;&#34;].*?
    &lt;div\ wtype=[&#39;&#34;]related[&#39;&#34;]\ .*?
    &lt;div\ class=[&#39;&#34;]wvalue[&#39;&#34;]&gt;(.*?)&lt;/div&gt;
    &#34;&#34;&#34;.format(
            eid=eid, field=field
        ),
        re.S | re.X,
    )


def detailRe(dtable):
    return re.compile(
        r&#34;&#34;&#34;&lt;details itemkey=[&#39;&#34;]{dtable}/([^&#39;&#34;]+)[&#39;&#34;][^&gt;]*&gt;(.*?)&lt;/details&gt;&#34;&#34;&#34;.format(
            dtable=dtable
        ),
        re.S,
    )


def warningRe(label):
    return re.compile(
        r&#34;&#34;&#34;\bclass=[&#39;&#34;][^&#39;&#34;]*\bwarning\b[^&#39;&#34;]*[&#39;&#34;][^&gt;]*&gt;{label}&lt;&#34;&#34;&#34;.format(
            label=label
        ),
        re.S,
    )


def assertAddItem(client, table, expect):
    &#34;&#34;&#34;Adds an item to a table.

    The response texts will be analysed into messages and fields, the eid
    of the new item will be read off.

    Parameters
    ----------
    client: fixture
    table: string
    expect: boolean

    Returns
    -------
    text: string
        The complete response text
    fields: dict
        All fields and their values
    msgs: list
        All entries that have been flashed (and arrived in the flash bar)
    eid: str(ObjectId)
        The id of the inserted item.
    &#34;&#34;&#34;

    response = client.get(f&#34;/api/{table}/insert&#34;, follow_redirects=True)
    text = response.get_data(as_text=True)
    fields = {field: value for (field, value) in fieldRe.findall(text)}
    msgs = findMsg(text)
    eid = findEid(text)
    if expect:
        assert &#34;item added&#34; in msgs
    else:
        assert &#34;item added&#34; not in msgs
    return (text, fields, msgs, eid)


def assertDelItem(client, table, eid, expect):
    &#34;&#34;&#34;Deletes an item from a table.

    Parameters
    ----------
    client: fixture
    table: string
    eid: string(ObjectId)
    expect: boolean
    &#34;&#34;&#34;

    assertStatus(client, f&#34;/api/{table}/delete/{eid}&#34;, expect)


def assertEditor(client, table, eid, valueTables, expect, clear=False):
    &#34;&#34;&#34;Sets the `editors` of an item to **editor**, or clears the `editors` field.

    Parameters
    ----------
    table: string
    eid: string(ObjectId)
    valueTables: the store for the value tables
    expect: boolean
    clear: boolean, optional `False`
        If True, clears the editors field.
    &#34;&#34;&#34;

    if clear:
        value = ([], &#34;&#34;)
    else:
        users = valueTables[&#34;user&#34;]
        (editorId, editorName) = users[&#34;editor&#34;]
        value = ([editorId], editorName)
    assertModifyField(client, table, eid, &#34;editors&#34;, value, expect)


def assertFieldValue(source, field, expect):
    &#34;&#34;&#34;Verify whether a field has a certain expected value.

    If we pass expect `None` we want to assert that the field is not present at all.

    Parameters
    ----------
    source: dict | (client: fixture, table: string, eid: string)
        The dictionary of fields and values of a retrieved response.
        If it is a tuple, the dictionary will be retrieved by looking up
        the item specified by `table` and `eid`.
    field: string
        The name of the specific field.
    expect:
        The expected value for this field.
    &#34;&#34;&#34;

    if type(source) is tuple:
        (client, table, eid) = source
        (text, fields, msgs, dummy) = findItem(client, table, eid)
    else:
        fields = source

    if expect is None:
        assert field not in fields
    else:
        assert field in fields
        assert expect == fields[field]


def assertModifyField(client, table, eid, field, newValue, expect):
    &#34;&#34;&#34;Try to modify a field and check the outcome.

    !!! note &#34;Read access&#34;
        The test has to reckon with the fact that the client may not even have
        read access to the field.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    field: string
    newValue: string | tuple
        If a tuple, the first component is the modification value,
        and the second component is the value we read back from the modified record
    expect: boolean
        Whether we expect the modification to succeed
    &#34;&#34;&#34;

    if not expect:
        fields = findItem(client, table, eid)[1]
        oldValue = fields[field] if field in fields else None

    if type(newValue) is tuple:
        (newValue, newValueRep) = newValue
    else:
        newValueRep = newValue

    (text, fields) = modifyField(client, table, eid, field, newValue)

    if not expect:
        assert field not in fields

    (text, fields, msgs, eid) = findItem(client, table, eid)

    if expect:
        assertFieldValue(fields, field, newValueRep)
    else:
        if field in fields:
            assertFieldValue(fields, field, oldValue)


def assertMylist(client, table, eid, label, expect):
    &#34;&#34;&#34;Verify whether the client can see mylist on table.

    Mylist is retrieved, and if successful, it is also verified either that
    a record with id `eid` is in it or that the list is empty.

    Parameters
    ----------
    client: fixture
    table: string
    eid: string(objectId)
    label: string
        How a record of this table is called on the interface, in the plural
    expect: (mayList: boolean, showsUp: boolean)
        mayList means: we expect to be able to see mylist
        showsUp means: we expect the record to show up. Otherwise mylist should be
        empty.
    &#34;&#34;&#34;
    url = f&#34;/{table}/list?action=my&#34;
    (mayList, canSee) = expect
    assertStatus(client, url, mayList)
    if mayList:
        (text, status, msgs) = accessUrl(client, url, redirect=True)
        material = findMaterial(text)
        theId = findEid(text)
        if canSee:
            assert eid == theId
        else:
            assert f&#34;0 {label}&#34; in material


def assertStage(client, table, eid, expect):
    &#34;&#34;&#34;Check whether a record has a certain workflow stage.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    expect: string
    &#34;&#34;&#34;

    (text, fields, msgs, dummy) = findItem(client, table, eid)
    stageFound = findStages(text)[0]
    assert stageFound == expect
    return (text, fields, msgs, eid)


def assertStartAssessment(client, cId, expect):
    &#34;&#34;&#34;Issues the startAssessment workflow command.

    The response texts will be analysed into messages and fields, the aId
    of the new assessment will be read off.

    Parameters
    ----------
    client: fixture
    cId: string(ObjectId)
        The contribution id for which the assessment must be started.
    expect: boolean

    Returns
    -------
    aIds: list of str(ObjectId)
        The ids of all assessments of the contribution after the act.
    &#34;&#34;&#34;

    assertStatus(client, f&#34;/api/task/startAssessment/{cId}&#34;, expect)
    if expect:
        aIds = getAid(client, multiple=True)
    else:
        aIds = []
    return aIds


def assertStatus(client, url, expect):
    &#34;&#34;&#34;Get data and see whether that went right or wrong.

    Parameters
    ----------
    client: function
    url: string(url)
        The url to retrieve from the server
    expect: boolean
        Whether it is expected to be successful
    &#34;&#34;&#34;

    response = client.get(url)
    if expect:
        assert response.status_code in {200, 302}
    else:
        assert response.status_code in {400, 303}


def findDetails(text, dtable):
    &#34;&#34;&#34;Get the details from a response, but only those in a specific table.

    Parameters
    ----------
    text: string
        The response text.
    dtail: string
        The detail table

    Returns
    -------
    list of tuple of (string(id), string(html))
        The HTML for the details, chunked per detail record.
        Each chunk consists of the following parts:

        *   the entity id of that detail,
        *   the piece of HTML representing the title of the detail.
    &#34;&#34;&#34;

    result = []
    for (eid, mat) in detailRe(dtable).findall(text):
        result.append((eid, mat))
    return result


def findEid(text, multiple=False):
    &#34;&#34;&#34;Get the entity id(s) from a response.

    If the response shows a record, dig out its entity id.
    Otherwise, return `None`

    Parameters
    ----------
    text: string
        The response text.
    multiple: boolean
        Whether we should return the list of all found ids or only the first one.

    Returns
    -------
    list of string(ObjectId) | string(ObjectId) | `None`
    &#34;&#34;&#34;

    results = eidRe.findall(text)
    return results if multiple else results[0] if results else None


def findFields(text):
    &#34;&#34;&#34;Get the fields from a response.

    If the response shows a record, dig out its fields and values.

    !!! hint
        They are neatly packaged in comment lines!

    Parameters
    ----------
    text: string
        The response text.

    Returns
    -------
    dict
        Keyed by field names, valued by field values.
    &#34;&#34;&#34;

    return {field: value for (field, value) in fieldRe.findall(text)}


def findItem(client, table, eid):
    &#34;&#34;&#34;Looks up an item directly.

    The response texts will be analysed into messages and fields, the eid
    of the item will be read off.

    We assume that there is still only one item in the view.

    Parameters
    ----------
    client: fixture
    table: string
    action: string, optional `None`
        The view on the table, such as `my`, `our`.

    Returns
    -------
    text: string
        The complete response text
    fields: dict
        All fields and their values
    msgs: list
        All entries that have been flashed (and arrived in the flash bar)
    eid: str(ObjectId)
        The id of the item.
    &#34;&#34;&#34;

    url = f&#34;/{table}/item/{eid}&#34;
    response = client.get(url)
    text = response.get_data(as_text=True)
    fields = {field: value for (field, value) in fieldRe.findall(text)}
    msgs = findMsg(text)
    eid = findEid(text)
    return (text, fields, msgs, eid)


def findItemEid(client, table, action=None):
    &#34;&#34;&#34;Looks up an item from a view on a table.

    The response texts will be analysed into messages and fields, the eid
    of the item will be read off.

    We assume that there is still only one item in the view.

    Parameters
    ----------
    client: fixture
    table: string
    action: string, optional `None`
        The view on the table, such as `my`, `our`.

    Returns
    -------
    eid: str(ObjectId)
        The id of the item.
    &#34;&#34;&#34;

    actionStr = &#34;&#34; if action is None else f&#34;?action={action}&#34;
    response = client.get(f&#34;/{table}/list{actionStr}&#34;)
    text = response.get_data(as_text=True)
    eid = findEid(text)
    return eid


def findMaterial(text):
    &#34;&#34;&#34;Get the text of the material div. &#34;&#34;&#34;

    results = materialRe.findall(text)
    return results[0].strip() if results else None


def findMsg(text):
    &#34;&#34;&#34;Get flashed messages from a response.

    Parameters
    ----------
    text: string
        The response text.

    Returns
    -------
    set
        All text messages found in the flash bar.
    &#34;&#34;&#34;

    return set(msgRe.findall(text))


def findStages(text):
    &#34;&#34;&#34;Get the workflow stages from a response.

    !!! hint
        They are neatly packaged in comment lines!

    Parameters
    ----------
    text: string
        The response text.

    Returns
    -------
    list of string
    &#34;&#34;&#34;

    return stageRe.findall(text)


def findUsers(text):
    return {
        name.split()[0].lower(): (eid, name) for (eid, name) in userRe.findall(text)
    }


def getAid(cl, multiple=False):
    &#34;&#34;&#34;Gets the id(s) of the assessment(s) in the mylist view.&#34;&#34;&#34;

    url = f&#34;/{ASSESS}/list?action=my&#34;
    (text, status, msgs) = accessUrl(cl, url, redirect=True)
    return findEid(text, multiple=multiple)


def inspectTitleAll(clients, eid, expect):
    field = &#34;title&#34;

    def assertIt(cl, exp):
        assertFieldValue((cl, ASSESS, eid), field, exp)

    forall(clients, expect, assertIt)


def checkWarning(text, label):
    return not not warningRe(label).search(text)


def startWithContrib(client):
    eid = findItemEid(client, CONTRIB)
    if eid:
        result = findItem(client, CONTRIB, eid)
        return result
    return assertAddItem(client, CONTRIB, True)


def startWithAssessment(client, cId):
    aId = findItemEid(client, ASSESS)
    if aId:
        return [aId]
    return assertStartAssessment(client, cId, True)


def postJson(client, url, value):
    &#34;&#34;&#34;Post data to a url and retrieve the response text.

    Parameters
    ----------
    client: function
    url: string(url)
    value: mixed
        The value to post.
        Will be wrapped into JSON with a proper header.

    Returns
    -------
    string
        The response text
    &#34;&#34;&#34;

    response = client.post(
        url, data=json.dumps(dict(save=value)), content_type=&#34;application/json&#34;,
    )
    text = response.get_data(as_text=True)

    return text


def modifyField(client, table, eid, field, newValue):
    &#34;&#34;&#34;Post data to update a field and analyse the response for the effect.&#34;&#34;&#34;

    url = f&#34;/api/{table}/item/{eid}/field/{field}?action=view&#34;
    text = postJson(client, url, newValue)
    fields = findFields(text)
    return (text, fields)


def viewField(client, table, eid, field):
    &#34;&#34;&#34;Get the response for showing a field.&#34;&#34;&#34;

    url = f&#34;/api/{table}/item/{eid}/field/{field}?action=view&#34;
    response = client.get(url)
    text = response.get_data(as_text=True)
    fields = findFields(text)
    return (text, fields)


def accessUrl(client, url, redirect=False):
    &#34;&#34;&#34;Get the response on accessing a url.&#34;&#34;&#34;

    response = client.get(url, follow_redirects=redirect)
    text = response.get_data(as_text=True)
    status = response.status_code
    msgs = findMsg(text)
    return (text, status, msgs)


def getRelatedValues(client, table, eid, field):
    &#34;&#34;&#34;Get an editable view on a field that represents a related value.&#34;&#34;

    We check the contents.
    &#34;&#34;&#34;
    url = f&#34;/api/{table}/item/{eid}/field/{field}?action=edit&#34;
    response = client.get(url)
    text = response.get_data(as_text=True)
    thisRe = fieldEditRe(eid, field)
    valueStr = thisRe.findall(text)
    values = valueRe.findall(valueStr[0])
    valueDict = {value: eid for (eid, value) in values}
    return valueDict


def getValueTable(client, table, eid, valueTable, dest):
    &#34;&#34;&#34;Get a mapping of values in a value table to their object ids.

    We obtain the mapping by asking for an edit view of a field that
    takes values in this value table.
    Then we inspect the edit widget and read off the values and ids.

    Except for the user table, there we directly list the items.

    The mapping is stored in the dict `dest` keyed by the
    name of the valueTable.

    Parameters
    ----------
    table: string
        The name of table whose record we inspect
    eid: dict
        The id of the record
    valueTable: string
        The name of a value table which is also the name of the field in the record

    Returns
    -------
    dict
        The stored value dict for this valueTable
    &#34;&#34;&#34;

    if valueTable == &#34;user&#34;:
        response = client.get(f&#34;/user/list&#34;)
        text = response.get_data(as_text=True)
        dest[valueTable] = findUsers(text)
    else:
        valueDict = getRelatedValues(client, table, eid, valueTable)
        dest[valueTable] = valueDict
    return dest[valueTable]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="helpers.accessUrl"><code class="name flex">
<span>def <span class="ident">accessUrl</span></span>(<span>client, url, redirect=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the response on accessing a url.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accessUrl(client, url, redirect=False):
    &#34;&#34;&#34;Get the response on accessing a url.&#34;&#34;&#34;

    response = client.get(url, follow_redirects=redirect)
    text = response.get_data(as_text=True)
    status = response.status_code
    msgs = findMsg(text)
    return (text, status, msgs)</code></pre>
</details>
</dd>
<dt id="helpers.assertAddItem"><code class="name flex">
<span>def <span class="ident">assertAddItem</span></span>(<span>client, table, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds an item to a table.</p>
<p>The response texts will be analysed into messages and fields, the eid
of the new item will be read off.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>The complete response text</dd>
<dt><strong><code>fields</code></strong> :&ensp;<code>dict</code></dt>
<dd>All fields and their values</dd>
<dt><strong><code>msgs</code></strong> :&ensp;<code>list</code></dt>
<dd>All entries that have been flashed (and arrived in the flash bar)</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>str</code>(<code>ObjectId</code>)</dt>
<dd>The id of the inserted item.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertAddItem(client, table, expect):
    &#34;&#34;&#34;Adds an item to a table.

    The response texts will be analysed into messages and fields, the eid
    of the new item will be read off.

    Parameters
    ----------
    client: fixture
    table: string
    expect: boolean

    Returns
    -------
    text: string
        The complete response text
    fields: dict
        All fields and their values
    msgs: list
        All entries that have been flashed (and arrived in the flash bar)
    eid: str(ObjectId)
        The id of the inserted item.
    &#34;&#34;&#34;

    response = client.get(f&#34;/api/{table}/insert&#34;, follow_redirects=True)
    text = response.get_data(as_text=True)
    fields = {field: value for (field, value) in fieldRe.findall(text)}
    msgs = findMsg(text)
    eid = findEid(text)
    if expect:
        assert &#34;item added&#34; in msgs
    else:
        assert &#34;item added&#34; not in msgs
    return (text, fields, msgs, eid)</code></pre>
</details>
</dd>
<dt id="helpers.assertDelItem"><code class="name flex">
<span>def <span class="ident">assertDelItem</span></span>(<span>client, table, eid, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes an item from a table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string</code>(<code>ObjectId</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertDelItem(client, table, eid, expect):
    &#34;&#34;&#34;Deletes an item from a table.

    Parameters
    ----------
    client: fixture
    table: string
    eid: string(ObjectId)
    expect: boolean
    &#34;&#34;&#34;

    assertStatus(client, f&#34;/api/{table}/delete/{eid}&#34;, expect)</code></pre>
</details>
</dd>
<dt id="helpers.assertEditor"><code class="name flex">
<span>def <span class="ident">assertEditor</span></span>(<span>client, table, eid, valueTables, expect, clear=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the <code>editors</code> of an item to <strong>editor</strong>, or clears the <code>editors</code> field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string</code>(<code>ObjectId</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>valueTables</code></strong> :&ensp;<code>the</code> <code>store</code> <code>for</code> <code>the</code> <code>value</code> <code>tables</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>clear</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, clears the editors field.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertEditor(client, table, eid, valueTables, expect, clear=False):
    &#34;&#34;&#34;Sets the `editors` of an item to **editor**, or clears the `editors` field.

    Parameters
    ----------
    table: string
    eid: string(ObjectId)
    valueTables: the store for the value tables
    expect: boolean
    clear: boolean, optional `False`
        If True, clears the editors field.
    &#34;&#34;&#34;

    if clear:
        value = ([], &#34;&#34;)
    else:
        users = valueTables[&#34;user&#34;]
        (editorId, editorName) = users[&#34;editor&#34;]
        value = ([editorId], editorName)
    assertModifyField(client, table, eid, &#34;editors&#34;, value, expect)</code></pre>
</details>
</dd>
<dt id="helpers.assertFieldValue"><code class="name flex">
<span>def <span class="ident">assertFieldValue</span></span>(<span>source, field, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Verify whether a field has a certain expected value.</p>
<p>If we pass expect <code>None</code> we want to assert that the field is not present at all.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>dict</code> | (<code>client</code>: <code>fixture</code>, <code>table</code>: <code>string</code>, <code>eid</code>: <code>string</code>)</dt>
<dd>The dictionary of fields and values of a retrieved response.
If it is a tuple, the dictionary will be retrieved by looking up
the item specified by <code>table</code> and <code>eid</code>.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the specific field.</dd>
</dl>
<p>expect:
The expected value for this field.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertFieldValue(source, field, expect):
    &#34;&#34;&#34;Verify whether a field has a certain expected value.

    If we pass expect `None` we want to assert that the field is not present at all.

    Parameters
    ----------
    source: dict | (client: fixture, table: string, eid: string)
        The dictionary of fields and values of a retrieved response.
        If it is a tuple, the dictionary will be retrieved by looking up
        the item specified by `table` and `eid`.
    field: string
        The name of the specific field.
    expect:
        The expected value for this field.
    &#34;&#34;&#34;

    if type(source) is tuple:
        (client, table, eid) = source
        (text, fields, msgs, dummy) = findItem(client, table, eid)
    else:
        fields = source

    if expect is None:
        assert field not in fields
    else:
        assert field in fields
        assert expect == fields[field]</code></pre>
</details>
</dd>
<dt id="helpers.assertModifyField"><code class="name flex">
<span>def <span class="ident">assertModifyField</span></span>(<span>client, table, eid, field, newValue, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Try to modify a field and check the outcome.</p>
<div class="admonition note">
<p class="admonition-title">Read access</p>
<p>The test has to reckon with the fact that the client may not even have
read access to the field.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>ObjectId</code> | <code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>newValue</code></strong> :&ensp;<code>string</code> | <code>tuple</code></dt>
<dd>If a tuple, the first component is the modification value,
and the second component is the value we read back from the modified record</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether we expect the modification to succeed</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertModifyField(client, table, eid, field, newValue, expect):
    &#34;&#34;&#34;Try to modify a field and check the outcome.

    !!! note &#34;Read access&#34;
        The test has to reckon with the fact that the client may not even have
        read access to the field.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    field: string
    newValue: string | tuple
        If a tuple, the first component is the modification value,
        and the second component is the value we read back from the modified record
    expect: boolean
        Whether we expect the modification to succeed
    &#34;&#34;&#34;

    if not expect:
        fields = findItem(client, table, eid)[1]
        oldValue = fields[field] if field in fields else None

    if type(newValue) is tuple:
        (newValue, newValueRep) = newValue
    else:
        newValueRep = newValue

    (text, fields) = modifyField(client, table, eid, field, newValue)

    if not expect:
        assert field not in fields

    (text, fields, msgs, eid) = findItem(client, table, eid)

    if expect:
        assertFieldValue(fields, field, newValueRep)
    else:
        if field in fields:
            assertFieldValue(fields, field, oldValue)</code></pre>
</details>
</dd>
<dt id="helpers.assertMylist"><code class="name flex">
<span>def <span class="ident">assertMylist</span></span>(<span>client, table, eid, label, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Verify whether the client can see mylist on table.</p>
<p>Mylist is retrieved, and if successful, it is also verified either that
a record with id <code>eid</code> is in it or that the list is empty.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>string</code>(<code>objectId</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code></dt>
<dd>How a record of this table is called on the interface, in the plural</dd>
<dt><strong><code>expect</code></strong> :&ensp;(<code>mayList</code>: <code>boolean</code>, <code>showsUp</code>: <code>boolean</code>)</dt>
<dd>mayList means: we expect to be able to see mylist
showsUp means: we expect the record to show up. Otherwise mylist should be
empty.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertMylist(client, table, eid, label, expect):
    &#34;&#34;&#34;Verify whether the client can see mylist on table.

    Mylist is retrieved, and if successful, it is also verified either that
    a record with id `eid` is in it or that the list is empty.

    Parameters
    ----------
    client: fixture
    table: string
    eid: string(objectId)
    label: string
        How a record of this table is called on the interface, in the plural
    expect: (mayList: boolean, showsUp: boolean)
        mayList means: we expect to be able to see mylist
        showsUp means: we expect the record to show up. Otherwise mylist should be
        empty.
    &#34;&#34;&#34;
    url = f&#34;/{table}/list?action=my&#34;
    (mayList, canSee) = expect
    assertStatus(client, url, mayList)
    if mayList:
        (text, status, msgs) = accessUrl(client, url, redirect=True)
        material = findMaterial(text)
        theId = findEid(text)
        if canSee:
            assert eid == theId
        else:
            assert f&#34;0 {label}&#34; in material</code></pre>
</details>
</dd>
<dt id="helpers.assertStage"><code class="name flex">
<span>def <span class="ident">assertStage</span></span>(<span>client, table, eid, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Check whether a record has a certain workflow stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>ObjectId</code> | <code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertStage(client, table, eid, expect):
    &#34;&#34;&#34;Check whether a record has a certain workflow stage.

    Parameters
    ----------
    client: fixture
    table: string
    eid: ObjectId | string
    expect: string
    &#34;&#34;&#34;

    (text, fields, msgs, dummy) = findItem(client, table, eid)
    stageFound = findStages(text)[0]
    assert stageFound == expect
    return (text, fields, msgs, eid)</code></pre>
</details>
</dd>
<dt id="helpers.assertStartAssessment"><code class="name flex">
<span>def <span class="ident">assertStartAssessment</span></span>(<span>client, cId, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Issues the startAssessment workflow command.</p>
<p>The response texts will be analysed into messages and fields, the aId
of the new assessment will be read off.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cId</code></strong> :&ensp;<code>string</code>(<code>ObjectId</code>)</dt>
<dd>The contribution id for which the assessment must be started.</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>aIds</code></strong> :&ensp;<code>list</code> of <code>str</code>(<code>ObjectId</code>)</dt>
<dd>The ids of all assessments of the contribution after the act.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertStartAssessment(client, cId, expect):
    &#34;&#34;&#34;Issues the startAssessment workflow command.

    The response texts will be analysed into messages and fields, the aId
    of the new assessment will be read off.

    Parameters
    ----------
    client: fixture
    cId: string(ObjectId)
        The contribution id for which the assessment must be started.
    expect: boolean

    Returns
    -------
    aIds: list of str(ObjectId)
        The ids of all assessments of the contribution after the act.
    &#34;&#34;&#34;

    assertStatus(client, f&#34;/api/task/startAssessment/{cId}&#34;, expect)
    if expect:
        aIds = getAid(client, multiple=True)
    else:
        aIds = []
    return aIds</code></pre>
</details>
</dd>
<dt id="helpers.assertStatus"><code class="name flex">
<span>def <span class="ident">assertStatus</span></span>(<span>client, url, expect)</span>
</code></dt>
<dd>
<section class="desc"><p>Get data and see whether that went right or wrong.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>function</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>string</code>(<code>url</code>)</dt>
<dd>The url to retrieve from the server</dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether it is expected to be successful</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertStatus(client, url, expect):
    &#34;&#34;&#34;Get data and see whether that went right or wrong.

    Parameters
    ----------
    client: function
    url: string(url)
        The url to retrieve from the server
    expect: boolean
        Whether it is expected to be successful
    &#34;&#34;&#34;

    response = client.get(url)
    if expect:
        assert response.status_code in {200, 302}
    else:
        assert response.status_code in {400, 303}</code></pre>
</details>
</dd>
<dt id="helpers.checkWarning"><code class="name flex">
<span>def <span class="ident">checkWarning</span></span>(<span>text, label)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkWarning(text, label):
    return not not warningRe(label).search(text)</code></pre>
</details>
</dd>
<dt id="helpers.detailRe"><code class="name flex">
<span>def <span class="ident">detailRe</span></span>(<span>dtable)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detailRe(dtable):
    return re.compile(
        r&#34;&#34;&#34;&lt;details itemkey=[&#39;&#34;]{dtable}/([^&#39;&#34;]+)[&#39;&#34;][^&gt;]*&gt;(.*?)&lt;/details&gt;&#34;&#34;&#34;.format(
            dtable=dtable
        ),
        re.S,
    )</code></pre>
</details>
</dd>
<dt id="helpers.fieldEditRe"><code class="name flex">
<span>def <span class="ident">fieldEditRe</span></span>(<span>eid, field)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fieldEditRe(eid, field):
    return re.compile(
        r&#34;&#34;&#34;
    &lt;span\ [^&gt;]*?eid=[&#39;&#34;]{eid}[&#39;&#34;]\s+field=[&#39;&#34;]{field}[&#39;&#34;].*?
    &lt;div\ wtype=[&#39;&#34;]related[&#39;&#34;]\ .*?
    &lt;div\ class=[&#39;&#34;]wvalue[&#39;&#34;]&gt;(.*?)&lt;/div&gt;
    &#34;&#34;&#34;.format(
            eid=eid, field=field
        ),
        re.S | re.X,
    )</code></pre>
</details>
</dd>
<dt id="helpers.findDetails"><code class="name flex">
<span>def <span class="ident">findDetails</span></span>(<span>text, dtable)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the details from a response, but only those in a specific table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>The response text.</dd>
<dt><strong><code>dtail</code></strong> :&ensp;<code>string</code></dt>
<dd>The detail table</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tuple</code> of (<code>string</code>(<code>id</code>), <code>string</code>(<code>html</code>))</dt>
<dd>
<p>The HTML for the details, chunked per detail record.
Each chunk consists of the following parts:</p>
<ul>
<li>the entity id of that detail,</li>
<li>the piece of HTML representing the title of the detail.</li>
</ul>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findDetails(text, dtable):
    &#34;&#34;&#34;Get the details from a response, but only those in a specific table.

    Parameters
    ----------
    text: string
        The response text.
    dtail: string
        The detail table

    Returns
    -------
    list of tuple of (string(id), string(html))
        The HTML for the details, chunked per detail record.
        Each chunk consists of the following parts:

        *   the entity id of that detail,
        *   the piece of HTML representing the title of the detail.
    &#34;&#34;&#34;

    result = []
    for (eid, mat) in detailRe(dtable).findall(text):
        result.append((eid, mat))
    return result</code></pre>
</details>
</dd>
<dt id="helpers.findEid"><code class="name flex">
<span>def <span class="ident">findEid</span></span>(<span>text, multiple=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the entity id(s) from a response.</p>
<p>If the response shows a record, dig out its entity id.
Otherwise, return <code>None</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>The response text.</dd>
<dt><strong><code>multiple</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether we should return the list of all found ids or only the first one.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of string(ObjectId) | string(ObjectId) | <code>None</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findEid(text, multiple=False):
    &#34;&#34;&#34;Get the entity id(s) from a response.

    If the response shows a record, dig out its entity id.
    Otherwise, return `None`

    Parameters
    ----------
    text: string
        The response text.
    multiple: boolean
        Whether we should return the list of all found ids or only the first one.

    Returns
    -------
    list of string(ObjectId) | string(ObjectId) | `None`
    &#34;&#34;&#34;

    results = eidRe.findall(text)
    return results if multiple else results[0] if results else None</code></pre>
</details>
</dd>
<dt id="helpers.findFields"><code class="name flex">
<span>def <span class="ident">findFields</span></span>(<span>text)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the fields from a response.</p>
<p>If the response shows a record, dig out its fields and values.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>They are neatly packaged in comment lines!</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>The response text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keyed by field names, valued by field values.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findFields(text):
    &#34;&#34;&#34;Get the fields from a response.

    If the response shows a record, dig out its fields and values.

    !!! hint
        They are neatly packaged in comment lines!

    Parameters
    ----------
    text: string
        The response text.

    Returns
    -------
    dict
        Keyed by field names, valued by field values.
    &#34;&#34;&#34;

    return {field: value for (field, value) in fieldRe.findall(text)}</code></pre>
</details>
</dd>
<dt id="helpers.findItem"><code class="name flex">
<span>def <span class="ident">findItem</span></span>(<span>client, table, eid)</span>
</code></dt>
<dd>
<section class="desc"><p>Looks up an item directly.</p>
<p>The response texts will be analysed into messages and fields, the eid
of the item will be read off.</p>
<p>We assume that there is still only one item in the view.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The view on the table, such as <code>my</code>, <code>our</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>The complete response text</dd>
<dt><strong><code>fields</code></strong> :&ensp;<code>dict</code></dt>
<dd>All fields and their values</dd>
<dt><strong><code>msgs</code></strong> :&ensp;<code>list</code></dt>
<dd>All entries that have been flashed (and arrived in the flash bar)</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>str</code>(<code>ObjectId</code>)</dt>
<dd>The id of the item.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findItem(client, table, eid):
    &#34;&#34;&#34;Looks up an item directly.

    The response texts will be analysed into messages and fields, the eid
    of the item will be read off.

    We assume that there is still only one item in the view.

    Parameters
    ----------
    client: fixture
    table: string
    action: string, optional `None`
        The view on the table, such as `my`, `our`.

    Returns
    -------
    text: string
        The complete response text
    fields: dict
        All fields and their values
    msgs: list
        All entries that have been flashed (and arrived in the flash bar)
    eid: str(ObjectId)
        The id of the item.
    &#34;&#34;&#34;

    url = f&#34;/{table}/item/{eid}&#34;
    response = client.get(url)
    text = response.get_data(as_text=True)
    fields = {field: value for (field, value) in fieldRe.findall(text)}
    msgs = findMsg(text)
    eid = findEid(text)
    return (text, fields, msgs, eid)</code></pre>
</details>
</dd>
<dt id="helpers.findItemEid"><code class="name flex">
<span>def <span class="ident">findItemEid</span></span>(<span>client, table, action=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Looks up an item from a view on a table.</p>
<p>The response texts will be analysed into messages and fields, the eid
of the item will be read off.</p>
<p>We assume that there is still only one item in the view.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The view on the table, such as <code>my</code>, <code>our</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eid</code></strong> :&ensp;<code>str</code>(<code>ObjectId</code>)</dt>
<dd>The id of the item.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findItemEid(client, table, action=None):
    &#34;&#34;&#34;Looks up an item from a view on a table.

    The response texts will be analysed into messages and fields, the eid
    of the item will be read off.

    We assume that there is still only one item in the view.

    Parameters
    ----------
    client: fixture
    table: string
    action: string, optional `None`
        The view on the table, such as `my`, `our`.

    Returns
    -------
    eid: str(ObjectId)
        The id of the item.
    &#34;&#34;&#34;

    actionStr = &#34;&#34; if action is None else f&#34;?action={action}&#34;
    response = client.get(f&#34;/{table}/list{actionStr}&#34;)
    text = response.get_data(as_text=True)
    eid = findEid(text)
    return eid</code></pre>
</details>
</dd>
<dt id="helpers.findMaterial"><code class="name flex">
<span>def <span class="ident">findMaterial</span></span>(<span>text)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the text of the material div.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findMaterial(text):
    &#34;&#34;&#34;Get the text of the material div. &#34;&#34;&#34;

    results = materialRe.findall(text)
    return results[0].strip() if results else None</code></pre>
</details>
</dd>
<dt id="helpers.findMsg"><code class="name flex">
<span>def <span class="ident">findMsg</span></span>(<span>text)</span>
</code></dt>
<dd>
<section class="desc"><p>Get flashed messages from a response.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>The response text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>All text messages found in the flash bar.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findMsg(text):
    &#34;&#34;&#34;Get flashed messages from a response.

    Parameters
    ----------
    text: string
        The response text.

    Returns
    -------
    set
        All text messages found in the flash bar.
    &#34;&#34;&#34;

    return set(msgRe.findall(text))</code></pre>
</details>
</dd>
<dt id="helpers.findStages"><code class="name flex">
<span>def <span class="ident">findStages</span></span>(<span>text)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the workflow stages from a response.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>They are neatly packaged in comment lines!</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>The response text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findStages(text):
    &#34;&#34;&#34;Get the workflow stages from a response.

    !!! hint
        They are neatly packaged in comment lines!

    Parameters
    ----------
    text: string
        The response text.

    Returns
    -------
    list of string
    &#34;&#34;&#34;

    return stageRe.findall(text)</code></pre>
</details>
</dd>
<dt id="helpers.findUsers"><code class="name flex">
<span>def <span class="ident">findUsers</span></span>(<span>text)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findUsers(text):
    return {
        name.split()[0].lower(): (eid, name) for (eid, name) in userRe.findall(text)
    }</code></pre>
</details>
</dd>
<dt id="helpers.forall"><code class="name flex">
<span>def <span class="ident">forall</span></span>(<span>cls, expect, assertFunc, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Executes an assert function for a subset of all clients.</p>
<p>The subset is determined by <code>expect</code>, which holds expected outcomes
for the clients.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>fixture</code></dt>
<dd>Contains a dict of all clients: <a title="conftest.clients" href="conftest.html#conftest.clients"><code>clients()</code></a></dd>
<dt><strong><code>assertFunc</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied for each client.
It will be passed all the <code>args</code> and a relevant part of <code>expect</code></dd>
<dt><strong><code>expect</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyed by user (eppn), contains the expected value for that user.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forall(cls, expect, assertFunc, *args):
    &#34;&#34;&#34;Executes an assert function for a subset of all clients.

    The subset is determined by `expect`, which holds expected outcomes
    for the clients.

    Parameters
    ----------
    cls: fixture
        Contains a dict of all clients: `conftest.clients`
    assertFunc: function
        The function to be applied for each client.
        It will be passed all the `args` and a relevant part of `expect`
    expect: dict
        Keyed by user (eppn), contains the expected value for that user.
    &#34;&#34;&#34;

    for (user, exp) in expect.items():
        serverprint(f&#34;USER {user} EXPECTS {exp}&#34;)
        assertFunc(cls[user], *args, exp)</code></pre>
</details>
</dd>
<dt id="helpers.getAid"><code class="name flex">
<span>def <span class="ident">getAid</span></span>(<span>cl, multiple=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the id(s) of the assessment(s) in the mylist view.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAid(cl, multiple=False):
    &#34;&#34;&#34;Gets the id(s) of the assessment(s) in the mylist view.&#34;&#34;&#34;

    url = f&#34;/{ASSESS}/list?action=my&#34;
    (text, status, msgs) = accessUrl(cl, url, redirect=True)
    return findEid(text, multiple=multiple)</code></pre>
</details>
</dd>
<dt id="helpers.getRelatedValues"><code class="name flex">
<span>def <span class="ident">getRelatedValues</span></span>(<span>client, table, eid, field)</span>
</code></dt>
<dd>
<section class="desc"><p>Get an editable view on a field that represents a related value.""</p>
<p>We check the contents.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRelatedValues(client, table, eid, field):
    &#34;&#34;&#34;Get an editable view on a field that represents a related value.&#34;&#34;

    We check the contents.
    &#34;&#34;&#34;
    url = f&#34;/api/{table}/item/{eid}/field/{field}?action=edit&#34;
    response = client.get(url)
    text = response.get_data(as_text=True)
    thisRe = fieldEditRe(eid, field)
    valueStr = thisRe.findall(text)
    values = valueRe.findall(valueStr[0])
    valueDict = {value: eid for (eid, value) in values}
    return valueDict</code></pre>
</details>
</dd>
<dt id="helpers.getValueTable"><code class="name flex">
<span>def <span class="ident">getValueTable</span></span>(<span>client, table, eid, valueTable, dest)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a mapping of values in a value table to their object ids.</p>
<p>We obtain the mapping by asking for an edit view of a field that
takes values in this value table.
Then we inspect the edit widget and read off the values and ids.</p>
<p>Except for the user table, there we directly list the items.</p>
<p>The mapping is stored in the dict <code>dest</code> keyed by the
name of the valueTable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of table whose record we inspect</dd>
<dt><strong><code>eid</code></strong> :&ensp;<code>dict</code></dt>
<dd>The id of the record</dd>
<dt><strong><code>valueTable</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of a value table which is also the name of the field in the record</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The stored value dict for this valueTable</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValueTable(client, table, eid, valueTable, dest):
    &#34;&#34;&#34;Get a mapping of values in a value table to their object ids.

    We obtain the mapping by asking for an edit view of a field that
    takes values in this value table.
    Then we inspect the edit widget and read off the values and ids.

    Except for the user table, there we directly list the items.

    The mapping is stored in the dict `dest` keyed by the
    name of the valueTable.

    Parameters
    ----------
    table: string
        The name of table whose record we inspect
    eid: dict
        The id of the record
    valueTable: string
        The name of a value table which is also the name of the field in the record

    Returns
    -------
    dict
        The stored value dict for this valueTable
    &#34;&#34;&#34;

    if valueTable == &#34;user&#34;:
        response = client.get(f&#34;/user/list&#34;)
        text = response.get_data(as_text=True)
        dest[valueTable] = findUsers(text)
    else:
        valueDict = getRelatedValues(client, table, eid, valueTable)
        dest[valueTable] = valueDict
    return dest[valueTable]</code></pre>
</details>
</dd>
<dt id="helpers.inspectTitleAll"><code class="name flex">
<span>def <span class="ident">inspectTitleAll</span></span>(<span>clients, eid, expect)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inspectTitleAll(clients, eid, expect):
    field = &#34;title&#34;

    def assertIt(cl, exp):
        assertFieldValue((cl, ASSESS, eid), field, exp)

    forall(clients, expect, assertIt)</code></pre>
</details>
</dd>
<dt id="helpers.modifyField"><code class="name flex">
<span>def <span class="ident">modifyField</span></span>(<span>client, table, eid, field, newValue)</span>
</code></dt>
<dd>
<section class="desc"><p>Post data to update a field and analyse the response for the effect.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modifyField(client, table, eid, field, newValue):
    &#34;&#34;&#34;Post data to update a field and analyse the response for the effect.&#34;&#34;&#34;

    url = f&#34;/api/{table}/item/{eid}/field/{field}?action=view&#34;
    text = postJson(client, url, newValue)
    fields = findFields(text)
    return (text, fields)</code></pre>
</details>
</dd>
<dt id="helpers.postJson"><code class="name flex">
<span>def <span class="ident">postJson</span></span>(<span>client, url, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Post data to a url and retrieve the response text.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>function</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>string</code>(<code>url</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>mixed</code></dt>
<dd>The value to post.
Will be wrapped into JSON with a proper header.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The response text</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postJson(client, url, value):
    &#34;&#34;&#34;Post data to a url and retrieve the response text.

    Parameters
    ----------
    client: function
    url: string(url)
    value: mixed
        The value to post.
        Will be wrapped into JSON with a proper header.

    Returns
    -------
    string
        The response text
    &#34;&#34;&#34;

    response = client.post(
        url, data=json.dumps(dict(save=value)), content_type=&#34;application/json&#34;,
    )
    text = response.get_data(as_text=True)

    return text</code></pre>
</details>
</dd>
<dt id="helpers.startWithAssessment"><code class="name flex">
<span>def <span class="ident">startWithAssessment</span></span>(<span>client, cId)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startWithAssessment(client, cId):
    aId = findItemEid(client, ASSESS)
    if aId:
        return [aId]
    return assertStartAssessment(client, cId, True)</code></pre>
</details>
</dd>
<dt id="helpers.startWithContrib"><code class="name flex">
<span>def <span class="ident">startWithContrib</span></span>(<span>client)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startWithContrib(client):
    eid = findItemEid(client, CONTRIB)
    if eid:
        result = findItem(client, CONTRIB, eid)
        return result
    return assertAddItem(client, CONTRIB, True)</code></pre>
</details>
</dd>
<dt id="helpers.viewField"><code class="name flex">
<span>def <span class="ident">viewField</span></span>(<span>client, table, eid, field)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the response for showing a field.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewField(client, table, eid, field):
    &#34;&#34;&#34;Get the response for showing a field.&#34;&#34;&#34;

    url = f&#34;/api/{table}/item/{eid}/field/{field}?action=view&#34;
    response = client.get(url)
    text = response.get_data(as_text=True)
    fields = findFields(text)
    return (text, fields)</code></pre>
</details>
</dd>
<dt id="helpers.warningRe"><code class="name flex">
<span>def <span class="ident">warningRe</span></span>(<span>label)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warningRe(label):
    return re.compile(
        r&#34;&#34;&#34;\bclass=[&#39;&#34;][^&#39;&#34;]*\bwarning\b[^&#39;&#34;]*[&#39;&#34;][^&gt;]*&gt;{label}&lt;&#34;&#34;&#34;.format(
            label=label
        ),
        re.S,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="helpers.accessUrl" href="#helpers.accessUrl">accessUrl</a></code></li>
<li><code><a title="helpers.assertAddItem" href="#helpers.assertAddItem">assertAddItem</a></code></li>
<li><code><a title="helpers.assertDelItem" href="#helpers.assertDelItem">assertDelItem</a></code></li>
<li><code><a title="helpers.assertEditor" href="#helpers.assertEditor">assertEditor</a></code></li>
<li><code><a title="helpers.assertFieldValue" href="#helpers.assertFieldValue">assertFieldValue</a></code></li>
<li><code><a title="helpers.assertModifyField" href="#helpers.assertModifyField">assertModifyField</a></code></li>
<li><code><a title="helpers.assertMylist" href="#helpers.assertMylist">assertMylist</a></code></li>
<li><code><a title="helpers.assertStage" href="#helpers.assertStage">assertStage</a></code></li>
<li><code><a title="helpers.assertStartAssessment" href="#helpers.assertStartAssessment">assertStartAssessment</a></code></li>
<li><code><a title="helpers.assertStatus" href="#helpers.assertStatus">assertStatus</a></code></li>
<li><code><a title="helpers.checkWarning" href="#helpers.checkWarning">checkWarning</a></code></li>
<li><code><a title="helpers.detailRe" href="#helpers.detailRe">detailRe</a></code></li>
<li><code><a title="helpers.fieldEditRe" href="#helpers.fieldEditRe">fieldEditRe</a></code></li>
<li><code><a title="helpers.findDetails" href="#helpers.findDetails">findDetails</a></code></li>
<li><code><a title="helpers.findEid" href="#helpers.findEid">findEid</a></code></li>
<li><code><a title="helpers.findFields" href="#helpers.findFields">findFields</a></code></li>
<li><code><a title="helpers.findItem" href="#helpers.findItem">findItem</a></code></li>
<li><code><a title="helpers.findItemEid" href="#helpers.findItemEid">findItemEid</a></code></li>
<li><code><a title="helpers.findMaterial" href="#helpers.findMaterial">findMaterial</a></code></li>
<li><code><a title="helpers.findMsg" href="#helpers.findMsg">findMsg</a></code></li>
<li><code><a title="helpers.findStages" href="#helpers.findStages">findStages</a></code></li>
<li><code><a title="helpers.findUsers" href="#helpers.findUsers">findUsers</a></code></li>
<li><code><a title="helpers.forall" href="#helpers.forall">forall</a></code></li>
<li><code><a title="helpers.getAid" href="#helpers.getAid">getAid</a></code></li>
<li><code><a title="helpers.getRelatedValues" href="#helpers.getRelatedValues">getRelatedValues</a></code></li>
<li><code><a title="helpers.getValueTable" href="#helpers.getValueTable">getValueTable</a></code></li>
<li><code><a title="helpers.inspectTitleAll" href="#helpers.inspectTitleAll">inspectTitleAll</a></code></li>
<li><code><a title="helpers.modifyField" href="#helpers.modifyField">modifyField</a></code></li>
<li><code><a title="helpers.postJson" href="#helpers.postJson">postJson</a></code></li>
<li><code><a title="helpers.startWithAssessment" href="#helpers.startWithAssessment">startWithAssessment</a></code></li>
<li><code><a title="helpers.startWithContrib" href="#helpers.startWithContrib">startWithContrib</a></code></li>
<li><code><a title="helpers.viewField" href="#helpers.viewField">viewField</a></code></li>
<li><code><a title="helpers.warningRe" href="#helpers.warningRe">warningRe</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>