<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>starters API documentation</title>
<meta name="description" content="The start-up functions for batches of tests â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>starters</code></h1>
</header>
<section id="section-intro">
<p>The start-up functions for batches of tests.</p>
<p>We have divided the tests in batches.
Each batch is a separate file.</p>
<p>The batches can be run alltogether in sequential order,
or they can be run individually.</p>
<p>The <code><a title="starters.start" href="#starters.start">start()</a></code> function achieves that when a batch is run as part of a bigger sequence,
the initial situation for the batch is the right one.
And also, if the batch is run individually, that it starts with exactly the same
state.</p>
<h2 id="clean-slate">Clean slate</h2>
<p>The base line is clean database, i.e. a database with
all the value tables fully filled, with a set of test users,
with packages, criteria, and types, but not with user-contributed content,
such as contributions, assessments, and reviews.</p>
<p>This is the <em>clean slate</em>.</p>
<p>The starter functions may insert a few records in the database and fetch
a few value tables for usage in test functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The start-up functions for batches of tests.

We have divided the tests in batches.
Each batch is a separate file.

The batches can be run alltogether in sequential order,
or they can be run individually.

The `start` function achieves that when a batch is run as part of a bigger sequence,
the initial situation for the batch is the right one.
And also, if the batch is run individually, that it starts with exactly the same
state.

## Clean slate

The base line is clean database, i.e. a database with
all the value tables fully filled, with a set of test users,
with packages, criteria, and types, but not with user-contributed content,
such as contributions, assessments, and reviews.

This is the *clean slate*.

The starter functions may insert a few records in the database and fetch
a few value tables for usage in test functions.
&#34;&#34;&#34;

from control.utils import pick as G
from example import (
    ASSESS,
    COMMENTS,
    COMPLETE,
    CONTRIB,
    CRITERIA_ENTRY,
    CRITERIA_ENTRIES_N,
    COUNTRY,
    ELLIPS_DIV,
    EVIDENCE,
    EXPERT,
    FINAL,
    REVIEW,
    REVIEW_ENTRY,
    REVIEWER_E,
    REVIEWER_F,
    SCORE,
    START_ASSESSMENT,
    START_REVIEW,
    SUBMIT_ASSESSMENT,
    TYPE,
    TYPE1,
    TYPE2,
    USER,
)
from helpers import (
    findDetails,
    findValues,
    getItem,
    getReviewEntryId,
    getScores,
)
from subtest import (
    assertAddItem,
    assertEditor,
    assertModifyField,
    assertStage,
    assertStartTask,
    assertStatus,
)


def getValueTable(cl, table):
    &#34;&#34;&#34;Get a mapping of values in a value table to their object ids.

    We look directly in the list of items of a valueTable.

    The mapping is stored in the dict `dest` keyed by the
    name of the valueTable.

    Parameters
    ----------
    table: string
        The name of a value table

    Returns
    -------
    dict
        The stored value dict for this valueTable
    &#34;&#34;&#34;

    response = cl.get(f&#34;/{table}/list&#34;)
    text = response.get_data(as_text=True)
    return findValues(table, text)


def makeItem(cl, table, cId=None, aId=None):
    &#34;&#34;&#34;Makes a contribution/assessment/review.

    Parameters
    ----------
    cl: fixture
    table: string
        Either `contrib` or `assessment` or `review`
    cId: string(ObjectId), optional `None`
        If we make an assessment, the id of the contribution for which it is an
        assessment
    aId: string(ObjectId), optional `None`
        If we make a review, the id of the assessment for which it is a
        review

    Returns
    -------
    eid: string(ObjectId)
        the id of the contribution/assessment
    &#34;&#34;&#34;

    if table == CONTRIB:
        return assertAddItem(cl, table, True)
    if table == ASSESS:
        return assertStartTask(cl, START_ASSESSMENT, cId, True)
    if table == REVIEW:
        return assertStartTask(cl, START_REVIEW, aId, True)


def start(
    clientOffice=None,
    clientOwner=None,
    clientExpert=None,
    clientFinal=None,
    users=False,
    types=False,
    countries=False,
    contrib=False,
    assessment=False,
    fillout=False,
    submit=False,
    assign=False,
    review=False,
):
    &#34;&#34;&#34;The start sequence for a batch of tests.

    The first step is to start with a clean slate inth database:
    Only the value records, no user-contributed content.

    It depends on the batch what we have to make on top of that..

    The result is always that certain records in the database are retrieved,
    of if they do not exist, created.

    Records with user added content are stored in the dict `recordId`,
    under the name of the table as key.

    Records in value tables are stored in the dict `valueTables`,
    under the name of the table as key.

    !!! hint &#34;Dependencies of parameters&#34;
        Some things are dependent on others, for example, making an assessment
        presupposes that there is a contribution.
        The function will switch on all parameters that are implied before
        creating or finding stuff.

    Parameters
    ----------
    clientOffice, clientOwner: fixture
    users: boolean, optional `False`
        Whether to fetch the list of users
    types: boolean, optional `False`
        Whether to fetch the list of contribution types
    countries: boolean, optional `False`
        Whether to fetch the list of countries
    contrib: boolean, optional `False`
        Whether to find or make a contribution
    assessment: boolean, optional `False`
        Whether to find or make an assessment
    fillout: boolean, optional `False`
        Whether to fill out the criteria entries
    submit: boolean, optional `False`
        Whether to submit the completed assessment
    assign: boolean, optional `False`
        Whether to assign reviewers
    review: boolean, optional `False`
        Whether to start and fillout both reviews

    Returns
    -------
    valueTables: dict, optional `None`
        Where the retrieved data for the value tables end up
    recordId: dict, optional `None`
        Where the retrieved ids for the records end up
    ids: dict, optional `None`
        A resulting mapping between values in a value table and their corresponding ids
    &#34;&#34;&#34;

    if review:
        assign = True
    if assign:
        submit = True
    if submit:
        fillout = True
    if fillout:
        assessment = True
    if assessment:
        contrib = True
        types = True
    if contrib:
        users = True

    valueTables = {}
    recordId = {}
    recordInfo = {}
    ids = {}

    def startReviews():
        aId = recordId[ASSESS]
        cIds = recordId[CRITERIA_ENTRY]

        recordId.setdefault(REVIEW, {})
        clr = {EXPERT: clientExpert, FINAL: clientFinal}

        for (user, cl) in clr.items():
            rId = makeItem(cl, REVIEW, aId=aId)
            recordId[REVIEW][user] = rId

        for (user, cl) in clr.items():
            rId = recordId[REVIEW][user]
            for (i, cId) in enumerate(cIds):
                rEId = recordId[REVIEW][EXPERT]
                rFId = recordId[REVIEW][FINAL]
                reId = getReviewEntryId(clr, cId, rEId, rFId)
                reId = reId[user]
                newValue = [f&#34;{user}&#39;s comment on criteria {i + 1}&#34;]
                newValueRep = &#34;,&#34;.join(newValue)
                assertModifyField(
                    cl, REVIEW_ENTRY, reId, COMMENTS, (newValue, newValueRep), True
                )

    def startAssign():
        aId = recordId[ASSESS]
        users = G(valueTables, USER)
        for (field, user) in ((REVIEWER_E, EXPERT), (REVIEWER_F, FINAL)):
            value = G(users, user)
            assertModifyField(clientOffice, ASSESS, aId, field, (value, user), True)

        if review:
            startReviews()

    def startSubmit():
        aId = recordId[ASSESS]
        url = f&#34;/api/task/{SUBMIT_ASSESSMENT}/{aId}&#34;
        assertStatus(clientOwner, url, True)

        if assign:
            startAssign()

    def startFillout():
        aId = recordId[ASSESS]
        assessInfo = getItem(clientOwner, ASSESS, aId)
        criteriaEntries = findDetails(assessInfo[&#34;text&#34;], CRITERIA_ENTRY)
        nCId = len(criteriaEntries)
        assert nCId == CRITERIA_ENTRIES_N[TYPE1]
        cIds = []

        for (i, (cId, material)) in enumerate(criteriaEntries):
            cIds.append(cId)
            assert ELLIPS_DIV in material
            scores = getScores(cId)
            (scoreValue, scoreId) = sorted(scores.items())[1]
            assertModifyField(
                clientOwner, CRITERIA_ENTRY, cId, SCORE, (scoreId, scoreValue), True,
            )
            theEvidence = [f&#34;evidence for {i + 1}&#34;, &#34;see the internet&#34;]
            theEvidenceRep = &#34;,&#34;.join(theEvidence)
            assertModifyField(
                clientOwner,
                CRITERIA_ENTRY,
                cId,
                EVIDENCE,
                (theEvidence, theEvidenceRep),
                True,
            )
        recordId[CRITERIA_ENTRY] = cIds

        assertStage(clientOwner, ASSESS, aId, COMPLETE)

        if submit:
            startSubmit()

    def startAssessment():
        eid = recordId[CONTRIB]
        assertModifyField(
            clientOwner, CONTRIB, eid, TYPE, (ids[&#34;TYPE1&#34;], TYPE1), True,
        )
        aId = makeItem(clientOwner, ASSESS, cId=eid)
        recordId[ASSESS] = aId
        assertEditor(clientOwner, ASSESS, aId, valueTables, True)

        if fillout:
            startFillout()

    def startContrib():
        eid = makeItem(clientOwner, CONTRIB)
        recordId[CONTRIB] = eid
        assertEditor(clientOwner, CONTRIB, eid, valueTables, True)

        if assessment:
            startAssessment()

    if users:
        valueTables[USER] = getValueTable(clientOffice, USER)

    if countries:
        valueTables[COUNTRY] = getValueTable(clientOffice, COUNTRY)

    if types:
        typeValues = getValueTable(clientOffice, TYPE)
        ids[&#34;TYPE1&#34;] = typeValues[TYPE1]
        ids[&#34;TYPE2&#34;] = typeValues[TYPE2]
        valueTables[TYPE] = typeValues

    if contrib:
        startContrib()

    return dict(
        valueTables=valueTables, recordId=recordId, recordInfo=recordInfo, ids=ids
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="starters.getValueTable"><code class="name flex">
<span>def <span class="ident">getValueTable</span></span>(<span>cl, table)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a mapping of values in a value table to their object ids.</p>
<p>We look directly in the list of items of a valueTable.</p>
<p>The mapping is stored in the dict <code>dest</code> keyed by the
name of the valueTable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of a value table</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The stored value dict for this valueTable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValueTable(cl, table):
    &#34;&#34;&#34;Get a mapping of values in a value table to their object ids.

    We look directly in the list of items of a valueTable.

    The mapping is stored in the dict `dest` keyed by the
    name of the valueTable.

    Parameters
    ----------
    table: string
        The name of a value table

    Returns
    -------
    dict
        The stored value dict for this valueTable
    &#34;&#34;&#34;

    response = cl.get(f&#34;/{table}/list&#34;)
    text = response.get_data(as_text=True)
    return findValues(table, text)</code></pre>
</details>
</dd>
<dt id="starters.makeItem"><code class="name flex">
<span>def <span class="ident">makeItem</span></span>(<span>cl, table, cId=None, aId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a contribution/assessment/review.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cl</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Either <code>contrib</code> or <code>assessment</code> or <code>review</code></dd>
<dt><strong><code>cId</code></strong> :&ensp;<code>string(ObjectId)</code>, optional <code>None</code></dt>
<dd>If we make an assessment, the id of the contribution for which it is an
assessment</dd>
<dt><strong><code>aId</code></strong> :&ensp;<code>string(ObjectId)</code>, optional <code>None</code></dt>
<dd>If we make a review, the id of the assessment for which it is a
review</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eid</code></strong> :&ensp;<code>string(ObjectId)</code></dt>
<dd>the id of the contribution/assessment</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeItem(cl, table, cId=None, aId=None):
    &#34;&#34;&#34;Makes a contribution/assessment/review.

    Parameters
    ----------
    cl: fixture
    table: string
        Either `contrib` or `assessment` or `review`
    cId: string(ObjectId), optional `None`
        If we make an assessment, the id of the contribution for which it is an
        assessment
    aId: string(ObjectId), optional `None`
        If we make a review, the id of the assessment for which it is a
        review

    Returns
    -------
    eid: string(ObjectId)
        the id of the contribution/assessment
    &#34;&#34;&#34;

    if table == CONTRIB:
        return assertAddItem(cl, table, True)
    if table == ASSESS:
        return assertStartTask(cl, START_ASSESSMENT, cId, True)
    if table == REVIEW:
        return assertStartTask(cl, START_REVIEW, aId, True)</code></pre>
</details>
</dd>
<dt id="starters.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>clientOffice=None, clientOwner=None, clientExpert=None, clientFinal=None, users=False, types=False, countries=False, contrib=False, assessment=False, fillout=False, submit=False, assign=False, review=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The start sequence for a batch of tests.</p>
<p>The first step is to start with a clean slate inth database:
Only the value records, no user-contributed content.</p>
<p>It depends on the batch what we have to make on top of that..</p>
<p>The result is always that certain records in the database are retrieved,
of if they do not exist, created.</p>
<p>Records with user added content are stored in the dict <code>recordId</code>,
under the name of the table as key.</p>
<p>Records in value tables are stored in the dict <code>valueTables</code>,
under the name of the table as key.</p>
<div class="admonition hint">
<p class="admonition-title">Dependencies of parameters</p>
<p>Some things are dependent on others, for example, making an assessment
presupposes that there is a contribution.
The function will switch on all parameters that are implied before
creating or finding stuff.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clientOffice</code></strong>, <strong><code>clientOwner</code></strong> :&ensp;<code>fixture</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>users</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to fetch the list of users</dd>
<dt><strong><code>types</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to fetch the list of contribution types</dd>
<dt><strong><code>countries</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to fetch the list of countries</dd>
<dt><strong><code>contrib</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to find or make a contribution</dd>
<dt><strong><code>assessment</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to find or make an assessment</dd>
<dt><strong><code>fillout</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to fill out the criteria entries</dd>
<dt><strong><code>submit</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to submit the completed assessment</dd>
<dt><strong><code>assign</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to assign reviewers</dd>
<dt><strong><code>review</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to start and fillout both reviews</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>valueTables</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>Where the retrieved data for the value tables end up</dd>
<dt><strong><code>recordId</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>Where the retrieved ids for the records end up</dd>
<dt><strong><code>ids</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>A resulting mapping between values in a value table and their corresponding ids</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(
    clientOffice=None,
    clientOwner=None,
    clientExpert=None,
    clientFinal=None,
    users=False,
    types=False,
    countries=False,
    contrib=False,
    assessment=False,
    fillout=False,
    submit=False,
    assign=False,
    review=False,
):
    &#34;&#34;&#34;The start sequence for a batch of tests.

    The first step is to start with a clean slate inth database:
    Only the value records, no user-contributed content.

    It depends on the batch what we have to make on top of that..

    The result is always that certain records in the database are retrieved,
    of if they do not exist, created.

    Records with user added content are stored in the dict `recordId`,
    under the name of the table as key.

    Records in value tables are stored in the dict `valueTables`,
    under the name of the table as key.

    !!! hint &#34;Dependencies of parameters&#34;
        Some things are dependent on others, for example, making an assessment
        presupposes that there is a contribution.
        The function will switch on all parameters that are implied before
        creating or finding stuff.

    Parameters
    ----------
    clientOffice, clientOwner: fixture
    users: boolean, optional `False`
        Whether to fetch the list of users
    types: boolean, optional `False`
        Whether to fetch the list of contribution types
    countries: boolean, optional `False`
        Whether to fetch the list of countries
    contrib: boolean, optional `False`
        Whether to find or make a contribution
    assessment: boolean, optional `False`
        Whether to find or make an assessment
    fillout: boolean, optional `False`
        Whether to fill out the criteria entries
    submit: boolean, optional `False`
        Whether to submit the completed assessment
    assign: boolean, optional `False`
        Whether to assign reviewers
    review: boolean, optional `False`
        Whether to start and fillout both reviews

    Returns
    -------
    valueTables: dict, optional `None`
        Where the retrieved data for the value tables end up
    recordId: dict, optional `None`
        Where the retrieved ids for the records end up
    ids: dict, optional `None`
        A resulting mapping between values in a value table and their corresponding ids
    &#34;&#34;&#34;

    if review:
        assign = True
    if assign:
        submit = True
    if submit:
        fillout = True
    if fillout:
        assessment = True
    if assessment:
        contrib = True
        types = True
    if contrib:
        users = True

    valueTables = {}
    recordId = {}
    recordInfo = {}
    ids = {}

    def startReviews():
        aId = recordId[ASSESS]
        cIds = recordId[CRITERIA_ENTRY]

        recordId.setdefault(REVIEW, {})
        clr = {EXPERT: clientExpert, FINAL: clientFinal}

        for (user, cl) in clr.items():
            rId = makeItem(cl, REVIEW, aId=aId)
            recordId[REVIEW][user] = rId

        for (user, cl) in clr.items():
            rId = recordId[REVIEW][user]
            for (i, cId) in enumerate(cIds):
                rEId = recordId[REVIEW][EXPERT]
                rFId = recordId[REVIEW][FINAL]
                reId = getReviewEntryId(clr, cId, rEId, rFId)
                reId = reId[user]
                newValue = [f&#34;{user}&#39;s comment on criteria {i + 1}&#34;]
                newValueRep = &#34;,&#34;.join(newValue)
                assertModifyField(
                    cl, REVIEW_ENTRY, reId, COMMENTS, (newValue, newValueRep), True
                )

    def startAssign():
        aId = recordId[ASSESS]
        users = G(valueTables, USER)
        for (field, user) in ((REVIEWER_E, EXPERT), (REVIEWER_F, FINAL)):
            value = G(users, user)
            assertModifyField(clientOffice, ASSESS, aId, field, (value, user), True)

        if review:
            startReviews()

    def startSubmit():
        aId = recordId[ASSESS]
        url = f&#34;/api/task/{SUBMIT_ASSESSMENT}/{aId}&#34;
        assertStatus(clientOwner, url, True)

        if assign:
            startAssign()

    def startFillout():
        aId = recordId[ASSESS]
        assessInfo = getItem(clientOwner, ASSESS, aId)
        criteriaEntries = findDetails(assessInfo[&#34;text&#34;], CRITERIA_ENTRY)
        nCId = len(criteriaEntries)
        assert nCId == CRITERIA_ENTRIES_N[TYPE1]
        cIds = []

        for (i, (cId, material)) in enumerate(criteriaEntries):
            cIds.append(cId)
            assert ELLIPS_DIV in material
            scores = getScores(cId)
            (scoreValue, scoreId) = sorted(scores.items())[1]
            assertModifyField(
                clientOwner, CRITERIA_ENTRY, cId, SCORE, (scoreId, scoreValue), True,
            )
            theEvidence = [f&#34;evidence for {i + 1}&#34;, &#34;see the internet&#34;]
            theEvidenceRep = &#34;,&#34;.join(theEvidence)
            assertModifyField(
                clientOwner,
                CRITERIA_ENTRY,
                cId,
                EVIDENCE,
                (theEvidence, theEvidenceRep),
                True,
            )
        recordId[CRITERIA_ENTRY] = cIds

        assertStage(clientOwner, ASSESS, aId, COMPLETE)

        if submit:
            startSubmit()

    def startAssessment():
        eid = recordId[CONTRIB]
        assertModifyField(
            clientOwner, CONTRIB, eid, TYPE, (ids[&#34;TYPE1&#34;], TYPE1), True,
        )
        aId = makeItem(clientOwner, ASSESS, cId=eid)
        recordId[ASSESS] = aId
        assertEditor(clientOwner, ASSESS, aId, valueTables, True)

        if fillout:
            startFillout()

    def startContrib():
        eid = makeItem(clientOwner, CONTRIB)
        recordId[CONTRIB] = eid
        assertEditor(clientOwner, CONTRIB, eid, valueTables, True)

        if assessment:
            startAssessment()

    if users:
        valueTables[USER] = getValueTable(clientOffice, USER)

    if countries:
        valueTables[COUNTRY] = getValueTable(clientOffice, COUNTRY)

    if types:
        typeValues = getValueTable(clientOffice, TYPE)
        ids[&#34;TYPE1&#34;] = typeValues[TYPE1]
        ids[&#34;TYPE2&#34;] = typeValues[TYPE2]
        valueTables[TYPE] = typeValues

    if contrib:
        startContrib()

    return dict(
        valueTables=valueTables, recordId=recordId, recordInfo=recordInfo, ids=ids
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#clean-slate">Clean slate</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="starters.getValueTable" href="#starters.getValueTable">getValueTable</a></code></li>
<li><code><a title="starters.makeItem" href="#starters.makeItem">makeItem</a></code></li>
<li><code><a title="starters.start" href="#starters.start">start</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>